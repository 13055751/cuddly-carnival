var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Config: () => Config,
  apply: () => apply,
  filter: () => filter,
  inject: () => inject,
  name: () => name
});
module.exports = __toCommonJS(index_exports);
var import_koishi3 = require("koishi");
var import_console = require("@koishijs/console");
var import_path = require("path");

// src/bot.ts
var import_koishi2 = require("koishi");

// src/message.ts
var import_koishi = require("koishi");
var SandboxMessenger = class extends import_koishi.MessageEncoder {
  static {
    __name(this, "SandboxMessenger");
  }
  buffer = "";
  rules = Object.fromEntries(["image", "img", "audio", "video", "file"].map((type) => {
    return [type, async (attrs) => {
      const src = attrs.src || attrs.url;
      const type1 = type === "image" ? "img" : type;
      if (src.startsWith("file:")) {
        return (0, import_koishi.h)(type1, { ...attrs, src: `${this.bot.ctx.server.selfUrl}/sandbox/${src}` });
      }
      return (0, import_koishi.h)(type1, { ...attrs, src });
    }];
  }));
  async flush() {
    if (!this.buffer.trim()) return;
    const content = await import_koishi.h.transformAsync(this.buffer.trim(), this.rules);
    const session = this.bot.session(this.session.event);
    session.messageId = import_koishi.Random.id();
    this.bot.client.send({
      type: "sandbox/message",
      body: {
        content,
        user: "Koishi",
        channel: session.channelId,
        id: session.messageId,
        platform: session.platform
      }
    });
    this.results.push(session.event.message);
    this.buffer = "";
  }
  async visit(element) {
    const { type, children } = element;
    if (type === "message" || type === "figure") {
      await this.flush();
      await this.render(children);
      await this.flush();
    } else {
      this.buffer += element.toString();
    }
  }
};

// src/bot.ts
var SandboxBot = class extends import_koishi2.Bot {
  constructor(ctx, client, config) {
    super(ctx, config, "sandbox");
    this.client = client;
    this.selfId = config.selfId;
    this.platform = config.platform;
    this.user.name = "koishi";
  }
  static {
    __name(this, "SandboxBot");
  }
  static MessageEncoder = SandboxMessenger;
  hidden = true;
  internal = {};
  async request(method, data = {}) {
    const nonce = Math.random().toString(36).slice(2);
    return new Promise((resolve2, reject) => {
      const dispose1 = this.ctx.on("sandbox/response", (nonce2, data2) => {
        if (nonce !== nonce2) return;
        dispose1();
        dispose2();
        resolve2(data2);
      });
      const dispose2 = this.ctx.setTimeout(() => {
        dispose1();
        dispose2();
        reject(new Error("timeout"));
      }, import_koishi2.Time.second * 5);
      this.client.send({
        type: "sandbox/request",
        body: { method, data, nonce }
      });
    });
  }
  async createDirectChannel(userId) {
    return { id: "@" + userId, type: import_koishi2.Universal.Channel.Type.DIRECT };
  }
  async deleteMessage(channelId, messageId) {
    return this.request("deleteMessage", { channelId, messageId });
  }
  async getMessage(channelId, messageId) {
    return this.request("getMessage", { channelId, messageId });
  }
  async getChannel(channelId, guildId) {
    return this.request("getChannel", { channelId, guildId });
  }
  async getChannelList(guildId) {
    return this.request("getChannelList", { guildId });
  }
  async getGuild(guildId) {
    return this.request("getGuild", { guildId });
  }
  async getGuildList() {
    return this.request("getGuildList");
  }
  async getGuildMember(guildId, userId) {
    return this.request("getGuildMember", { guildId, userId });
  }
  async getGuildMemberList(guildId) {
    return this.request("getGuildMemberList", { guildId });
  }
};

// src/locales/zh-CN.yml
var zh_CN_default = { commands: { clear: { description: "清空聊天记录" } } };

// src/index.ts
var import_fs = require("fs");
var import_url = require("url");
var import_meta = {};
var filter = false;
var name = "sandbox";
var inject = ["console", "server"];
var Config = import_koishi3.Schema.object({
  fileServer: import_koishi3.Schema.object({
    enabled: import_koishi3.Schema.boolean().default(false).description("是否提供本地静态文件服务 (请勿在暴露在公网的设备上开启此选项)。")
  })
});
var SandboxService = class extends import_console.DataService {
  static {
    __name(this, "SandboxService");
  }
  static inject = ["database"];
  constructor(ctx) {
    super(ctx, "sandbox");
  }
  async get() {
    const data = await this.ctx.database.select("binding").groupBy("platform", {
      count: /* @__PURE__ */ __name((row) => import_koishi3.$.count(row.pid), "count")
    }).execute();
    return Object.fromEntries(data.map(({ platform, count }) => [platform, count]));
  }
};
function apply(ctx, config) {
  ctx.plugin(SandboxService);
  ctx.console.addEntry(process.env.KOISHI_BASE ? [
    process.env.KOISHI_BASE + "/dist/index.js",
    process.env.KOISHI_BASE + "/dist/style.css"
  ] : process.env.KOISHI_ENV === "browser" ? [
    // @ts-ignore
    import_meta.url.replace(/\/src\/[^/]+$/, "/client/index.ts")
  ] : {
    dev: (0, import_path.resolve)(__dirname, "../client/index.ts"),
    prod: (0, import_path.resolve)(__dirname, "../dist")
  });
  const bots = {};
  const createEvent = /* @__PURE__ */ __name((userId, channelId) => {
    const isDirect = channelId === "@" + userId;
    return {
      user: { id: userId, name: userId },
      channel: { id: channelId, type: isDirect ? import_koishi3.Universal.Channel.Type.DIRECT : import_koishi3.Universal.Channel.Type.TEXT },
      guild: isDirect ? void 0 : { id: channelId },
      timestamp: Date.now()
    };
  }, "createEvent");
  const ensureBot = /* @__PURE__ */ __name((platform, client) => {
    return bots[platform] ||= new SandboxBot(ctx, client, {
      platform,
      selfId: "koishi"
    });
  }, "ensureBot");
  ctx.console.addListener("sandbox/send-message", async function(platform, userId, channel, content, quote) {
    const bot = ensureBot(platform, this);
    const id = import_koishi3.Random.id();
    this.send({
      type: "sandbox/message",
      body: { id, content, user: userId, channel, platform, quote }
    });
    const session = bot.session(createEvent(userId, channel));
    session.type = "message";
    session.messageId = id;
    session.quote = quote && {
      content: quote.content,
      id: quote.id
    };
    session.content = content;
    bot.dispatch(session);
  }, { authority: 4 });
  ctx.console.addListener("sandbox/delete-message", async function(platform, userId, channel, messageId) {
    const bot = ensureBot(platform, this);
    const session = bot.session(createEvent(userId, channel));
    session.type = "message-deleted";
    session.messageId = messageId;
    bot.dispatch(session);
  }, { authority: 4 });
  ctx.console.addListener("sandbox/get-user", async function(platform, pid) {
    const database = ctx.get("database");
    if (!database) return;
    const [binding] = await database.get("binding", { platform, pid }, ["aid"]);
    if (binding) return database.getUser(platform, pid);
    return database.createUser(platform, pid, {
      authority: 1
    });
  }, { authority: 4 });
  ctx.console.addListener("sandbox/set-user", async function(platform, pid, data) {
    const bot = ensureBot(platform, this);
    const session = bot.session(createEvent(pid, "#"));
    if (data) {
      session.type = "guild-member-added";
      ctx.emit("guild-member-added", session);
    } else {
      session.type = "guild-member-removed";
      ctx.emit("guild-member-removed", session);
    }
    const database = ctx.get("database");
    if (!database) return;
    const [binding] = await database.get("binding", { platform, pid }, ["aid"]);
    if (!binding) {
      if (!data) return;
      await database.createUser(platform, pid, {
        authority: 1,
        ...data
      });
    } else if (!data) {
      await database.remove("user", binding.aid);
      await database.remove("binding", { platform, pid });
    } else {
      await database.upsert("user", [{
        id: binding.aid,
        ...data
      }]);
    }
  }, { authority: 4 });
  ctx.console.addListener("sandbox/response", (nonce, data) => {
    ctx.emit("sandbox/response", nonce, data);
  }, { authority: 4 });
  ctx.on("console/connection", async (client) => {
    if (ctx.console.clients[client.id]) return;
    for (const [platform, bot] of Object.entries(bots)) {
      if (bot.client === client) {
        delete bots[platform];
        delete ctx.bots[bot.sid];
      }
    }
  });
  if (config.fileServer.enabled) {
    ctx.server.get("/sandbox/:url(file:.+)", async (koa) => {
      const { url } = koa.params;
      koa.type = (0, import_path.extname)(url);
      koa.body = (0, import_fs.createReadStream)((0, import_url.fileURLToPath)(url));
    });
  }
  ctx.i18n.define("zh-CN", zh_CN_default);
  ctx.intersect((session) => session.platform.startsWith("sandbox:")).command("clear").action(({ session }) => {
    session.bot.client.send({
      type: "sandbox/clear"
    });
  });
}
__name(apply, "apply");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  filter,
  inject,
  name
});
//# sourceMappingURL=index.js.map
