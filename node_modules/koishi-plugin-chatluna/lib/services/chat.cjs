var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/locales/zh-CN.schema.plugin.yml
var require_zh_CN_schema_plugin = __commonJS({
  "src/locales/zh-CN.schema.plugin.yml"(exports2, module2) {
    module2.exports = { $inner: [{ $desc: "全局配置", $inner: { chatConcurrentMaxSize: "当前适配器支持的模型最大并发聊天数。", chatTimeLimit: "每小时的 API 调用次数限制。", maxRetries: "模型请求失败后的最大重试次数。", timeout: "模型请求的超时时间（毫秒）。", configMode: { $desc: "请求配置模式。", $inner: ["顺序配置模式（当前配置无效时，自动切换至下一个可用配置）。", "负载均衡模式（轮询使用所有可用配置）。"] }, proxyMode: { $desc: "当前插件的代理设置模式。", $inner: ["遵循全局代理设置", "禁用代理", "使用自定义代理设置"] } } }, [{ $desc: "代理配置", $inner: { proxyAddress: "当前插件的自定义代理地址。若指定，所有网络请求将使用此代理。若未指定，则尝试使用主插件的全局代理设置。" } }]] };
  }
});

// src/locales/en-US.schema.plugin.yml
var require_en_US_schema_plugin = __commonJS({
  "src/locales/en-US.schema.plugin.yml"(exports2, module2) {
    module2.exports = { $inner: [{ $desc: "Global Configuration", $inner: { chatConcurrentMaxSize: "Max concurrent chats for current adapter models.", chatTimeLimit: "API calls per hour limit (calls/hour).", maxRetries: "Max retries on model request failure.", timeout: "Model request timeout (ms).", configMode: { $desc: "Request config mode.", $inner: ["Sequential (auto-switch to next valid config on failure).", "Load balancing (rotate through all available configs)."] }, proxyMode: { $desc: "Plugin proxy mode.", $inner: ["Use global proxy", "Disable proxy", "Use custom proxy"] } } }, [{ $desc: "Proxy Configuration", $inner: { proxyAddress: 'Custom proxy for plugin. Overrides global proxy if set. (e.g., "http://127.0.0.1:7890" or "socks5://proxy.example.com:1080")' } }]] };
  }
});

// src/services/chat.ts
var chat_exports = {};
__export(chat_exports, {
  ChatLunaPlugin: () => ChatLunaPlugin,
  ChatLunaService: () => ChatLunaService,
  MessageTransformer: () => MessageTransformer,
  PresetFormatService: () => PresetFormatService
});
module.exports = __toCommonJS(chat_exports);
var import_messages2 = require("@langchain/core/messages");
var import_fs = __toESM(require("fs"), 1);
var import_koishi11 = require("koishi");
var import_app = require("koishi-plugin-chatluna/llm-core/chat/app");
var import_path = __toESM(require("path"), 1);
var import_lru_cache = require("lru-cache");
var import_uuid = require("uuid");

// src/cache.ts
var import_koishi = require("koishi");
var Cache = class {
  constructor(ctx, config, tableName) {
    this.config = config;
    this.tableName = tableName;
    this._cache = new DatabaseCache(ctx);
  }
  static {
    __name(this, "Cache");
  }
  _cache;
  get(tableNameOrId, id) {
    if (typeof id === "string") {
      return this._cache.get(tableNameOrId, id);
    }
    return this._cache.get(this.tableName, tableNameOrId);
  }
  set(tableNameOrId, idOrValue, value) {
    if (value != null) {
      return this._cache.set(tableNameOrId, idOrValue, value);
    }
    return this._cache.set(this.tableName, tableNameOrId, idOrValue);
  }
  delete(tableNameOrId, id) {
    if (typeof id === "string") {
      return this._cache.delete(tableNameOrId, id);
    }
    return this._cache.delete(this.tableName, tableNameOrId);
  }
  async clear(tableName) {
    if (tableName) {
      await this._cache.clear(tableName);
    } else {
      await this._cache.clear(this.tableName);
    }
  }
};
var DatabaseCache = class {
  constructor(ctx) {
    this.ctx = ctx;
    ctx.model.extend(
      "cache",
      {
        table: "string(63)",
        key: "string(63)",
        value: "text",
        expire: "timestamp"
      },
      {
        primary: ["table", "key"]
      }
    );
    ctx.setInterval(async () => {
      await ctx.database.remove("cache", { expire: { $lt: /* @__PURE__ */ new Date() } });
    }, 10 * import_koishi.Time.minute);
  }
  static {
    __name(this, "DatabaseCache");
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  encode(data) {
    return JSON.stringify(data);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  decode(record) {
    return JSON.parse(record);
  }
  async clear(table) {
    await this.ctx.database.remove("cache", { table });
  }
  async get(table, key) {
    const [entry] = await this.ctx.database.get("cache", { table, key }, [
      "expire",
      "value"
    ]);
    if (!entry) return;
    if (entry.expire && +entry.expire < Date.now()) return;
    return this.decode(entry.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async set(table, key, value, maxAge) {
    const expire = maxAge ? new Date(Date.now() + maxAge) : null;
    await this.ctx.database.upsert("cache", [
      {
        table,
        key,
        value: this.encode(value),
        expire
      }
    ]);
  }
  async delete(table, key) {
    await this.ctx.database.remove("cache", { table, key });
  }
  async *keys(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "key"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => entry.key);
  }
  async *values(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "value"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => this.decode(entry.value));
  }
  async *entries(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "key",
      "value"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => [entry.key, this.decode(entry.value)]);
  }
};

// src/chains/chain.ts
var import_events = require("events");
var import_koishi2 = require("koishi");
var import_error = require("koishi-plugin-chatluna/utils/error");
var import_logger = require("koishi-plugin-chatluna/utils/logger");

// src/middlewares/lifecycle.ts
var lifecycleNames = [
  "lifecycle-check",
  "lifecycle-prepare",
  "lifecycle-handle_command",
  "lifecycle-request_model",
  "lifecycle-send"
];

// src/chains/chain.ts
var logger;
var ChatChain = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    logger = (0, import_logger.createLogger)(ctx);
    this._graph = new ChatChainDependencyGraph();
    this._senders = [];
    const defaultChatChainSender = new DefaultChatChainSender(config);
    this._senders.push(
      (session, messages) => defaultChatChainSender.send(session, messages)
    );
  }
  static {
    __name(this, "ChatChain");
  }
  _graph;
  _senders;
  isSetErrorMessage = false;
  async receiveMessage(session, ctx) {
    const context = {
      config: this.config,
      message: session.content,
      ctx: ctx ?? this.ctx,
      session,
      options: {},
      send: /* @__PURE__ */ __name((message) => this.sendMessage(session, message), "send"),
      recallThinkingMessage: /* @__PURE__ */ __name(async () => {
      }, "recallThinkingMessage")
    };
    context.recallThinkingMessage = async () => {
      if (!context.options?.thinkingTimeoutObject) return;
      const timeoutObj = context.options.thinkingTimeoutObject;
      clearTimeout(timeoutObj.timeout);
      timeoutObj.autoRecallTimeout && clearTimeout(timeoutObj.autoRecallTimeout);
      timeoutObj.recallFunc && await timeoutObj.recallFunc();
      timeoutObj.timeout = null;
      context.options.thinkingTimeoutObject = void 0;
    };
    const result = await this._runMiddleware(session, context);
    await context.recallThinkingMessage();
    return result;
  }
  async receiveCommand(session, command, options = {}, ctx = this.ctx) {
    const context = {
      config: this.config,
      message: options?.message ?? session.content,
      ctx,
      session,
      command,
      send: /* @__PURE__ */ __name((message) => this.sendMessage(session, message), "send"),
      recallThinkingMessage: /* @__PURE__ */ __name(async () => {
      }, "recallThinkingMessage"),
      options
    };
    context.recallThinkingMessage = async () => {
      if (!context.options?.thinkingTimeoutObject) return;
      const timeoutObj = context.options.thinkingTimeoutObject;
      clearTimeout(timeoutObj.timeout);
      timeoutObj.autoRecallTimeout && clearTimeout(timeoutObj.autoRecallTimeout);
      timeoutObj.recallFunc && await timeoutObj.recallFunc();
      timeoutObj.timeout = null;
      context.options.thinkingTimeoutObject = void 0;
    };
    const result = await this._runMiddleware(session, context);
    await context.recallThinkingMessage();
    return result;
  }
  middleware(name, middleware, ctx = this.ctx) {
    const result = new ChainMiddleware(name, middleware, this._graph);
    this._graph.addNode(result);
    ctx.on("dispose", () => {
      this._graph.removeNode(name);
    });
    return result;
  }
  sender(sender) {
    this._senders.push(sender);
  }
  async _runMiddleware(session, context) {
    if (!this.isSetErrorMessage) {
      (0, import_error.setErrorFormatTemplate)(session.text("chatluna.error_message"));
      this.isSetErrorMessage = true;
    }
    const originMessage = context.message;
    const runList = this._graph.build();
    if (runList.length === 0) {
      return false;
    }
    let isOutputLog = false;
    for (const middleware of runList) {
      let result;
      const startTime = Date.now();
      try {
        result = await middleware.run(session, context);
        const shouldLogTime = !middleware.name.startsWith("lifecycle-") && result !== 0 /* SKIPPED */ && middleware.name !== "allow_reply" && Date.now() - startTime > 10;
        if (shouldLogTime) {
          logger.debug(
            `middleware %c executed in %d ms`,
            middleware.name,
            Date.now() - startTime
          );
          isOutputLog = true;
        }
        if (result === 1 /* STOP */) {
          await this.handleStopStatus(
            session,
            context,
            originMessage,
            isOutputLog
          );
          return false;
        }
        if (result instanceof Array || typeof result === "string") {
          context.message = result;
        }
      } catch (error) {
        await this.handleMiddlewareError(
          session,
          middleware.name,
          error
        );
        return false;
      }
    }
    if (isOutputLog) {
      logger.debug("-".repeat(40) + "\n");
    }
    if (context.message != null && context.message !== originMessage) {
      await this.sendMessage(session, context.message);
    }
    return true;
  }
  async sendMessage(session, message) {
    const messages = message instanceof Array ? message : [message];
    for (const sender of this._senders) {
      await sender(session, messages);
    }
  }
  async handleStopStatus(session, context, originMessage, isOutputLog) {
    if (context.message != null && context.message !== originMessage) {
      await this.sendMessage(session, context.message);
    }
    if (isOutputLog) {
      logger.debug("-".repeat(40) + "\n");
    }
  }
  async handleMiddlewareError(session, middlewareName, error) {
    if (error instanceof import_error.ChatLunaError) {
      const message = error.errorCode === import_error.ChatLunaErrorCode.ABORTED ? session.text("chatluna.aborted") : error.message;
      await this.sendMessage(session, message);
      return;
    }
    logger.error(`chat-chain: ${middlewareName} error ${error}`);
    logger.error(error);
    error.cause && logger.error(error.cause);
    logger.debug("-".repeat(40) + "\n");
    await this.sendMessage(
      session,
      session.text("chatluna.middleware_error", [
        middlewareName,
        error.message
      ])
    );
  }
};
var ChatChainDependencyGraph = class {
  static {
    __name(this, "ChatChainDependencyGraph");
  }
  _tasks = /* @__PURE__ */ new Map();
  _dependencies = /* @__PURE__ */ new Map();
  _eventEmitter = new import_events.EventEmitter();
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  _listeners = /* @__PURE__ */ new Map();
  _cachedOrder = null;
  constructor() {
    this._eventEmitter.on("build_node", () => {
      for (const [name, listeners] of this._listeners) {
        for (const listener of listeners) {
          listener(name);
        }
        listeners.clear();
      }
      this._cachedOrder = null;
    });
  }
  // Add a task to the DAG.
  addNode(middleware) {
    this._tasks.set(middleware.name, {
      name: middleware.name,
      middleware
    });
    this._cachedOrder = null;
  }
  removeNode(name) {
    this._tasks.delete(name);
    this._dependencies.delete(name);
    for (const deps of this._dependencies.values()) {
      deps.delete(name);
    }
    this._cachedOrder = null;
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  once(name, listener) {
    const listeners = this._listeners.get(name) ?? /* @__PURE__ */ new Set();
    listeners.add(listener);
    this._listeners.set(name, listeners);
  }
  // Set a dependency between two tasks
  before(taskA, taskB) {
    if (taskA instanceof ChainMiddleware) {
      taskA = taskA.name;
    }
    if (taskB instanceof ChainMiddleware) {
      taskB = taskB.name;
    }
    if (taskA && taskB) {
      const dependencies = this._dependencies.get(taskA) ?? /* @__PURE__ */ new Set();
      dependencies.add(taskB);
      this._dependencies.set(taskA, dependencies);
    } else {
      throw new Error("Invalid tasks");
    }
  }
  // Set a reverse dependency between two tasks
  after(taskA, taskB) {
    if (taskA instanceof ChainMiddleware) {
      taskA = taskA.name;
    }
    if (taskB instanceof ChainMiddleware) {
      taskB = taskB.name;
    }
    if (taskA && taskB) {
      const dependencies = this._dependencies.get(taskB) ?? /* @__PURE__ */ new Set();
      dependencies.add(taskA);
      this._dependencies.set(taskB, dependencies);
    } else {
      throw new Error("Invalid tasks");
    }
  }
  // Get dependencies of a task
  getDependencies(task) {
    return this._dependencies.get(task);
  }
  // Get dependents of a task
  getDependents(task) {
    const dependents = [];
    for (const [key, value] of this._dependencies.entries()) {
      if ([...value].includes(task)) {
        dependents.push(key);
      }
    }
    return dependents;
  }
  // Build a two-dimensional array of tasks based on their dependencies
  build() {
    if (this._cachedOrder) {
      return this._cachedOrder;
    }
    this._eventEmitter.emit("build_node");
    const indegree = /* @__PURE__ */ new Map();
    const tempGraph = /* @__PURE__ */ new Map();
    for (const taskName of this._tasks.keys()) {
      indegree.set(taskName, 0);
      tempGraph.set(taskName, /* @__PURE__ */ new Set());
    }
    for (const [from, deps] of this._dependencies.entries()) {
      const depsSet = tempGraph.get(from) || /* @__PURE__ */ new Set();
      for (const to of deps) {
        depsSet.add(to);
        indegree.set(to, (indegree.get(to) || 0) + 1);
      }
      tempGraph.set(from, depsSet);
    }
    const queue = [];
    const result = [];
    const visited = /* @__PURE__ */ new Set();
    for (const [task, degree] of indegree.entries()) {
      if (degree === 0) {
        queue.push(task);
      }
    }
    while (queue.length > 0) {
      const current = queue.shift();
      if (visited.has(current)) {
        continue;
      }
      visited.add(current);
      const node = this._tasks.get(current);
      if (node?.middleware) {
        result.push(node.middleware);
      }
      const successors = tempGraph.get(current) || /* @__PURE__ */ new Set();
      for (const next of successors) {
        const newDegree = indegree.get(next) - 1;
        indegree.set(next, newDegree);
        if (newDegree === 0) {
          queue.push(next);
        }
      }
    }
    for (const [node, degree] of indegree.entries()) {
      if (degree > 0) {
        throw new Error(
          `Circular dependency detected involving node: ${node}`
        );
      }
    }
    if (visited.size !== this._tasks.size) {
      throw new Error(
        "Some nodes are unreachable in the dependency graph"
      );
    }
    this._cachedOrder = result;
    return result;
  }
};
var ChainMiddleware = class {
  constructor(name, execute, graph) {
    this.name = name;
    this.execute = execute;
    this.graph = graph;
  }
  static {
    __name(this, "ChainMiddleware");
  }
  before(name) {
    this.graph.before(this.name, name);
    if (this.name.startsWith("lifecycle-")) {
      return this;
    }
    const lifecycleName = lifecycleNames;
    if (lifecycleName.includes(name)) {
      const lastLifecycleName = lifecycleName[lifecycleName.indexOf(name) - 1];
      if (lastLifecycleName) {
        this.graph.after(this.name, lastLifecycleName);
      }
      return this;
    }
    this.graph.once("build_node", () => {
      const beforeMiddlewares = [
        ...this.graph.getDependencies(name)
      ].filter((name2) => name2.startsWith("lifecycle-"));
      const afterMiddlewares = this.graph.getDependents(name).filter((name2) => name2.startsWith("lifecycle-"));
      for (const before of beforeMiddlewares) {
        this.graph.before(this.name, before);
      }
      for (const after of afterMiddlewares) {
        this.graph.after(this.name, after);
      }
    });
    return this;
  }
  after(name) {
    this.graph.after(this.name, name);
    if (this.name.startsWith("lifecycle-")) {
      return this;
    }
    const lifecycleName = lifecycleNames;
    if (lifecycleName.includes(name)) {
      const nextLifecycleName = lifecycleName[lifecycleName.indexOf(name) + 1];
      if (nextLifecycleName) {
        this.graph.before(this.name, nextLifecycleName);
      }
      return this;
    }
    this.graph.once("build_node", () => {
      const beforeMiddlewares = [
        ...this.graph.getDependencies(name)
      ].filter((name2) => name2.startsWith("lifecycle-"));
      const afterMiddlewares = this.graph.getDependents(name).filter((name2) => name2.startsWith("lifecycle-"));
      for (const before of beforeMiddlewares) {
        this.graph.before(this.name, before);
      }
      for (const after of afterMiddlewares) {
        this.graph.after(this.name, after);
      }
    });
    return this;
  }
  run(session, options) {
    return this.execute(session, options);
  }
};
var DefaultChatChainSender = class {
  constructor(config) {
    this.config = config;
  }
  static {
    __name(this, "DefaultChatChainSender");
  }
  processElements(elements) {
    return elements.filter((element) => {
      if (!element) return false;
      if (element.type === "img") {
        const src = element.attrs?.["src"];
        return !(typeof src === "string" && src.startsWith("attachment"));
      }
      return true;
    }).map((element) => {
      if (element.children?.length) {
        element.children = this.processElements(element.children);
      }
      return element;
    });
  }
  async send(session, messages) {
    if (!messages?.length) return;
    if (this.config.isForwardMsg) {
      await this.sendAsForward(session, messages);
      return;
    }
    await this.sendAsNormal(session, messages);
  }
  async sendAsForward(session, messages) {
    const sendMessages = this.convertToForwardMessages(messages);
    if (sendMessages.length < 1 || sendMessages.length === 1 && sendMessages.join().length === 0) {
      return;
    }
    await session.sendQueued(
      (0, import_koishi2.h)("message", { forward: true }, ...sendMessages)
    );
  }
  convertToForwardMessages(messages) {
    const firstMsg = messages[0];
    if (Array.isArray(firstMsg)) {
      return messages.map((msg) => (0, import_koishi2.h)("message", ...msg));
    }
    if (typeof firstMsg === "object") {
      return [(0, import_koishi2.h)("message", ...messages)];
    }
    if (typeof firstMsg === "string") {
      return [import_koishi2.h.text(firstMsg)];
    }
    throw new Error(`Unsupported message type: ${typeof firstMsg}`);
  }
  async sendAsNormal(session, messages) {
    for (const message of messages) {
      const messageFragment = await this.buildMessageFragment(
        session,
        message
      );
      if (!messageFragment?.length) continue;
      const processedFragment = this.processElements(messageFragment);
      await session.sendQueued(processedFragment);
    }
  }
  async buildMessageFragment(session, message) {
    const shouldAddQuote = this.config.isReplyWithAt && session.isDirect === false && session.messageId;
    const messageContent = this.convertMessageToArray(message);
    if (messageContent == null || messageContent.length < 1 || messageContent.length === 1 && messageContent.join().length === 0) {
      return;
    }
    if (!shouldAddQuote) {
      return messageContent;
    }
    const quote = (0, import_koishi2.h)("quote", { id: session.messageId });
    const hasIncompatibleType = messageContent.some(
      (element) => element.type === "audio" || element.type === "message"
    );
    return hasIncompatibleType ? messageContent : [quote, ...messageContent];
  }
  convertMessageToArray(message) {
    if (Array.isArray(message)) {
      return message;
    }
    if (typeof message === "string") {
      return [import_koishi2.h.text(message)];
    }
    return [message];
  }
};

// src/services/chat.ts
var import_config = require("koishi-plugin-chatluna/llm-core/platform/config");
var import_model = require("koishi-plugin-chatluna/llm-core/platform/model");
var import_service = require("koishi-plugin-chatluna/llm-core/platform/service");
var import_types = require("koishi-plugin-chatluna/llm-core/platform/types");
var import_count_tokens = require("koishi-plugin-chatluna/llm-core/utils/count_tokens");
var import_preset = require("koishi-plugin-chatluna/preset");
var import_error4 = require("koishi-plugin-chatluna/utils/error");
var import_queue = require("koishi-plugin-chatluna/utils/queue");

// src/services/message_transform.ts
var import_koishi_plugin_chatluna = require("koishi-plugin-chatluna");
var import_error2 = require("koishi-plugin-chatluna/utils/error");
var MessageTransformer = class {
  constructor(_config) {
    this._config = _config;
  }
  static {
    __name(this, "MessageTransformer");
  }
  _transformFunctions = {};
  async transform(session, elements, message = {
    content: "",
    additional_kwargs: {}
  }, quote = false, model) {
    for (const element of elements) {
      const transformFunction = this._transformFunctions[element.type];
      if (transformFunction != null) {
        const result = await transformFunction(
          session,
          element,
          message,
          model
        );
        if (result === false && element.children) {
          await this.transform(
            session,
            element.children,
            message,
            false,
            model
          );
        }
      } else if (element.children) {
        await this.transform(
          session,
          element.children,
          message,
          quote,
          model
        );
      }
    }
    if (session.quote && !quote && this._config.includeQuoteReply) {
      const quoteMessage = await this.transform(
        session,
        session.quote.elements ?? [],
        {
          content: "",
          additional_kwargs: {}
        },
        true,
        model
      );
      if (quoteMessage.content.length > 0 && quoteMessage.content !== "[image]") {
        message.additional_kwargs["raw_content"] = message.content;
        message.content = `The following is a quoted message: "${quoteMessage.content}"

Please consider this quote when generating your response. User's message: ${message.content}`;
      }
      if (quoteMessage.additional_kwargs["images"]) {
        const currentImages = message.additional_kwargs["images"] ?? [];
        const currentImageHashs = message.additional_kwargs["imageHashs"] ?? [];
        message.additional_kwargs["images"] = [
          ...currentImages,
          ...quoteMessage.additional_kwargs["images"]
        ];
        message.additional_kwargs["imageHashs"] = [
          ...currentImageHashs,
          ...quoteMessage.additional_kwargs["imageHashs"]
        ];
      }
    }
    return message;
  }
  intercept(type, transformFunction) {
    if (type === "text" && this._transformFunctions["text"] != null) {
      throw new import_error2.ChatLunaError(
        import_error2.ChatLunaErrorCode.UNKNOWN_ERROR,
        new Error("text transform function already exists")
      );
    }
    if (this._transformFunctions[type] != null && !["img"].includes(type)) {
      import_koishi_plugin_chatluna.logger?.warn(
        `transform function for ${type} already exists. Check your installed plugins.`
      );
    }
    this._transformFunctions[type] = transformFunction;
    return () => {
      delete this._transformFunctions[type];
    };
  }
  replace(type, transformFunction) {
    if (type === "text") {
      throw new import_error2.ChatLunaError(
        import_error2.ChatLunaErrorCode.UNKNOWN_ERROR,
        new Error("text transform function already exists")
      );
    }
    if (this._transformFunctions[type] == null) {
      import_koishi_plugin_chatluna.logger?.warn(
        `transform function for ${type} not exists. Check your installed plugins.`
      );
    }
    this._transformFunctions[type] = transformFunction;
    return () => {
      delete this._transformFunctions[type];
    };
  }
  has(type) {
    return this._transformFunctions[type] != null;
  }
};

// src/services/chat.ts
var import_request = require("koishi-plugin-chatluna/utils/request");

// src/render.ts
var import_koishi9 = require("koishi");
var import_error3 = require("koishi-plugin-chatluna/utils/error");

// src/renders/default.ts
var Renderer = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "Renderer");
  }
};

// src/renders/text.ts
var import_koishi_plugin_markdown = require("koishi-plugin-markdown");
var import_koishi3 = require("koishi");
var import_he = __toESM(require("he"), 1);
var TextRenderer = class extends Renderer {
  static {
    __name(this, "TextRenderer");
  }
  async render(message, options) {
    let transformed = transformAndEscape(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return (0, import_koishi3.h)("message", element);
      });
    }
    if (transformed[0]?.type === "p") {
      const pElement = transformed.shift();
      const pElementContent = pElement.attrs["content"];
      if (pElementContent) {
        transformed.unshift(import_koishi3.h.text(pElementContent));
      } else {
        transformed.unshift(...pElement.children);
      }
    }
    return {
      element: transformed
    };
  }
  schema = import_koishi3.Schema.const("text").i18n({
    "zh-CN": "将回复作为 markdown 进行渲染",
    "en-US": "Render as markdown"
  });
};
function unescape(element) {
  if (element.type === "text") {
    element.attrs["content"] = import_he.default.decode(element.attrs["content"]);
  }
  if (element.children && element.children.length > 0) {
    element.children = element.children.map(unescape);
  }
  return element;
}
__name(unescape, "unescape");
function transformAndEscape(source) {
  const transformed = (0, import_koishi_plugin_markdown.transform)(source).map(unescape);
  return transformed;
}
__name(transformAndEscape, "transformAndEscape");

// src/renders/voice.ts
var import_marked = require("marked");
var import_koishi_plugin_chatluna2 = require("koishi-plugin-chatluna");
var import_koishi4 = require("koishi");
var VoiceRenderer = class extends Renderer {
  static {
    __name(this, "VoiceRenderer");
  }
  async render(message, options) {
    const splitMessages = this._splitMessage(message.content).flatMap((text) => text.trim().split("\n\n")).filter((text) => text.length > 0);
    import_koishi_plugin_chatluna2.logger?.debug(`splitMessages: ${JSON.stringify(splitMessages)}`);
    if (options.split) {
      return {
        element: await Promise.all(
          splitMessages.map(async (text) => {
            return (0, import_koishi4.h)(
              "message",
              await this._renderToVoice(text, options)
            );
          })
        )
      };
    } else {
      return {
        element: await this._renderToVoice(
          splitMessages.join(""),
          options
        )
      };
    }
  }
  _splitMessage(message) {
    const tokens = renderTokens(import_marked.marked.lexer(message));
    if (tokens.length === 0 || tokens[0].length === 0) {
      return [message];
    }
    return tokens;
  }
  _renderToVoice(text, options) {
    return this.ctx.vits.say(
      Object.assign(
        {
          speaker_id: options?.voice?.speakerId ?? 0,
          input: text
        },
        {
          session: options.session
        }
      )
    );
  }
  schema = import_koishi4.Schema.const("voice").i18n({
    "zh-CN": "将回复渲染为语音",
    "en-US": "Render as voice"
  });
};
function renderToken(token) {
  if (token.type === "text" || //     token.type === "space" ||
  token.type === "heading" || token.type === "em" || token.type === "strong" || token.type === "del" || token.type === "codespan" || token.type === "list_item" || token.type === "blockquote" || token.type === "code") {
    return token.text;
  }
  return token.raw;
}
__name(renderToken, "renderToken");
function renderTokens(tokens) {
  return tokens.map(renderToken);
}
__name(renderTokens, "renderTokens");

// src/renders/raw.ts
var import_koishi5 = require("koishi");
var RawRenderer = class extends Renderer {
  static {
    __name(this, "RawRenderer");
  }
  async render(message, options) {
    return {
      element: import_koishi5.h.text(message.content)
    };
  }
  schema = import_koishi5.Schema.const("raw").i18n({
    "zh-CN": "原始输出",
    "en-US": "Raw text"
  });
};

// src/renders/koishi-element.ts
var import_koishi6 = require("koishi");
var import_he2 = __toESM(require("he"), 1);
var import_koishi_plugin_chatluna3 = require("koishi-plugin-chatluna");
var KoishiElementRenderer = class extends Renderer {
  static {
    __name(this, "KoishiElementRenderer");
  }
  async render(message, options) {
    let transformed = transformAndEscape2(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return (0, import_koishi6.h)("message", element);
      });
    }
    return {
      element: transformed
    };
  }
  schema = import_koishi6.Schema.const("koishi-element").i18n({
    "zh-CN": "将回复作为 koishi 消息元素进行渲染",
    "en-US": "Render as koishi message element template"
  });
};
function unescape2(element) {
  if (element.type === "text") {
    element.attrs["content"] = import_he2.default.decode(element.attrs["content"]);
  }
  if (element.children && element.children.length > 0) {
    element.children = element.children.map(unescape2);
  }
  return element;
}
__name(unescape2, "unescape");
function transformAndEscape2(source) {
  try {
    return import_koishi6.h.parse(source).map(unescape2);
  } catch (e) {
    import_koishi_plugin_chatluna3.logger.error(e);
    return [import_koishi6.h.text(source)];
  }
}
__name(transformAndEscape2, "transformAndEscape");

// src/renders/mixed-voice.ts
var import_marked2 = require("marked");
var import_koishi_plugin_chatluna4 = require("koishi-plugin-chatluna");
var import_koishi7 = require("koishi");
var MixedVoiceRenderer = class extends Renderer {
  static {
    __name(this, "MixedVoiceRenderer");
  }
  async render(message, options) {
    const elements = [];
    const renderText = (await this.renderText(message, options)).element;
    if (renderText instanceof Array) {
      elements.push(...renderText);
    } else {
      elements.push(renderText);
    }
    const renderVoice = (await this.renderVoice(message, options)).element;
    if (renderVoice instanceof Array) {
      elements.push(...renderVoice);
    } else {
      elements.push(renderVoice);
    }
    return {
      element: elements
    };
  }
  async renderText(message, options) {
    let transformed = transformAndEscape(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return (0, import_koishi7.h)("message", element);
      });
    }
    return {
      element: transformed
    };
  }
  async renderVoice(message, options) {
    const splitMessages = this._splitMessage(message.content).flatMap((text) => text.trim().split("\n\n")).filter((text) => text.length > 0);
    import_koishi_plugin_chatluna4.logger?.debug(`splitMessages: ${JSON.stringify(splitMessages)}`);
    return {
      element: await this._renderToVoice(splitMessages.join(""), options)
    };
  }
  _splitMessage(message) {
    const tokens = renderTokens2(import_marked2.marked.lexer(message));
    if (tokens.length === 0 || tokens[0].length === 0) {
      return [message];
    }
    return tokens;
  }
  _renderToVoice(text, options) {
    return this.ctx.vits.say(
      Object.assign(
        {
          speaker_id: options?.voice?.speakerId ?? 0,
          input: text
        },
        {
          session: options.session
        }
      )
    );
  }
  schema = import_koishi7.Schema.const("mixed-voice").i18n({
    "zh-CN": "同时输出语音和文本",
    "en-US": "Output both voice and text"
  });
};
function renderToken2(token) {
  if (token.type === "text" || //     token.type === "space" ||
  token.type === "heading" || token.type === "em" || token.type === "strong" || token.type === "del" || token.type === "codespan" || token.type === "list_item" || token.type === "blockquote") {
    return token.text;
  }
  return token.raw;
}
__name(renderToken2, "renderToken");
function renderTokens2(tokens) {
  return tokens.map(renderToken2);
}
__name(renderTokens2, "renderTokens");

// src/renders/pure-text.ts
var import_koishi_plugin_markdown2 = require("koishi-plugin-markdown");
var import_koishi8 = require("koishi");

// src/utils/remove-markdown.ts
function removeMarkdown(md, options = {}) {
  options.listUnicodeChar = Object.prototype.hasOwnProperty.call(
    options,
    "listUnicodeChar"
  ) ? options.listUnicodeChar : false;
  options.stripListLeaders = Object.prototype.hasOwnProperty.call(
    options,
    "stripListLeaders"
  ) ? options.stripListLeaders : true;
  options.gfm = Object.prototype.hasOwnProperty.call(options, "gfm") ? options.gfm : true;
  options.useImgAltText = Object.prototype.hasOwnProperty.call(
    options,
    "useImgAltText"
  ) ? options.useImgAltText : true;
  options.abbr = Object.prototype.hasOwnProperty.call(options, "abbr") ? options.abbr : false;
  options.replaceLinksWithURL = Object.prototype.hasOwnProperty.call(
    options,
    "replaceLinksWithURL"
  ) ? options.replaceLinksWithURL : false;
  options.htmlTagsToSkip = Object.prototype.hasOwnProperty.call(
    options,
    "htmlTagsToSkip"
  ) ? options.htmlTagsToSkip : [];
  options.throwError = Object.prototype.hasOwnProperty.call(
    options,
    "throwError"
  ) ? options.throwError : false;
  let output = md || "";
  output = output.replace(
    /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/gm,
    ""
  );
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(
          /^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,
          options.listUnicodeChar + " $1"
        );
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/```(?:.*)\n([\s\S]*?)```/g, (_, code) => code.trim());
    }
    if (options.abbr) {
      output = output.replace(/\*\[.*\]:.*\n/, "");
    }
    let htmlReplaceRegex = /<[^>]*>/g;
    if (options.htmlTagsToSkip && options.htmlTagsToSkip.length > 0) {
      const joinedHtmlTagsToSkip = options.htmlTagsToSkip.join("|");
      htmlReplaceRegex = new RegExp(
        `<(?!/?(${joinedHtmlTagsToSkip})(?=>|s[^>]*>))[^>]*>`,
        "g"
      );
    }
    output = output.replace(htmlReplaceRegex, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(
      /\!\[(.*?)\][\[\(].*?[\]\)]/g,
      options.useImgAltText ? "$1" : ""
    ).replace(
      /\[([\s\S]*?)\]\s*[\(\[].*?[\)\]]/g,
      options.replaceLinksWithURL ? "$2" : "$1"
    ).replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(
      /^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm,
      "$1$3$4$6"
    ).replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    if (options.throwError) throw e;
    console.error("remove-markdown encountered error: %s", e);
    return md;
  }
  return output;
}
__name(removeMarkdown, "removeMarkdown");

// src/renders/pure-text.ts
var import_he3 = __toESM(require("he"), 1);
var PureTextRenderer = class extends Renderer {
  static {
    __name(this, "PureTextRenderer");
  }
  async render(message, options) {
    let transformed = [import_koishi8.h.text(message.content)];
    if (options.split) {
      transformed = transformed.flatMap((element) => {
        const content = element.attrs["content"];
        return content.split("\n\n\n").map((paragraph) => {
          return import_koishi8.h.text(paragraph);
        });
      });
    }
    transformed = transformed.map((element) => {
      const content = element.attrs["content"];
      return import_koishi8.h.text(stripMarkdown(content));
    });
    return {
      element: transformed
    };
  }
  schema = import_koishi8.Schema.const("pure-text").i18n({
    "zh-CN": "将回复渲染为纯文本（去除 markdown 格式）",
    "en-US": "Render as pure text (remove markdown format)"
  });
};
function stripMarkdown(source) {
  return removeMarkdown(source);
}
__name(stripMarkdown, "stripMarkdown");

// src/render.ts
var DefaultRenderer = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.defaultOptions = {
      type: config.outputMode,
      split: config.splitMessage,
      voice: {
        speakerId: config.voiceSpeakId
      }
    };
    ctx.inject(["chatluna"], (ctx2) => {
      this.addRenderer("text", () => new TextRenderer(ctx2));
      this.addRenderer("voice", () => new VoiceRenderer(ctx2));
      this.addRenderer("raw", () => new RawRenderer(ctx2));
      this.addRenderer("mixed-voice", () => new MixedVoiceRenderer(ctx2));
      this.addRenderer(
        "koishi-element",
        () => new KoishiElementRenderer(ctx2)
      );
      this.addRenderer("pure-text", () => new PureTextRenderer(ctx2));
    });
  }
  static {
    __name(this, "DefaultRenderer");
  }
  defaultOptions;
  renderers = {};
  async render(message, options = this.defaultOptions) {
    try {
      const result = [];
      const currentRenderer = await this.getRenderer(options.type);
      const rawRenderer = options.type === "raw" ? currentRenderer : await this.getRenderer("raw");
      if (message.additionalReplyMessages) {
        for (const additionalMessage of message.additionalReplyMessages) {
          const elements = await rawRenderer.render(additionalMessage, options).then((r) => r.element);
          result.push({
            element: (0, import_koishi9.h)(
              "message",
              { forward: true },
              Array.isArray(elements) ? elements : [elements]
            )
          });
        }
      }
      result.push(await currentRenderer.render(message, options));
      return result;
    } catch (e) {
      throw new import_error3.ChatLunaError(import_error3.ChatLunaErrorCode.RENDER_ERROR, e);
    }
  }
  addRenderer(type, renderer) {
    this.renderers[type] = renderer(this.ctx, this.config);
    this.updateSchema();
    return () => this.removeRenderer(type);
  }
  removeRenderer(type) {
    delete this.renderers[type];
    this.updateSchema();
  }
  async getRenderer(type) {
    return this.renderers[type];
  }
  updateSchema() {
    if (!this.ctx.scope.isActive) {
      return;
    }
    this.ctx.schema.set(
      "output-mode",
      import_koishi9.Schema.union(this._getAllRendererScheme())
    );
  }
  _getAllRendererScheme() {
    return Object.values(this.renderers).map((key) => key.schema);
  }
  get rendererTypeList() {
    return Object.keys(this.renderers);
  }
};

// src/services/chat.ts
var import_promise = require("koishi-plugin-chatluna/utils/promise");
var import_in_memory = require("koishi-plugin-chatluna/llm-core/model/in_memory");

// src/services/variable.ts
var import_messages = require("@langchain/core/messages");
var import_koishi10 = require("koishi");
var import_koishi_plugin_chatluna5 = require("koishi-plugin-chatluna");
var import_string = require("koishi-plugin-chatluna/utils/string");
var import_prompt = require("koishi-plugin-chatluna/llm-core/prompt");
var PresetFormatService = class {
  static {
    __name(this, "PresetFormatService");
  }
  _functionHandlers = {};
  _variableProviders = [];
  _staticVariables = {};
  constructor() {
    this._initBuiltinFunctions();
  }
  _initBuiltinFunctions() {
    this._functionHandlers["time_UTC"] = (args) => {
      const date = /* @__PURE__ */ new Date();
      const utcOffset = args[0] ? parseInt(args[0]) : 0;
      if (isNaN(utcOffset)) {
        import_koishi_plugin_chatluna5.logger.warn(`Invalid UTC offset: ${args[0]}`);
        return "Invalid UTC offset";
      }
      const offsetDate = new Date(+date + utcOffset * import_koishi10.Time.hour);
      return offsetDate.toISOString().replace("T", " ").slice(0, -5);
    };
    this._functionHandlers["timeDiff"] = (args) => {
      return (0, import_string.getTimeDiff)(args[0], args[1]);
    };
    this._functionHandlers["date"] = () => {
      const date = /* @__PURE__ */ new Date();
      const offsetDate = new Date(
        +date - date.getTimezoneOffset() * import_koishi10.Time.minute
      );
      return offsetDate.toISOString().split("T")[0];
    };
    this._functionHandlers["weekday"] = () => {
      const date = /* @__PURE__ */ new Date();
      return [
        "Sunday",
        "Monday",
        "Tuesday",
        "Wednesday",
        "Thursday",
        "Friday",
        "Saturday"
      ][date.getDay()];
    };
    this._functionHandlers["isotime"] = () => {
      const date = /* @__PURE__ */ new Date();
      const offsetDate = new Date(
        +date - date.getTimezoneOffset() * import_koishi10.Time.minute
      );
      return offsetDate.toISOString().slice(11, 19);
    };
    this._functionHandlers["isodate"] = () => {
      const date = /* @__PURE__ */ new Date();
      const offsetDate = new Date(
        +date - date.getTimezoneOffset() * import_koishi10.Time.minute
      );
      return offsetDate.toISOString().split("T")[0];
    };
    this._functionHandlers["random"] = (args) => {
      if (args.length === 2) {
        const [min, max] = args.map(Number);
        if (!isNaN(min) && !isNaN(max)) {
          return Math.floor(
            Math.random() * (max - min + 1) + min
          ).toString();
        }
      }
      return (0, import_string.selectFromList)(args.join(","), false);
    };
    this._functionHandlers["pick"] = (args) => {
      return (0, import_string.selectFromList)(args.join(","), true);
    };
    this._functionHandlers["roll"] = (args) => {
      return (0, import_string.rollDice)(args[0]).toString();
    };
    this._functionHandlers["url"] = async (args) => {
      return await (0, import_string.fetchUrl)(
        args[1],
        args[0],
        args[2],
        parseInt(args[3] ?? "1000")
      );
    };
  }
  registerFunction(name, handler) {
    if (this._functionHandlers[name] != null) {
      import_koishi_plugin_chatluna5.logger.warn(
        `Function handler for ${name} already exists. It will be replaced.`
      );
    }
    this._functionHandlers[name] = handler;
    return () => {
      delete this._functionHandlers[name];
    };
  }
  replaceFunction(name, handler) {
    if (this._functionHandlers[name] == null) {
      import_koishi_plugin_chatluna5.logger.warn(`Function handler for ${name} not exists.`);
    }
    this._functionHandlers[name] = handler;
    return () => {
      delete this._functionHandlers[name];
    };
  }
  hasFunction(name) {
    return this._functionHandlers[name] != null;
  }
  registerVariableProvider(provider) {
    this._variableProviders.push(provider);
    return () => {
      const index = this._variableProviders.indexOf(provider);
      if (index !== -1) {
        this._variableProviders.splice(index, 1);
      }
    };
  }
  setVariable(name, value) {
    this._staticVariables[name] = value;
  }
  getVariable(name) {
    return this._staticVariables[name];
  }
  removeVariable(name) {
    delete this._staticVariables[name];
  }
  _getAllVariables(inputVariables) {
    let allVariables = { ...this._staticVariables, ...inputVariables };
    for (const provider of this._variableProviders) {
      const providerVariables = provider();
      allVariables = { ...allVariables, ...providerVariables };
    }
    return allVariables;
  }
  async _evaluateFunction(func, args, inputVariables, session) {
    const handler = this._functionHandlers[func];
    if (handler) {
      const processedArgs = await Promise.all(
        args.map(async (arg) => {
          return await this.formatPresetTemplateString(
            arg,
            inputVariables,
            [],
            session
          );
        })
      );
      const result = await handler(processedArgs, inputVariables, session);
      return result;
    }
    return `{${func}${args.length ? ":" + args.join("::") : ""}}`;
  }
  async formatPresetTemplateString(rawString, inputVariables = {}, variables = [], session) {
    const allVariables = this._getAllVariables(inputVariables);
    const tokens = (0, import_prompt.tokenize)(rawString);
    const results = await Promise.all(
      tokens.map(async (token) => {
        switch (token.type) {
          case "text":
            return token.value;
          case "variable": {
            variables.push(token.value);
            let value = allVariables[token.value];
            if (typeof value === "function") value = value();
            if (Promise.resolve(value) instanceof Promise) {
              value = await value;
            }
            let result = value;
            if (!result) {
              result = "";
              import_koishi_plugin_chatluna5.logger.warn(`Variable ${token.value} not found`);
            }
            return result;
          }
          case "function": {
            variables.push(token.value);
            return await this._evaluateFunction(
              token.value,
              token.args,
              allVariables,
              session
            );
          }
        }
      })
    );
    return results.join("");
  }
  async formatMessages(messages, variables = {}, session) {
    return await Promise.all(
      messages.map(async (message) => {
        const content = await this.formatPresetTemplateString(
          message.content,
          variables,
          [],
          session
        );
        const messageInstance = new {
          human: import_messages.HumanMessage,
          ai: import_messages.AIMessage,
          system: import_messages.SystemMessage
        }[message.getType()]({
          content,
          additional_kwargs: message.additional_kwargs
        });
        return messageInstance;
      })
    );
  }
  async formatPresetTemplate(presetTemplate, inputVariables = {}, returnVariables = false, session) {
    const variables = [];
    const formattedMessages = await Promise.all(
      presetTemplate.messages.map(async (message) => {
        const content = await this.formatPresetTemplateString(
          message.content,
          inputVariables,
          variables,
          session
        );
        const messageInstance = new {
          human: import_messages.HumanMessage,
          ai: import_messages.AIMessage,
          system: import_messages.SystemMessage
        }[message.getType()]({
          content,
          additional_kwargs: message.additional_kwargs
        });
        return messageInstance;
      })
    );
    if (returnVariables) {
      return [formattedMessages, variables];
    }
    return formattedMessages;
  }
  getFunctionNames() {
    return Object.keys(this._functionHandlers);
  }
  getVariableNames() {
    return Object.keys(this._staticVariables);
  }
};

// src/services/chat.ts
var ChatLunaService = class extends import_koishi11.Service {
  constructor(ctx, config) {
    super(ctx, "chatluna");
    this.ctx = ctx;
    this.config = config;
    this._chain = new ChatChain(ctx, config);
    this._keysCache = new Cache(this.ctx, config, "chathub/keys");
    this._preset = new import_preset.PresetService(ctx, config, this._keysCache);
    this._platformService = new import_service.PlatformService(ctx);
    this._messageTransformer = new MessageTransformer(config);
    this._renderer = new DefaultRenderer(ctx, config);
    this._variable = new PresetFormatService();
    this._createTempDir();
    this._defineDatabase();
  }
  static {
    __name(this, "ChatLunaService");
  }
  _plugins = {};
  _chatInterfaceWrapper;
  _chain;
  _keysCache;
  _preset;
  _platformService;
  _messageTransformer;
  _renderer;
  _variable;
  async registerPlugin(plugin) {
    const platformName = plugin.platformName;
    if (this._plugins[platformName]) {
      throw new import_error4.ChatLunaError(
        import_error4.ChatLunaErrorCode.PLUGIN_ALREADY_REGISTERED,
        new Error(`Plugin ${platformName} already registered`)
      );
    }
    this._plugins[platformName] = plugin;
    this.logger.success(`register plugin %c`, plugin.platformName);
  }
  async awaitLoadPlatform(plugin, timeout = 3e4) {
    const pluginName = typeof plugin === "string" ? plugin : plugin.platformName;
    const { promise, resolve, reject } = (0, import_promise.withResolver)();
    if (this._platformService.getModels(pluginName, import_types.ModelType.all).length > 0) {
      resolve();
      return promise;
    }
    const timeoutId = setTimeout(() => {
      dispose();
      reject(
        new Error(`Timeout waiting for platform ${pluginName} to load`)
      );
    }, timeout);
    const dispose = this.ctx.on(
      "chatluna/model-added",
      (service, platform) => {
        if (platform === pluginName) {
          clearTimeout(timeoutId);
          resolve();
          dispose();
        }
      }
    );
    return promise;
  }
  unregisterPlugin(plugin) {
    const platformName = typeof plugin === "string" ? plugin : plugin.platformName;
    const targetPlugin = this._plugins[platformName];
    if (!targetPlugin) {
      return;
    }
    const platform = targetPlugin.platformName;
    this._chatInterfaceWrapper?.dispose(platform);
    targetPlugin.dispose();
    delete this._plugins[platform];
    this.logger.success("unregister plugin %c", targetPlugin.platformName);
  }
  getPlugin(platformName) {
    return this._plugins[platformName];
  }
  chat(session, room, message, event, stream = false, variables = {}, postHandler, requestId = (0, import_uuid.v4)()) {
    const chatInterfaceWrapper = this._chatInterfaceWrapper ?? this._createChatInterfaceWrapper();
    return chatInterfaceWrapper.chat(
      session,
      room,
      message,
      event,
      stream,
      requestId,
      variables,
      postHandler
    );
  }
  async stopChat(room, requestId) {
    const chatInterfaceWrapper = this.queryInterfaceWrapper(room, false);
    if (chatInterfaceWrapper == null) {
      return void 0;
    }
    return chatInterfaceWrapper.stopChat(requestId);
  }
  queryInterfaceWrapper(room, autoCreate = true) {
    return this._chatInterfaceWrapper ?? (autoCreate ? this._createChatInterfaceWrapper() : void 0);
  }
  async clearChatHistory(room) {
    const chatBridger = this._chatInterfaceWrapper ?? this._createChatInterfaceWrapper();
    return chatBridger.clearChatHistory(room);
  }
  getCachedInterfaceWrapper() {
    return this._chatInterfaceWrapper;
  }
  async clearCache(room) {
    const chatBridger = this._chatInterfaceWrapper ?? this._createChatInterfaceWrapper();
    return chatBridger.clearCache(room);
  }
  async createChatModel(platformName, model) {
    const service = this._platformService;
    const client = await service.randomClient(platformName);
    if (client == null) {
      throw new import_error4.ChatLunaError(
        import_error4.ChatLunaErrorCode.MODEL_ADAPTER_NOT_FOUND,
        new Error(`The platform ${platformName} no available`)
      );
    }
    return client.createModel(model);
  }
  randomChatModel(platformName, model) {
    return async () => await this.createChatModel(platformName, model);
  }
  async createEmbeddings(platformName, modelName) {
    const service = this._platformService;
    const client = await service.randomClient(platformName);
    if (client == null) {
      this.logger.warn(`The platform ${platformName} no available`);
      return new import_in_memory.EmptyEmbeddings();
    }
    const model = client.createModel(modelName);
    if (model instanceof import_model.ChatHubBaseEmbeddings) {
      return model;
    }
    throw new import_error4.ChatLunaError(
      import_error4.ChatLunaErrorCode.MODEL_NOT_FOUND,
      new Error(`The model ${modelName} is not embeddings`)
    );
  }
  randomEmbeddings(platformName, modelName) {
    return async () => await this.createEmbeddings(platformName, modelName);
  }
  get platform() {
    return this._platformService;
  }
  get cache() {
    return this._keysCache;
  }
  get preset() {
    return this._preset;
  }
  get chatChain() {
    return this._chain;
  }
  get messageTransformer() {
    return this._messageTransformer;
  }
  get renderer() {
    return this._renderer;
  }
  get variable() {
    return this._variable;
  }
  async stop() {
    for (const plugin of Object.values(this._plugins)) {
      this.unregisterPlugin(plugin);
    }
    this._chatInterfaceWrapper?.dispose();
    this._platformService.dispose();
  }
  _createTempDir() {
    const tempPath = import_path.default.resolve(this.ctx.baseDir, "data/chathub/temp");
    if (!import_fs.default.existsSync(tempPath)) {
      import_fs.default.mkdirSync(tempPath, { recursive: true });
    }
  }
  _defineDatabase() {
    const ctx = this.ctx;
    ctx.database.extend(
      "chathub_conversation",
      {
        id: {
          type: "char",
          length: 255
        },
        latestId: {
          type: "char",
          length: 255,
          nullable: true
        },
        additional_kwargs: {
          type: "text",
          nullable: true
        },
        updatedAt: {
          type: "timestamp",
          nullable: false,
          initial: /* @__PURE__ */ new Date()
        }
      },
      {
        autoInc: false,
        primary: "id",
        unique: ["id"]
      }
    );
    ctx.database.extend(
      "chathub_message",
      {
        id: {
          type: "char",
          length: 255
        },
        text: "text",
        parent: {
          type: "char",
          length: 255,
          nullable: true
        },
        role: {
          type: "char",
          length: 20
        },
        conversation: {
          type: "char",
          length: 255
        },
        additional_kwargs: {
          type: "text",
          nullable: true
        },
        additional_kwargs_binary: {
          type: "binary",
          nullable: true
        },
        rawId: {
          type: "char",
          length: 255,
          nullable: true
        }
      },
      {
        autoInc: false,
        primary: "id",
        unique: ["id"]
        /*  foreign: {
            conversation: ['chathub_conversaion', 'id']
        } */
      }
    );
    ctx.database.extend(
      "chathub_room",
      {
        roomId: {
          type: "integer"
        },
        roomName: "string",
        conversationId: {
          type: "char",
          length: 255,
          nullable: true
        },
        roomMasterId: {
          type: "char",
          length: 255
        },
        visibility: {
          type: "char",
          length: 20
        },
        preset: {
          type: "char",
          length: 255
        },
        model: {
          type: "char",
          length: 100
        },
        chatMode: {
          type: "char",
          length: 20
        },
        password: {
          type: "char",
          length: 100
        },
        autoUpdate: {
          type: "boolean",
          initial: false
        },
        updatedTime: {
          type: "timestamp",
          nullable: false,
          initial: /* @__PURE__ */ new Date()
        }
      },
      {
        autoInc: false,
        primary: "roomId",
        unique: ["roomId"]
      }
    );
    ctx.database.extend(
      "chathub_room_member",
      {
        userId: {
          type: "char",
          length: 255
        },
        roomId: {
          type: "integer"
        },
        roomPermission: {
          type: "char",
          length: 50
        },
        mute: {
          type: "boolean",
          initial: false
        }
      },
      {
        autoInc: false,
        primary: ["userId", "roomId"]
      }
    );
    ctx.database.extend(
      "chathub_room_group_member",
      {
        groupId: {
          type: "char",
          length: 255
        },
        roomId: {
          type: "integer"
        },
        roomVisibility: {
          type: "char",
          length: 20
        }
      },
      {
        autoInc: false,
        primary: ["groupId", "roomId"]
      }
    );
    ctx.database.extend(
      "chathub_user",
      {
        userId: {
          type: "char",
          length: 255
        },
        defaultRoomId: {
          type: "integer"
        },
        groupId: {
          type: "char",
          length: 255,
          nullable: true
        }
      },
      {
        autoInc: false,
        primary: ["userId", "groupId"]
      }
    );
  }
  _createChatInterfaceWrapper() {
    const chatBridger = new ChatInterfaceWrapper(this);
    this._chatInterfaceWrapper = chatBridger;
    return chatBridger;
  }
  static inject = ["database"];
};
var ChatLunaPlugin = class {
  constructor(ctx, config, platformName, createConfigPool = true) {
    this.ctx = ctx;
    this.config = config;
    this.platformName = platformName;
    ctx.once("dispose", async () => {
      ctx.chatluna.unregisterPlugin(this);
    });
    if (createConfigPool) {
      this._platformConfigPool = new import_config.ClientConfigPool(
        ctx,
        config.configMode === "default" ? import_config.ClientConfigPoolMode.AlwaysTheSame : import_config.ClientConfigPoolMode.LoadBalancing
      );
    }
    this._platformService = ctx.chatluna.platform;
  }
  static {
    __name(this, "ChatLunaPlugin");
  }
  _disposables = [];
  _supportModels = [];
  _platformConfigPool;
  _platformService;
  async parseConfig(f) {
    const configs = f(this.config);
    for (const config of configs) {
      await this._platformConfigPool.addConfig(config);
    }
  }
  async initClients() {
    this._platformService.registerConfigPool(
      this.platformName,
      this._platformConfigPool
    );
    try {
      await this._platformService.createClients(this.platformName);
    } catch (e) {
      this.ctx.chatluna.unregisterPlugin(this);
      throw e;
    }
    this._supportModels = this._supportModels.concat(
      this._platformService.getModels(this.platformName, import_types.ModelType.llm).map((model) => `${this.platformName}/${model.name}`)
    );
  }
  async initClientsWithPool(platformName, pool, createConfigFunc) {
    const configs = createConfigFunc(this.config);
    for (const config of configs) {
      await pool.addConfig(config);
    }
    this._platformService.registerConfigPool(platformName, pool);
    try {
      await this._platformService.createClients(platformName);
    } catch (e) {
      this.ctx.chatluna.unregisterPlugin(this);
      throw e;
    }
    this._supportModels = this._supportModels.concat(
      this._platformService.getModels(platformName, import_types.ModelType.llm).map((model) => `${platformName}/${model.name}`)
    );
  }
  get supportedModels() {
    return this._supportModels;
  }
  dispose() {
    while (this._disposables.length > 0) {
      const disposable = this._disposables.pop();
      disposable();
    }
  }
  registerConfigPool(platformName, configPool) {
    this._platformService.registerConfigPool(platformName, configPool);
  }
  registerToService() {
    this.ctx.chatluna.registerPlugin(this);
  }
  registerClient(func, platformName = this.platformName) {
    const disposable = this._platformService.registerClient(
      platformName,
      func
    );
    this._disposables.push(disposable);
  }
  registerVectorStore(name, func) {
    const disposable = this._platformService.registerVectorStore(name, func);
    this._disposables.push(disposable);
  }
  registerTool(name, tool) {
    const disposable = this._platformService.registerTool(name, tool);
    this._disposables.push(disposable);
  }
  registerChatChainProvider(name, description, func) {
    const disposable = this._platformService.registerChatChain(
      name,
      description,
      func
    );
    this._disposables.push(disposable);
  }
  async fetch(info, init) {
    const proxyMode = this.config.proxyMode;
    switch (proxyMode) {
      case "system":
        return (0, import_request.chatLunaFetch)(info, init);
      case "off":
        return (0, import_request.chatLunaFetch)(info, init, "null");
      case "on":
        return (0, import_request.chatLunaFetch)(info, init, this.config.proxyAddress);
      default:
        return (0, import_request.chatLunaFetch)(info, init);
    }
  }
  ws(url, options) {
    const proxyMode = this.config.proxyMode;
    let webSocket;
    switch (proxyMode) {
      case "system":
        webSocket = (0, import_request.ws)(url, options);
        break;
      case "off":
        webSocket = (0, import_request.ws)(url, options, "null");
        break;
      case "on":
        webSocket = (0, import_request.ws)(url, options, this.config.proxyAddress);
        break;
      default:
        webSocket = (0, import_request.ws)(url, options);
        break;
    }
    this.ctx.effect(() => webSocket.close);
    webSocket.on("error", (err) => {
      this.ctx.logger.error(err);
    });
    return webSocket;
  }
};
var ChatInterfaceWrapper = class {
  constructor(_service) {
    this._service = _service;
    this._platformService = _service.platform;
  }
  static {
    __name(this, "ChatInterfaceWrapper");
  }
  _conversations = new import_lru_cache.LRUCache({
    max: 40
  });
  _modelQueue = new import_queue.RequestIdQueue();
  _conversationQueue = new import_queue.RequestIdQueue();
  _platformService;
  _requestIdMap = /* @__PURE__ */ new Map();
  _platformToConversations = /* @__PURE__ */ new Map();
  async chat(session, room, message, event, stream, requestId, variables = {}, postHandler) {
    const { conversationId, model: fullModelName } = room;
    const [platform] = (0, import_count_tokens.parseRawModelName)(fullModelName);
    const config = this._platformService.getConfigs(platform)[0];
    try {
      await Promise.all([
        this._conversationQueue.add(conversationId, requestId),
        this._modelQueue.add(platform, requestId)
      ]);
      const currentQueueLength = await this._conversationQueue.getQueueLength(conversationId);
      await event["llm-queue-waiting"](currentQueueLength);
      await Promise.all([
        this._conversationQueue.wait(conversationId, requestId, 0),
        this._modelQueue.wait(
          platform,
          requestId,
          config.value.concurrentMaxSize
        )
      ]);
      const conversationIds = this._platformToConversations.get(platform) ?? [];
      conversationIds.push(conversationId);
      this._platformToConversations.set(platform, conversationIds);
      const { chatInterface } = this._conversations.get(conversationId) ?? await this._createChatInterface(room);
      const abortController = new AbortController();
      this._requestIdMap.set(requestId, abortController);
      const humanMessage = new import_messages2.HumanMessage({
        content: message.content,
        name: message.name,
        id: session.userId,
        additional_kwargs: {
          ...message.additional_kwargs,
          preset: room.preset
        }
      });
      const chainValues = await chatInterface.chat({
        message: humanMessage,
        events: event,
        stream,
        conversationId,
        session,
        variables,
        signal: abortController.signal,
        postHandler
      });
      const aiMessage = chainValues.message;
      const reasoningContent = aiMessage.additional_kwargs?.reasoning_content;
      const reasoingTime = aiMessage.additional_kwargs?.reasoning_time;
      const additionalReplyMessages = [];
      if (reasoningContent != null && reasoningContent.length > 0 && this._service.config.showThoughtMessage) {
        additionalReplyMessages.push({
          content: `Thought for ${reasoingTime / 1e3} seconds: 

${reasoningContent}`
        });
      }
      return {
        content: aiMessage.content,
        additionalReplyMessages
      };
    } finally {
      await Promise.all([
        this._modelQueue.remove(platform, requestId),
        this._conversationQueue.remove(conversationId, requestId)
      ]);
      this._requestIdMap.delete(requestId);
    }
  }
  stopChat(requestId) {
    const abortController = this._requestIdMap.get(requestId);
    if (!abortController) {
      return false;
    }
    abortController.abort();
    return true;
  }
  async query(room, create = false) {
    const { conversationId } = room;
    const { chatInterface } = this._conversations.get(conversationId) ?? {};
    if (chatInterface == null && create) {
      return this._createChatInterface(room).then(
        (result) => result.chatInterface
      );
    }
    return chatInterface;
  }
  async clearChatHistory(room) {
    const { conversationId } = room;
    const requestId = (0, import_uuid.v4)();
    try {
      await this._conversationQueue.add(conversationId, requestId);
      await this._conversationQueue.wait(conversationId, requestId, 0);
      const chatInterface = await this.query(room, true);
      await chatInterface.clearChatHistory();
      this._conversations.delete(conversationId);
    } finally {
      await this._conversationQueue.remove(conversationId, requestId);
    }
  }
  async clearCache(room) {
    const { conversationId } = room;
    const requestId = (0, import_uuid.v4)();
    try {
      await this._conversationQueue.add(conversationId, requestId);
      await this._conversationQueue.wait(conversationId, requestId, 0);
      const chatInterface = await this.query(room);
      await this._service.ctx.root.parallel(
        "chatluna/clear-chat-history",
        conversationId,
        chatInterface
      );
      return this._conversations.delete(conversationId);
    } finally {
      await this._conversationQueue.remove(conversationId, requestId);
    }
  }
  getCachedConversations() {
    return Array.from(this._conversations.entries());
  }
  async delete(room) {
    const { conversationId } = room;
    const requestId = (0, import_uuid.v4)();
    try {
      await this._conversationQueue.add(conversationId, requestId);
      await this._conversationQueue.wait(conversationId, requestId, 1);
      const chatInterface = await this.query(room);
      if (!chatInterface) return;
      await chatInterface.delete(this._service.ctx, room);
      await this.clearCache(room);
    } finally {
      await this._conversationQueue.remove(conversationId, requestId);
    }
  }
  dispose(platform) {
    for (const controller of this._requestIdMap.values()) {
      controller.abort();
    }
    if (!platform) {
      this._conversations.clear();
      this._requestIdMap.clear();
      this._platformToConversations.clear();
      return;
    }
    const conversationIds = this._platformToConversations.get(platform);
    if (!conversationIds?.length) return;
    for (const conversationId of conversationIds) {
      this._conversations.delete(conversationId);
      const controller = this._requestIdMap.get(conversationId);
      if (controller) {
        controller.abort();
        this._requestIdMap.delete(conversationId);
      }
    }
    this._platformToConversations.delete(platform);
  }
  async _createChatInterface(room) {
    const config = this._service.config;
    const chatInterface = new import_app.ChatInterface(this._service.ctx.root, {
      chatMode: room.chatMode,
      botName: config.botNames[0],
      preset: /* @__PURE__ */ __name(async () => {
        return await this._service.preset.getPreset(room.preset);
      }, "preset"),
      model: room.model,
      conversationId: room.conversationId,
      embeddings: config.defaultEmbeddings && config.defaultEmbeddings.length > 0 ? config.defaultEmbeddings : void 0,
      vectorStoreName: config.defaultVectorStore && config.defaultVectorStore.length > 0 ? config.defaultVectorStore : void 0,
      maxMessagesCount: config.messageCount
    });
    const result = {
      chatInterface,
      room
    };
    this._conversations.set(room.conversationId, result);
    return result;
  }
};
((ChatLunaPlugin2) => {
  ChatLunaPlugin2.Config = import_koishi11.Schema.intersect([
    import_koishi11.Schema.object({
      chatConcurrentMaxSize: import_koishi11.Schema.number().min(1).max(8).default(3),
      chatTimeLimit: import_koishi11.Schema.number().min(1).max(2e3).computed().default(200),
      configMode: import_koishi11.Schema.union([
        import_koishi11.Schema.const("default"),
        import_koishi11.Schema.const("balance")
      ]).default("default"),
      maxRetries: import_koishi11.Schema.number().min(1).max(6).default(3),
      timeout: import_koishi11.Schema.number().default(300 * 1e3),
      proxyMode: import_koishi11.Schema.union([
        import_koishi11.Schema.const("system"),
        import_koishi11.Schema.const("off"),
        import_koishi11.Schema.const("on")
      ]).default("system")
    }),
    import_koishi11.Schema.union([
      import_koishi11.Schema.object({
        proxyMode: import_koishi11.Schema.const("on").required(),
        proxyAddress: import_koishi11.Schema.string().default("")
      }),
      import_koishi11.Schema.object({})
    ])
  ]).i18n({
    "zh-CN": require_zh_CN_schema_plugin(),
    "en-US": require_en_US_schema_plugin()
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  });
})(ChatLunaPlugin || (ChatLunaPlugin = {}));
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatLunaPlugin,
  ChatLunaService,
  MessageTransformer,
  PresetFormatService
});
