var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/locales/zh-CN.schema.yml
var require_zh_CN_schema = __commonJS({
  "src/locales/zh-CN.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "bot 配置", botNames: "设置 bot 的名称。(只有第一个名称是实际的 bot 名称，其他名称仅用于触发对话)", isNickname: "是否允许在开头匹配 bot 配置中的昵称来触发对话。", isNickNameWithContent: "是否允许在对话内容里任意匹配 bot 配置中的昵称来触发对话。" }, { $desc: "对话行为选项", allowPrivate: "是否允许在私聊中触发对话。", allowAtReply: "是否允许通过 @ bot 来触发对话。", allowQuoteReply: "是否允许通过引用 bot 的消息来触发对话。", isReplyWithAt: "当 bot 回复时，是否引用原消息。", isForwardMsg: "是否以转发消息的形式发送 bot 的回复。", privateChatWithoutCommand: "在私聊中是否允许无需命令直接与 bot 对话。", allowChatWithRoomName: "是否允许使用房间名前缀触发对话。注意：启用此选项可能会显著影响 ChatLuna 的性能，建议配合过滤器仅在特定群组中启用。", randomReplyFrequency: "设置随机回复的频率。", includeQuoteReply: "是否在回复内容中包含引用消息的内容。" }, { $desc: "对话响应选项", sendThinkingMessage: "是否在请求处理过程中发送等待消息。", sendThinkingMessageTimeout: "设置在模型开始响应前，等待多少毫秒后发送等待消息。", thinkingMessage: "自定义等待消息的内容。", msgCooldown: "设置全局消息冷却时间（单位：秒），用于防止适配器被过于频繁地调用。", messageDelay: "设置消息的延迟响应时间（单位：毫秒），在该时间内如果接收到了多条消息，则会累积起来一起发送。为 0 时，则不启用延迟响应。", showThoughtMessage: "在使用插件模式或思考模型时，是否显示思考过程。" }, { $desc: "消息渲染选项", outputMode: { $desc: "选择消息回复的渲染输出模式。" }, splitMessage: "是否启用消息分割发送。启用后，回复会被分割成多条消息发送，使其看起来更像普通用户的对话。注意：此选项不支持引用消息、原始模式和图片模式。在启用流式响应时，会进行更细化的消息分割。", censor: "是否启用文本审核服务（需要安装 censor 服务）。", rawOnCensor: "是否在 Post Handler 被触发时，将原始消息发送给模型。", streamResponse: "是否启用流式响应。启用后，bot 会在生成回复的过程中就开始发送消息，而不是等待完全生成后再发送。注意：启用此选项会导致渲染输出模式选项失效，且不支持插件模式。" }, { $desc: "黑名单选项", blackList: { $desc: "设置黑名单列表。请谨慎使用，只对需要拉黑的用户或群启用。错误配置可能导致所有聊天被拉黑而无法响应。" }, blockText: "设置对被拉黑用户的固定回复内容。" }, { $desc: "历史记录选项", messageCount: "设置最大消息数量，用于限制聊天历史中保存的消息数。超出此数量后，最早的消息将被自动删除。", autoDelete: "是否自动删除长期未使用的房间。", autoDeleteTimeout: "设置自动删除未使用房间的时间阈值（单位：秒）。" }, { $desc: "模型选项", defaultEmbeddings: "设置默认使用的嵌入模型。", defaultVectorStore: "设置默认使用的向量数据库。" }, { $desc: "模板房间选项", autoCreateRoomFromUser: "是否为每个用户自动创建专属房间。", defaultChatMode: "设置默认的聊天模式。", defaultModel: "设置默认使用的聊天模型。", defaultPreset: "设置默认使用的聊天预设。", autoUpdateRoomMode: { $desc: "自动更新房间配置模式。触发后，相关房间的配置将跟随模版房间的配置。", $inner: ["所有房间更新", "仅自动创建房间更新", "禁用更新"] } }, { $desc: "杂项", authSystem: { $desc: "是否启用配额组和用户权限系统（实验性功能）。启用后，各适配器设置的调用限额将失效。", $inner: [true] }, errorTemplate: "设置错误提示消息的模板（此设置在未来版本中可能会有变更）。", voiceSpeakId: "设置使用 vits 服务时的默认发音人 ID。", isLog: "是否启用调试模式。", isProxy: { $desc: "是否启用代理。启用后，ChatLuna 全家桶插件的网络请求将使用此代理。", $inner: [true] } }, [{ $desc: "代理选项", $inner: { proxyAddress: "网络请求的代理地址。填写后，ChatLuna 相关插件的网络服务将使用此代理地址。如不填写，将尝试使用 Koishi 全局配置中的代理设置。" } }], [{ $desc: "配额组选项", $inner: { authUserDefaultGroup: { $desc: "格式为 [权限等级, 初始余额, 授权组名称]。权限等级：0 为 guest，1 为 user，2 为 admin。如不了解，请勿配置。" } } }]] };
  }
});

// src/locales/en-US.schema.yml
var require_en_US_schema = __commonJS({
  "src/locales/en-US.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "Bot Configuration", botNames: "Set the bot's name. (Only the first name is the actual bot name; other names are only used to trigger conversations.)", isNickname: "Allow matching bot nickname at the beginning of a message to trigger a conversation.", isNickNameWithContent: "Allow matching bot nickname anywhere in the message content to trigger a conversation." }, { $desc: "Conversation Behavior", allowPrivate: "Enable private chat conversations.", allowAtReply: "Enable @mention triggering.", allowQuoteReply: "Enable quote triggering.", isReplyWithAt: "Quote original message in bot replies.", isForwardMsg: "Send bot replies as forwarded messages.", privateChatWithoutCommand: "Enable direct conversation in private chats without commands.", allowChatWithRoomName: "Enable room name prefix triggering. Note: May impact performance significantly. Recommended for use with filters in specific groups only.", randomReplyFrequency: "Set random reply frequency (0-100, where 0 means never and 100 means always).", includeQuoteReply: "Include quoted message content in replies." }, { $desc: "Response Options", sendThinkingMessage: "Send waiting message during processing.", sendThinkingMessageTimeout: "Set timeout (ms) for waiting message dispatch.", thinkingMessage: "Customize waiting message content.", msgCooldown: "Set global message cooldown (seconds) to limit adapter calls.", messageDelay: "Set message delay (ms) for message accumulation. 0 means no delay.", showThoughtMessage: "Display thinking message in plugin mode or reasoner model." }, { $desc: "Message Rendering", outputMode: { $desc: "Select message reply rendering mode." }, splitMessage: "Enable message splitting. Splits replies into multiple messages for natural conversation flow. Note: Incompatible with quoted messages, raw mode, or image mode. Stream response enables finer-grained splitting.", censor: "Enable text moderation (requires censor service).", rawOnCensor: "Whether to send the raw message to the model when the Post Handler is triggered.", streamResponse: "Enable stream response. Initiates message sending during reply generation. Note: Disables rendering output mode and incompatible with plugin mode." }, { $desc: "Blacklist Management", blackList: "Configure blacklist. Use cautiously to avoid unintended blocking.", blockText: "Set fixed reply for blacklisted users." }, { $desc: "History Management", messageCount: "Set maximum saved messages in chat history.", autoDelete: "Enable automatic deletion of inactive rooms.", autoDeleteTimeout: "Set inactivity threshold for room deletion (seconds)." }, { $desc: "Model Configuration", defaultEmbeddings: "Set default embedding model.", defaultVectorStore: "Set default vector database." }, { $desc: "Template Room Configuration", autoCreateRoomFromUser: "Enable automatic room creation per user.", defaultChatMode: "Set default chat mode.", defaultModel: "Set default chat model.", defaultPreset: "Set default chat preset.", autoUpdateRoomMode: { $desc: "Automatic room configuration update mode. When triggered, room settings will follow template room configuration.", $inner: ["Update all rooms", "Update auto-created rooms only", "Disable updates"] } }, { $desc: "Miscellaneous", authSystem: { $desc: "Enable quota group and user permission system (experimental). Overrides adapter call limits.", $inner: [true] }, errorTemplate: "Set error prompt message template (subject to change).", voiceSpeakId: "Set default speaker ID for vits service.", isLog: "Enable debug mode.", isProxy: { $desc: "Enable proxy for ChatLuna family plugin network requests.", $inner: [true] } }, [{ $desc: "Proxy Configuration", $inner: { proxyAddress: "Set proxy address for network requests. Falls back to Koishi global proxy settings if empty." } }], [{ $desc: "Quota Group Configuration", $inner: { authUserDefaultGroup: { $desc: "Format: [permission level, initial balance, authorization group name]. Levels: 0 (guest), 1 (user), 2 (admin). Leave unconfigured if uncertain." } } }]] };
  }
});

// src/locales/zh-CN.yml
var require_zh_CN = __commonJS({
  "src/locales/zh-CN.yml"(exports, module) {
    module.exports = { commands: { chatluna: { description: "ChatLuna 相关指令。", room: { description: "ChatLuna 房间管理。", create: { description: "创建一个新房间。", options: { name: "房间名字。", preset: "房间预设。", model: "房间模型。", chatMode: "房间聊天模式。", password: "房间密码。", visibility: "房间可见性。" }, messages: { confirm_create: "你目前已提供基础参数，是否直接创建房间？如需直接创建房间请回复 Y，如需进入交互式创建请回复 N，其他回复将视为取消。", timeout: "你超时未回复，已取消创建房间。", cancelled: "你已取消创建房间。", enter_name: "请输入你需要使用的房间名，如：我的房间，回复 Q 退出创建。", change_or_keep: "你已经{0}{1}：{2}，是否需要更换？如需更换请回复更换后的{1}，否则回复 N。回复 Q 退出创建。", enter_model: "请输入你需要使用的模型，如：openai/gpt-3.5-turbo，回复 Q 退出创建。", model_not_found: "无法找到模型：{0}，请重新输入。", enter_preset: "请输入你需要使用的预设，如：chatgpt。如果不输入预设请回复 N（则使用默认 chatgpt 预设）。否则回复你需要使用的预设。回复 Q 退出创建。", preset_not_found: "无法找到预设：{0}，请重新输入。", enter_visibility: "请输入你需要使用的可见性，如：private。如果不输入可见性请回复 N（则使用默认 private 可见性）。否则回复需要使用的可见性。(目支持 public, private)，回复 Q 退出创建。", visibility_not_recognized: "无法识别可见性：{0}，请重新输入。", enter_chat_mode: "请输入你需要使用的聊天模式，如：chat。如果不输入聊天模式请回复 N（则使用默认 chat 聊天模式）。否则回复你需要使用的聊天模式。回复 Q 退出创建。", enter_password: "请输入你需要使用的密码，如：123456。如果不输入密码请回复 N（则不设置密码）。否则回复你需要使用的密码。回复 Q 退出设置。", template_room_created: "模板房间创建成功。", room_created: "房间创建成功，房间号为：{0}，房间名为：{1}。", invalid_chat_mode: "无法识别聊天模式：{0}，目前可用的聊天模式有：{1}。请重新输入。回复 Q 退出创建。", action: { input: "输入", set: "设置", select: "选择" }, field: { name: "房间名", model: "模型", preset: "预设", visibility: "可见性", chat_mode: "聊天模式", password: "密码" } } }, delete: { description: "删除一个房间。", arguments: { room: "目标房间。" }, messages: { room_not_found: "未找到指定的房间。", not_room_master: "你不是房间的房主，无法删除房间。", confirm_delete: "你确定要删除房间 {0} 吗？这将会删除房间内的所有消息。并且成员也会被移除。如果你确定要删除，请输入 Y 来确认。", timeout: "操作超时未确认，已自动取消。", cancelled: "已为你取消操作。", success: "已删除房间 {0}。" } }, "auto-update": { description: "设置模版克隆房间的自动更新属性。", options: { room: "指定房间。" }, messages: { room_not_found: "未找到指定的房间。", not_template_clone: "该房间不是模板克隆房间，无法设置自动更新属性。", not_admin: "你不是房间的房主，无法设置自动更新房间。", success: "已设置房间 {0} 的自动更新属性为 {1}。", "invalid-status": "您输入的参数不合法，参数只能为 true 或者 false。" } }, kick: { description: "踢出某个人员在你当前的房间。", messages: { no_room_specified: "你没有在当前环境里指定房间。请使用 chatluna.room.switch 命令来切换房间", not_admin: "你不是房间 {0} 的管理员，无法踢出用户。", success: "已将以下用户踢出房间 {0}：{1}" } }, invite: { description: "邀请进入房间。", messages: { no_room_specified: "你没有在当前环境里指定房间。请使用 chatluna.room.switch 命令来切换房间", not_admin: "你不是房间 {0} 的管理员，无法邀请用户加入。", success: "已邀请用户 {0} 加入房间 {1}。" } }, join: { description: "加入某个房间。", arguments: { id: "房间 ID 或名称。" }, messages: { room_not_found: "未找到指定的房间。", not_in_group: "该房间不在当前群聊中。", private_no_password: "该房间为私密房间。房主未设置密码加入，只能由房主邀请进入，无法加入。", private_group_join: "该房间为私密房间。由于需要输入密码，你无法在群聊中加入。", enter_password: "请输入密码来加入房间 {0}。", timeout: "操作超时未确认，已自动取消。", wrong_password: "密码错误，已为你取消操作。", success: "已加入房间 {0}" } }, leave: { description: "离开当前房间。", arguments: { room: "目标房间。" }, messages: { room_not_found: "未找到指定的房间。", confirm_delete: "检测到你为房主，当你退出房间时，房间将会被删除。如果你确定要删除，请输入 Y 来确认。", timeout: "操作超时未确认，已自动取消。", cancelled: "已为你取消操作。", success: "已退出房间 {0}。您可能需要重新加入或者切换房间。" } }, clear: { description: "清除指定房间的聊天记录。", arguments: { room: "目标房间。" }, messages: { success: "已清除房间 {0} 的聊天记录。", "no-room": "未找到指定的房间。" } }, set: { description: "设置房间的属性。", options: { name: "房间名字。", preset: "房间预设。", model: "房间模型。", chatMode: "房间聊天模式。", password: "房间密码。", visibility: "房间可见性。" }, messages: { room_not_found: "未找到指定的房间。", not_room_master: "你不是房间的房主，无法设置房间的属性。", confirm_update: "你目前已设置参数，是否直接更新房间属性？如需直接更新请回复 Y，如需进入交互式创建请回复 N，其他回复将视为取消。", timeout: "你超时未回复，已取消设置房间属性。", cancelled: "你已取消设置房间属性。", no_password_in_public: "你无法在非私有房间或群聊中设置密码。", change_or_keep: "你已经选择了{0}：{1}，是否需要更换？如无须更改请回复 N，否则回复更换后的{0}。回复 Q 退出设置。", model_not_found: "无法找到模型：{0}，请重新输入。回复 Q 退出设置。", preset_not_found: "无法找到预设：{0}，请重新输入。回复 Q 退出设置。", invalid_visibility: "无法识别可见性：{0}，请重新输入。回复 Q 退出设置。", enter_password: "请输入你需要使用的密码，如：123456。如果不输入密码请回复 N（则不设置密码）。否则回复你需要使用的密码。回复 Q 退出设置。", success_with_clear: "房间 {0} 已更新，聊天记录已被清空。", invalid_chat_mode: "无法识别聊天模式：{0}，目前可用的聊天模式有：{1}。请重新输入。", failed: "房间 {0} 更新失败。请检查你的设置并重新尝试。", success: "房间 {0} 已更新。", field: { name: "房间名", model: "模型", preset: "预设", visibility: "可见性", chat_mode: "聊天模式", password: "密码" } } }, list: { description: "列出所有你加入的房间。", options: { page: "页码。", limit: "每页数量。" }, messages: { header: "以下是查询到你加入的房间列表：", footer: "你可以使用 chatluna.room.switch [name/id] 来切换当前环境里你的默认房间。", pages: "当前为第 [page] / [total] 页", room_name: "房间名: {0}", room_id: "房间ID: {0}", room_preset: "房间预设: {0}", room_model: "房间模型: {0}", room_visibility: "房间可见性: {0}", room_chat_mode: "房间聊天模式: {0}", room_master_id: "房间创建者ID: {0}", room_availability: "房间可用性：{0}" } }, transfer: { description: "转移房间的房主。", messages: { room_not_found: "未找到指定的房间。", not_room_master: "你不是房间的房主，无法转移房间给他人。", confirm_transfer: "你确定要把房间 {0} 转移给用户 {1} 吗？转移后ta将成为房间的房主，你将失去房主权限。如果你确定要转移，请输入 Y 来确认。", timeout: "操作超时未确认，已自动取消。", cancelled: "已为你取消操作。", success: "已将房间 {0} 转移给用户 {1}。" } }, info: { description: "查看当前房间的信息。", arguments: { room: "目标房间。" }, messages: { room_not_found: "未找到指定的房间。", header: "以下是你目前所在的房间信息", room_name: "房间名: {0}", room_id: "房间ID: {0}", room_preset: "房间预设: {0}", room_model: "房间模型: {0}", room_visibility: "房间可见性: {0}", room_chat_mode: "房间聊天模式: {0}", room_master_id: "房间创建者ID: {0}" } }, switch: { description: "切换到你已经加入了的房间。", arguments: { name: "房间名称或 ID。" }, messages: { success: "已切换到房间 {0}。", room_not_found: "未找到指定的房间。" } }, permission: { description: "修改房间里某人的权限。", options: { room: "指定房间。", user: "目标用户。" }, messages: { room_not_found: "未找到指定的房间。", not_admin: "你不是房间的房主，无法为用户设置权限。", confirm_set: "你确定要为用户 {0} 设置房间 {1} 的权限吗？目前可以设置的权限为 member 和 admin。如果你确定要设置，请输入设置权限的值或首字母大写，其他输入均视为取消。", timeout: "操作超时未确认，已自动取消。", invalid_permission: "你输入的权限值不正确，已自动取消。", success: "已为用户 {0} 设置房间 {1} 的权限为 {2}" } }, mute: { description: "禁言某个用户，不让其发言。", options: { room: "指定房间。" }, messages: { room_not_found: "未找到指定的房间。", not_admin: "你不是房间 {0} 的管理员，无法禁言用户。", success: "已将用户 {0} 在房间 {1} 禁言或解除禁言。" } } }, chat: { description: "ChatLuna 对话相关指令。", text: { description: "与大语言模型进行文本对话。", options: { room: "指定对话的目标房间。", type: "设置消息的渲染类型。" }, examples: ["chatluna chat text -t text 你好，世界！", "chatluna chat text -t voice 你好，世界！", "chatluna chat text -r 原神 -t text 你好，世界！"], arguments: { message: "要发送的消息内容。" }, messages: { "invalid-render-type": "渲染类型无效。请使用有效的渲染类型，目前支持的类有 `text` 和 `voice`。" } }, rollback: { description: "重新生成上一次的对话内容。", options: { room: "指定要操作的房间。" }, arguments: { message: "新的消息内容。" }, messages: { room_not_found: "未找到指定的房间。", conversation_not_exist: "房间不存在。", no_chat_history: "找不到对话记录。", invalid_chat_history: "错误的聊天记录，请尝试清空聊天记录后重试。", rollback_success: "已成功回滚到 {0} 轮前的对话，请等待模型回复。" } }, stop: { description: "立即停止当前正在进行的对话。", options: { room: "指定要停止对话的房间。" }, messages: { room_not_found: "未找到指定的房间。", no_active_chat: "当前未在房间中对话。", stop_failed: "停止对话失败。", success: "已成功停止当前对话。" } }, voice: { description: "与模型进行对话并将回复转换为语音输出。", options: { room: "指定对话的目标房间。", speaker: "设置语音服务使用目标角色 ID。" }, arguments: { message: "要发送的消息内容。" } } }, wipe: { description: "清空 ChatLuna 的所有使用数据（请谨慎使用）。", messages: { confirm_wipe: "您接下来将要操作的是清除 ChatLuna 的全部相关数据！这些数据包括：\n1. 所有会话数据\n2. 其他缓存在数据库的数据\n3. 本地向量数据库的相关数据\n\n请输入下列算式的结果以确认删除：{0}。\n", timeout: "删除超时，已取消删除", incorrect_input: "你的输入不正确，已取消删除。", success: "已删除相关数据，即将重启完成更改。" } }, restart: { description: "重启 ChatLuna 服务。", messages: { success: "已成功重启 ChatLuna。" } }, auth: { description: "ChatLuna 鉴权相关指令。", list: { description: "列出授权组。", options: { page: "页码。", limit: "每页显示的数量。", platform: "指定平台。" }, messages: { header: "以下是查询到目前可用的配额组列表：", footer: "你可以使用 chatluna.auth.add [name/id] 来加入某个配额组。", pages: "当前为第 [page] / [total] 页", name: "名称：{0}", platform: "适用模型平台：{0}", cost: "计费：{0} / 1000 token", priority: "优先级: {0}", support_models: "限制模型：{0}", limit_per_min: "并发限制每 {0} 条消息/分", limit_per_day: "并发限制每 {0} 条消息/天", general: "通用" } }, add: { description: "将用户加入到指定配额组。", usage: "使用方法：chatluna auth add [组名] -u @用户", options: { user: "目标用户。" }, messages: { permission_denied: "你的权限不足以执行此操作。", success: "已将用户 {0} 添加到配额组 {1}。" } }, kick: { description: "将用户从指定配额组中移除。", usage: "使用方法：chatluna auth kick [组名] -u @用户", options: { user: "目标用户。" }, messages: { permission_denied: "你的权限不足以执行此操作。", success: "已将用户 {0} 踢出配额组 {1}" } }, create: { description: "创建一个新的授权组。", options: { name: "授权组名称。", preMin: "每分钟请求限额。", preDay: "每日请求限额。", platform: "指定平台。", supportModels: "支持的模型列表。", priority: "优先级。", cost: "token 费用。" }, messages: { enter_name: "请输入你需要使用的配额组名，如：OpenAI配额组", name_exists: "你输入的配额组名已存在，请重新输入。", enter_limit_per_min: "请输入配额组每分钟的限额条数，要求为数字并且大于 0。", enter_limit_per_day: "请输入配额组每天的限额条数，要求为数字并且大于每分钟的限额次数。", enter_platform: "请输入对该配额组的模型平台标识符，如： openai。表示优先在使用该平台模型时使用该配额组，如不输入回复 N", enter_priority: "请输入配额组的优先级（数字，越大越优先）（这很重要，会决定配额组的使用顺序）。", enter_cost: "请输入配额组的 token 费用（数字，按一千 token 计费，实际扣除用户余额）。", enter_models: "请输入该配额组可使用的模型列表（白名单机制），用英文逗号分割，如（openai/gpt-3.5-turbo, openai/gpt-4）。如果不输入回复 N（则不设置型列表）。", invalid_input: "你输入的{0}有误，请重新输入。", confirm_create: "你目前已提供基础参数，是否直接创建配额组？如需直接创建配额组请回复 Y，如需进入交互式创建请回复 N，其他回复将视为取消。", timeout: "你超时未回复，已取消创建配额组。", cancelled: "你已取消创建配额组。", success: "配额组创建成功，配额组名为：{0}。", change_or_keep: "你已经{0}{1}：{2}，是否需要更换？如需更换请回复更换后的{1}，否则回复 N。", invalid_models: "模型组里有不支持的模型，请重新输入。", action: { input: "输入", set: "设置", select: "选择" }, field: { name: "配额组名", limit_per_min: "每分钟限额条数", limit_per_day: "每天限额条数", platform: "平台标识符", priority: "优先级", cost: "费用", models: "模型列表" } } }, set: { description: "修改现有授权组的参数。", options: { name: "授权组名称。", preMin: "每分钟请求限额。", preDay: "每日请求限额。", platform: "指定平台。", supportModels: "支持的模型列表。", priority: "优先级。", cost: "token 费用。" }, messages: { confirm_set: "你目前已提供基础参数，是否直接修改配额组？如需直接修改配额组请回复 Y，如需进入交互式创建请回复 N，其他回复将视为取消。", timeout: "你超时未回复，已取消修改配额组。", cancelled: "你已取消修改配额组。", enter_name: "请输入你需要使用的配额组名，如：OpenAI配额组。回复 Q 退出修改。", name_exists: "你输入的配额组名已存在，请重新输入。", enter_limit_per_min: "请输入配额组每分钟的限额条数，要求为数字并且大于 0。回复 Q 退出修改。", enter_limit_per_day: "请输入配额组每天的限额条数，要求为数字并且大于每分钟的限额次数。回复 Q 退出修改。", enter_platform: "请输入对该配额组的模型平台标识符，如： openai。表示会优先在使用该平台模型时使用该配额组，如不输入回复 N。回复 Q 退出修改。", enter_priority: "请输入配额组的优先级（数字，越大越优先）（这很重要，会决定配额组的使用顺序）。回复 Q 退出修改。", enter_cost: "请输入配额组的 token 费用（数字，按一千 token 计费，实际扣除用户余额）。回复 Q 退出修改。", enter_models: "请输入该配额组可使用的模型列表（白名单机制），用英文逗号分割，如（openai/gpt-3.5-turbo, openai/gpt-4）。如果不输入回复 N（则不设置模型列表）。回复 Q 退出修改。", invalid_input: "你输入的{0}有误，请重新输入。", change_or_keep: "你已经{0}{1}：{2}，是否需要更换？如需更换请回复更换后的{1}，否则回复 N。回复 Q 退出修改。", invalid_models: "模型组里有不支持的模型，请重新输入。", success: "配额组修改成功，新配额组名为：{0}。", action: { input: "输入", set: "设置", select: "选择" }, field: { name: "配额组名", limit_per_min: "每分钟限额条数", limit_per_day: "每天限额条数", platform: "平台标识符", priority: "优先级", cost: "费用", models: "模型列表" } } } }, balance: { description: "ChatLuna 余额相关指令。", clear: { description: "清除指定用户的余额。将用户的余额重置为0。", arguments: { user: "目标用户。" }, examples: ["chatluna balance clear --user @用户名"], messages: { success: "已将用户 {0} 账户余额修改为 {1}" } }, set: { description: "设置指定用户的余额。可以增加或减少用户的余额。", arguments: { user: "目标用户。", amount: "要设置的余额数量。" }, examples: ["chatluna balance set --user @用户名 --amount 1000"], messages: { success: "已将用户 {0} 账户余额修改为 {1}" } }, query: { description: "查询用户的当前余额。如果不指定用户，则查询自己的余额。", arguments: { user: "目标用户。如果不指定，则查询当前用户。" }, examples: ["chatluna balance query", "chatluna balance query --user @用户名"], messages: { success: "用户 {0} 当前的账户余额为 {1}" } } }, model: { description: "ChatLuna 模型相关指令。", list: { description: "列出所有可用的模型。", usage: "chatluna model list --page 1 --limit 10", options: { page: "页码。", limit: "每页显示的数量。" }, messages: { header: "以下是目前可用的模型列表：", footer: "你可以使用 chatluna.room.set -m [model] 来设置默认使用的模型", pages: "当前为第 [page] / [total] 页" } }, search: { description: "搜索可用的模型。", arguments: { query: "搜索关键词。" }, usage: "chatluna model search openai --page 1 --limit 10", options: { page: "页码。", limit: "每页显示的数量。" }, messages: { header: "以下是目前搜索到的模型列表：", footer: "你可以使用 chatluna.room.set -m [model] 来设置默认使用的模型", pages: "当前为第 [page] / [total] 页" } } }, memory: { description: "ChatLuna 记忆相关指令。", search: { description: "搜索记忆。", arguments: { query: "搜索关键词。" }, usage: 'chatluna memory search --query "你好" --page 1 --limit 10', options: { page: "页码。", limit: "每页显示的数量。", type: "记忆所属的预设。", view: "记忆所属的层级。" }, messages: { header: "以下是使用 {0} 关键词在 {1} 预设下搜索出的记忆列表：", footer: "", document_content: "记忆内容： {0}", document_id: "记忆 ID： {0}", document_type: "记忆所属的类型： {0}", document_expire: "记忆过期时间： {0}", document_level: "记忆的重要性： {0}", pages: "当前为第 [page] / [total] 页", search_failed: "搜索记忆失败。", invalid_view: "无效的记忆层级。目前可用：{0}" } }, delete: { description: "删除记忆。", arguments: { ids: "记忆 ID 列表。" }, options: { type: "记忆所属的预设。", view: "记忆所属的层级。" }, messages: { delete_success: "已删除记忆。", delete_failed: "删除记忆失败。", invalid_view: "无效的记忆层级。目前可用：{0}" } }, clear: { description: "清空记忆。", options: { type: "记忆所属的预设。", view: "记忆所属的层级。" }, messages: { clear_success: "已清空记忆。", clear_failed: "清空记忆失败。", invalid_view: "无效的记忆层级。目前可用：{0}" } }, add: { description: "添加记忆。", arguments: { content: "记忆内容。" }, options: { type: "记忆所属的预设。", view: "记忆所属的层级。" }, messages: { add_success: "已添加记忆。", add_failed: "添加记忆失败。", invalid_view: "无效的记忆层级。目前可用：{0}" } }, edit: { description: "编辑记忆。", arguments: { id: "记忆 ID。" }, options: { type: "记忆所属的预设。", view: "记忆所属的层级。" }, messages: { edit_success: "已编辑记忆。", edit_failed: "编辑记忆失败。", edit_memory_start: "请发送你的新记忆内容。", invalid_view: "无效的记忆层级。目前可用：{0}" } } }, preset: { description: "ChatLuna 预设相关指令。", list: { description: "列出当前支持的所有预设。", options: { page: "指定页码", limit: "设置每页显示数量" }, messages: { header: "以下是目前可用的预设列表：", footer: "你可以使用 chatluna.room.set -p [preset] 来设置默认使用的预设", pages: "当前为第 [page] / [total] 页", preset_keyword: "预设关键词： {0}", preset_content: "预设内容： {0}" } }, add: { description: "添加新预设。", arguments: { preset: "预设名称" }, messages: { conflict: "该预设关键词已经和其他预设关键词冲突，请更换其他关键词重试哦", prompt: "请发送你的预设内容。", timeout: "添加预设超时，已取消添加预设: {0}", success: "预设添加成功，预设名称为: {0}。 请调用预设列表命令查看。" } }, clone: { description: "复制现有预设。", arguments: { originPreset: "源预设名称", newPresetName: "新预设名称" }, messages: { conflict: "该预设关键词已经和其他预设关键词冲突，请更换其他关键词重试哦。", confirm: "你确定要克隆预设 {0} 吗？如果你确定要克隆，请输入 Y 来确认。", timeout: "操作超时未确认，已自动取消。", cancelled: "已为你取消操作。", success: "预设克隆成功，预设名称为: {0}。 请调用预设列表命令查看。" } }, set: { description: "修改现有预设。", arguments: { preset: "预设名称" }, messages: { not_found: "找不到指定的预设。", not_support: "不支持修改 {0} 预设！该预设自定义了多条消息，属于复杂预设，无法使用此命令修改，请自行前往控制面板里的资源管理器编辑此预设。`", timeout: "操作超时未确认，已自动取消。", cancelled: "已为你取消操作。", enter_content: "请发送你的新预设内容。", success: "预设修改成功，预设名称为: {0}。 请调用预设列表命令查看。" } }, delete: { description: "删除指定预设。", arguments: { preset: "预设名称" }, messages: { only_one_preset: "现在只有一个预设了，删除后将无法使用预设功能，所以不允许删除。", not_found: "找不到该预设！请检查你是否输入了正确的预设？", confirm_delete: "是否要删除 {0} 预设？输入大写 Y 来确认删除，输入其他字符来取消删除。提示：删除后使用了该预设的会话将会自动删除无法使用。", timeout: "删除预设超时，已取消删除预设: {0}。", cancelled: "已取消删除预设: {0}", success: "已删除预设: {0}，即将自动重启完成更改。" } } }, embeddings: { description: "ChatLuna 嵌入模型管理。", list: { description: "查看支持的嵌入模型列表。", options: { page: "指定页码。", limit: "设置每页显示数量。" }, messages: { header: "以下是目前可用的嵌入模型列表：", footer: "你可以使用 chatluna.embeddings.set [model] 来设置默认使用的嵌入模型", pages: "当前为第 [page] / [total] 页" } }, set: { description: "设置默认嵌入模型。", arguments: { embeddings: "嵌入模型名称。" }, messages: { usage_hint: "你可以使用 chatluna.embeddings.set [model] 来设置默认使用的嵌入模型", multiple_models_found: { header: "基于你的输入，找到了以下嵌入模型：", footer: "请输入更精确的嵌入模型名称以避免歧义", example: "例如：chatluna.embeddings.set {0}" }, model_not_found: "找不到对应的嵌入模型，请检查输入是否正确", success: "已将默认嵌入模型设置为 {0} (将自动重启插件应用更改)" } } }, vectorstore: { description: "ChatLuna 向量数据库管理。", list: { description: "查看支持的向量数据库列表。", options: { page: "指定页码。", limit: "设置每页显示数量。" }, messages: { header: "以下是目前可用的向量数据库列表：", footer: "你可以使用 chatluna.vectorstore.set [model] 来设置默认使用的向量数据库（如果没有任何向量数据库，会使用存储在内存里的向量数据库（临时的））", pages: "当前为第 [page] / [total] 页" } }, set: { description: "设置默认向量数据库。", arguments: { vectorStore: "向量数据库名称。" }, messages: { usage_hint: "你可以使用 chatluna.vectorstore.set [model] 来设置默认使用的向量数据库", multiple_stores_found: { header: "基于你的输入，找到了以下向量数据库：", footer: "请输入更精确的向量数据库名称以避免歧义", example: "例如：chatluna.vectorstore.set {0}" }, store_not_found: "找不到对应的向量数据库，请检查名称是否正确", success: "已将默认向量数据库设置为 {0}，(将自动重启插件应用更改)" } } } } }, chatluna: { aborted: "已成功停止当前对话的生成。", thinking_message: "我还在思考中，前面还有 {0} 条消息等着我回复呢，稍等一下~", block_message: "哎呀(ｷ｀ﾟДﾟ´)!!，你怎么被拉入黑名单了呢？要不你去问问我的主人吧。", error_message: "使用 ChatLuna 时出现错误，错误码为 %s。请联系开发者以解决此问题。", middleware_error: "执行 {0} 时出现错误: {1}", chat_limit_exceeded: "你的聊天次数已经用完了喵，还需要等待 {0} 分钟才能继续聊天喵 >_<", room: { random_switch: "检测到你没有指定房间，已为你随机切换到房间 {0}。", not_joined: "你还没有加入任何房间，请先加入房间。", not_in_room: "你没有加入此房间，请先加入房间 {0}。", muted: "你已被禁言，无法在房间 {0} 发言。", unavailable: "检测到当前房间不可用，正在为您自动修复。", auto_switch: "已为用户 {0} 自动切换到房间 {1}。", auto_create: "已为用户 {0} 自动创建房间 {1}。", auto_create_template: "已为用户 {0} 自动创建模版克隆房间 {1}。", room_name: "{0} 的房间", template_clone_room_name: "{0} 的模版克隆房间", config_changed: "检测到模版房间 {0} 的配置变更，已更新到数据库。" }, cooldown_wait_message: "不要发这么快喵，等 {0}s 后我们再聊天喵。" } };
  }
});

// src/locales/en-US.yml
var require_en_US = __commonJS({
  "src/locales/en-US.yml"(exports, module) {
    module.exports = { commands: { chatluna: { description: "ChatLuna related commands.", room: { description: "ChatLuna room management.", create: { description: "Create a new room.", options: { name: "Room name", preset: "Room preset", model: "Room model", chatMode: "Chat mode", password: "Room password", visibility: "Room visibility" }, messages: { confirm_create: "Basic parameters provided. Create room directly? Y: Create, N: Interactive creation, Any other: Cancel.", timeout: "Response timeout. Room creation cancelled.", cancelled: "Room creation cancelled.", enter_name: "Enter room name (e.g., My Room). Q to exit.", change_or_keep: "{0} {1}: {2}. Change? New {1} to change, N to keep. Q to exit.", enter_model: "Enter model (e.g., openai/gpt-3.5-turbo). Q to exit.", model_not_found: "Model not found: {0}. Please retry.", enter_preset: "Enter preset (e.g., chatgpt). N for default. Q to exit.", preset_not_found: "Preset not found: {0}. Please retry.", enter_visibility: "Enter visibility (public/private). N for default. Q to exit.", visibility_not_recognized: "Unrecognized visibility: {0}. Please retry.", enter_chat_mode: "Enter chat mode. N for default. Q to exit.", enter_password: "Enter password. N for no password. Q to exit.", invalid_chat_mode: "Unable to recognize chat mode: {0}. Available chat modes are: {1}. Please try again. Q to exit.", template_room_created: "Template room created successfully.", room_created: "Room created. ID: {0}, Name: {1}.", action: { input: "Input", set: "Set", select: "Select" }, field: { name: "Room name", model: "Model", preset: "Preset", visibility: "Visibility", chat_mode: "Chat mode", password: "Password" } } }, delete: { description: "Delete a room.", arguments: { room: "Target room" }, messages: { room_not_found: "Room not found.", not_room_master: "Insufficient permissions: Not room owner.", confirm_delete: "Confirm deletion of room {0}? All messages and members will be removed. Y to confirm.", timeout: "Operation timed out. Automatically cancelled.", cancelled: "Operation cancelled.", success: "Room {0} deleted." } }, "auto-update": { description: "Set auto-update for template clone rooms.", options: { room: "Specify room" }, messages: { room_not_found: "Room not found.", not_template_clone: "Not a template clone room. Cannot set auto-update.", not_admin: "Insufficient permissions: Not room owner.", success: "Auto-update for room {0} set to {1}.", "invalid-status": "Invalid parameter. Use true or false." } }, kick: { description: "Kick user from current room.", messages: { no_room_specified: "No room specified. Use chatluna.room.switch to select a room.", not_admin: "Insufficient permissions: Not room admin.", success: "Users kicked from room {0}: {1}" } }, invite: { description: "Invite user to room.", messages: { no_room_specified: "No room specified. Use chatluna.room.switch to select a room.", not_admin: "Insufficient permissions: Not room admin.", success: "User {0} invited to room {1}." } }, join: { description: "Join a room.", arguments: { id: "Room ID or name" }, messages: { room_not_found: "Room not found.", not_in_group: "Room not in current group chat.", private_no_password: "Private room. Owner invitation required.", private_group_join: "Private room. Cannot join in group chat.", enter_password: "Enter password for room {0}.", timeout: "Operation timed out. Automatically cancelled.", wrong_password: "Incorrect password. Operation cancelled.", success: "Joined room {0}" } }, leave: { description: "Leave current room.", arguments: { room: "Target room" }, messages: { room_not_found: "Room not found.", confirm_delete: "Room owner detected. Leaving will delete the room. Y to confirm.", timeout: "Operation timed out. Automatically cancelled.", cancelled: "Operation cancelled.", success: "Left room {0}. Rejoin or switch rooms if needed." } }, clear: { description: "Clear room chat history.", arguments: { room: "Target room" }, messages: { success: "Chat history cleared for room {0}.", "no-room": "Room not found." } }, set: { description: "Set room properties.", options: { name: "Room name", preset: "Room preset", model: "Room model", chatMode: "Chat mode", password: "Room password", visibility: "Room visibility" }, messages: { room_not_found: "Room not found.", not_room_master: "Insufficient permissions: Not room owner.", confirm_update: "Update room properties? Y: Update, N: Interactive update, Any other: Cancel.", timeout: "Response timeout. Update cancelled.", cancelled: "Update cancelled.", no_password_in_public: "Cannot set password for non-private room or group chat.", change_or_keep: "{0}: {1}. Change? New value to change, N to keep. Q to exit.", model_not_found: "Model not found: {0}. Please retry.", preset_not_found: "Preset not found: {0}. Please retry.", invalid_visibility: "Invalid visibility: {0}. Please retry.", enter_password: "Enter password. N for no password. Q to exit.", success_with_clear: "Room {0} updated. Chat history cleared.", invalid_chat_mode: "Unable to recognize chat mode: {0}. Available chat modes are: {1}. Please try again.", failed: "Room {0} update failed. Please check your settings and try again.", success: "Room {0} updated.", field: { name: "Room name", model: "Model", preset: "Preset", visibility: "Visibility", chat_mode: "Chat mode", password: "Password" } } }, list: { description: "List joined rooms.", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Joined rooms:", footer: "Use chatluna.room.switch [name/id] to change default room.", pages: "Page: [page] / [total]", room_name: "Name: {0}", room_id: "ID: {0}", room_preset: "Preset: {0}", room_model: "Model: {0}", room_visibility: "Visibility: {0}", room_chat_mode: "Chat mode: {0}", room_master_id: "Creator ID: {0}", room_availability: "Availability: {0}" } }, transfer: { description: "Transfer room ownership.", messages: { room_not_found: "Room not found.", not_room_master: "Insufficient permissions: Not room owner.", confirm_transfer: "Transfer room {0} to user {1}? You will lose owner privileges. Y to confirm.", timeout: "Operation timed out. Automatically cancelled.", cancelled: "Operation cancelled.", success: "Room {0} transferred to user {1}." } }, info: { description: "View current room information.", arguments: { room: "Target room" }, messages: { room_not_found: "Room not found.", header: "Current room information:", room_name: "Name: {0}", room_id: "ID: {0}", room_preset: "Preset: {0}", room_model: "Model: {0}", room_visibility: "Visibility: {0}", room_chat_mode: "Chat mode: {0}", room_master_id: "Creator ID: {0}" } }, switch: { description: "Switch to a joined room.", arguments: { name: "Room name or ID" }, messages: { success: "Switched to room {0}.", room_not_found: "Room not found." } }, permission: { description: "Modify user permissions in room.", options: { room: "Specify room", user: "Target user" }, messages: { room_not_found: "Room not found.", not_admin: "Insufficient permissions: Not room owner.", confirm_set: "Set permissions for user {0} in room {1}? Available: member, admin. Enter permission or first letter. Any other: Cancel.", timeout: "Operation timed out. Automatically cancelled.", invalid_permission: "Invalid permission. Operation cancelled.", success: "Permission for user {0} in room {1} set to {2}" } }, mute: { description: "Mute a user in the room.", options: { room: "Specify room" }, messages: { room_not_found: "Room not found.", not_admin: "Insufficient permissions: Not room admin.", success: "User {0} muted/unmuted in room {1}." } } }, chat: { description: "ChatLuna conversation commands.", text: { description: "Initiate a text conversation with the AI model.", options: { room: "Target conversation room.", type: "Message rendering type." }, examples: ["chatluna chat text -t text Hello, world!", "chatluna chat text -t voice Hello, world!", "chatluna chat text -r Genshin -t text Hello, world!"], arguments: { message: "Message content to send." }, messages: { "invalid-render-type": "Invalid rendering type. Supported types: `text` and `voice`." } }, rollback: { description: "Regenerate last conversation content.", options: { room: "Target room for operation." }, arguments: { message: "New message content." }, messages: { room_not_found: "Room not found.", conversation_not_exist: "Room does not exist.", no_chat_history: "Chat history not found.", invalid_chat_history: "Invalid chat history. Clear history and retry.", rollback_success_1: "Successfully rolled back to {0} rounds ago." } }, stop: { description: "Immediately terminate ongoing conversation.", options: { room: "Target room to stop conversation." }, messages: { room_not_found: "Room not found.", no_active_chat: "No active conversation in current room.", stop_failed: "Failed to stop conversation.", success: "Conversation stopped successfully." } }, voice: { description: "Converse with AI model and receive voice output.", options: { room: "Target conversation room.", speaker: "Character ID for voice service." }, arguments: { message: "Message content to send." } } }, wipe: { description: "Clear all ChatLuna usage data (use with caution).", messages: { confirm_wipe: "Warning: You are about to clear all ChatLuna data, including:\n1. All session data\n2. Cached database data\n3. Local vector database data\n\nTo confirm deletion, enter the result of: {0}.\n", timeout: "Deletion timed out. Operation cancelled.", incorrect_input: "Incorrect input. Deletion cancelled.", success: "Data deleted. Restarting to apply changes." } }, restart: { description: "Restart the ChatLuna.", messages: { success: "Successfully restarted ChatLuna." } }, auth: { description: "ChatLuna authentication commands.", list: { description: "Display authorization groups.", options: { page: "Page number", limit: "Items per page", platform: "Specify platform" }, messages: { header: "Available quota groups:", footer: "Use chatluna.auth.add [name/id] to join a quota group.", pages: "Page: [page] / [total]", name: "Name: {0}", platform: "Model platform: {0}", cost: "Cost: {0} / 1000 tokens", priority: "Priority: {0}", support_models: "Allowed models: {0}", limit_per_min: "Limit: {0} messages/minute", limit_per_day: "Limit: {0} messages/day", general: "General" } }, add: { description: "Add user to quota group.", usage: "Usage: chatluna auth add [group] name -u @user", options: { user: "Target user" }, messages: { permission_denied: "Insufficient permissions for this operation.", success: "User {0} added to quota group {1}." } }, kick: { description: "Remove user from quota group.", usage: "Usage: chatluna auth kick [group name] -u @user", options: { user: "Target user" }, messages: { permission_denied: "Insufficient permissions for this operation.", success: "User {0} removed from quota group {1}." } }, create: { description: "Create new authorization group.", options: { name: "Group name", preMin: "Per-minute limit", preDay: "Daily limit", platform: "Platform", supportModels: "Supported models", priority: "Priority", cost: "Token cost" }, messages: { enter_name: "Enter quota group name (e.g., OpenAI Quota Group):", name_exists: "Group name already exists. Please try again.", enter_limit_per_min: "Enter per-minute limit (>0):", enter_limit_per_day: "Enter daily limit (>per-minute limit):", enter_platform: "Enter model platform ID (e.g., openai) or N to skip:", enter_priority: "Enter priority (higher number = higher priority):", enter_cost: "Enter token cost (per 1000 tokens):", enter_models: "Enter allowed models (comma-separated) or N to skip:", invalid_input: "Invalid input for {0}. Please try again.", confirm_create: "Create quota group? Y: Create, N: Interactive mode, Any other: Cancel.", timeout: "Response timeout. Creation cancelled.", cancelled: "Quota group creation cancelled.", success: 'Quota group "{0}" created successfully.', change_or_keep: "{0} {1}: {2}. Change? New value or N to keep.", invalid_models: "Invalid models detected. Please try again.", action: { input: "Input", set: "Set", select: "Select" }, field: { name: "Group name", limit_per_min: "Per-minute limit", limit_per_day: "Daily limit", platform: "Platform ID", priority: "Priority", cost: "Cost", models: "Allowed models" } } }, set: { description: "Modify existing authorization group.", options: { name: "Group name", preMin: "Per-minute limit", preDay: "Daily limit", platform: "Platform", supportModels: "Supported models", priority: "Priority", cost: "Token cost" }, messages: { confirm_set: "Modify quota group? Y: Direct modify, N: Interactive mode, Any other: Cancel.", timeout: "Response timeout. Modification cancelled.", cancelled: "Quota group modification cancelled.", enter_name: "Enter new group name (e.g., OpenAI Quota Group) or Q to exit:", name_exists: "Group name already exists. Please try again.", enter_limit_per_min: "Enter new per-minute limit (>0) or Q to exit:", enter_limit_per_day: "Enter new daily limit (>per-minute limit) or Q to exit:", enter_platform: "Enter new platform ID (e.g., openai), N to skip, or Q to exit:", enter_priority: "Enter new priority (higher = more priority) or Q to exit:", enter_cost: "Enter new token cost (per 1000 tokens) or Q to exit:", enter_models: "Enter new allowed models (comma-separated), N to skip, or Q to exit:", invalid_input: "Invalid input for {0}. Please try again.", change_or_keep: "{0} {1}: {2}. Change? New value, N to keep, or Q to exit.", invalid_models: "Invalid models detected. Please try again.", success: 'Quota group "{0}" modified successfully.', action: { input: "Input", set: "Set", select: "Select" }, field: { name: "Group name", limit_per_min: "Per-minute limit", limit_per_day: "Daily limit", platform: "Platform ID", priority: "Priority", cost: "Cost", models: "Allowed models" } } } }, balance: { description: "ChatLuna balance management.", clear: { description: "Reset user balance.", arguments: { user: "Target user" }, examples: ["chatluna balance clear --user @username"], messages: { success: "User {0} balance reset to {1}" } }, set: { description: "Adjust user balance.", arguments: { user: "Target user", amount: "New balance" }, examples: ["chatluna balance set --user @username --amount 1000"], messages: { success: "User {0} balance updated to {1}" } }, query: { description: "Check user balance.", arguments: { user: "Target user (default: current user)" }, examples: ["chatluna balance query", "chatluna balance query --user @username"], messages: { success: "User {0} current balance: {1}" } } }, model: { description: "ChatLuna model management.", list: { description: "Display available models.", usage: "chatluna model list --page 1 --limit 10", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Available models:", footer: "Set default model: chatluna.room.set -m [model]", pages: "Page: [page] / [total]" } }, search: { description: "Search available models.", arguments: { query: "Search keyword" }, usage: "chatluna model search openai --page 1 --limit 10", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Search results:", footer: "Set default model: chatluna.room.set -m [model]", pages: "Page: [page] / [total]" } } }, memory: { description: "ChatLuna memory-related commands.", search: { description: "Search memories.", arguments: { query: "Search keyword." }, usage: 'chatluna memory search --query "Hello" --page 1 --limit 10', options: { page: "Page number.", limit: "Items per page.", type: "Memory preset.", view: "Memory layer." }, messages: { header: "Here is the list of memories found using the keyword {0} under the preset {1}:", footer: "", document_content: "Memory content: {0}", document_id: "Memory ID: {0}", document_type: "Memory type: {0}", document_expire: "Memory expire: {0}", document_level: "Memory level: {0}", pages: "Page: [page] / [total]", search_failed: "Failed to search memories.", invalid_view: "Invalid view type. Currently supported types are: {0}." } }, delete: { description: "Delete memory.", arguments: { ids: "Memory ID list." }, options: { type: "Memory preset.", view: "Memory layer." }, messages: { delete_success: "Memory deleted successfully.", delete_failed: "Failed to delete memory.", invalid_view: "Invalid view type. Currently supported types are: {0}." } }, clear: { description: "Clear memory.", options: { type: "Memory preset.", view: "Memory layer." }, messages: { clear_success: "Memory cleared successfully.", clear_failed: "Failed to clear memory.", invalid_view: "Invalid view type. Currently supported types are: {0}." } }, add: { description: "Add memory.", arguments: { content: "Memory content." }, options: { type: "Memory preset.", view: "Memory layer." }, messages: { add_success: "Memory added successfully.", add_failed: "Failed to add memory.", invalid_view: "Invalid view type. Currently supported types are: {0}." } }, edit: { description: "Edit memory.", arguments: { id: "Memory ID." }, options: { type: "Memory preset.", view: "Memory layer." }, messages: { edit_success: "Memory edited successfully.", edit_failed: "Failed to edit memory.", edit_memory_start: "Please send your new memory content.", invalid_view: "Invalid view type. Currently supported types are: {0}." } } }, preset: { description: "ChatLuna preset management.", list: { description: "Display available presets.", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Available presets:", footer: "Set default preset: chatluna.room.set -p [preset]", pages: "Page: [page] / [total]", preset_keyword: "Keyword: {0}", preset_content: "Content: {0}" } }, add: { description: "Create new preset.", arguments: { preset: "Preset name" }, messages: { conflict: "Preset keyword conflict. Choose a different keyword.", prompt: "Enter preset content.", timeout: "Operation timed out. Cancelled adding preset: {0}", success: 'Preset "{0}" created. Use chatluna.preset.list to view.' } }, clone: { description: "Duplicate existing preset.", arguments: { originPreset: "Source preset", newPresetName: "New preset name" }, messages: { conflict: "Preset keyword conflict. Choose a different name.", confirm: "Confirm cloning preset {0}? Enter Y to proceed.", timeout: "Operation timed out. Cancelled.", cancelled: "Operation cancelled.", success: 'Preset "{0}" cloned. Use chatluna.preset.list to view.' } }, set: { description: "Update existing preset.", arguments: { preset: "Preset name" }, messages: { not_found: "Preset not found.", not_support: "Cannot modify preset {0}. This complex preset requires editing via the control panel resource manager.", timeout: "Operation timed out. Cancelled.", cancelled: "Operation cancelled.", enter_content: "Enter new preset content.", success: 'Preset "{0}" updated. Use chatluna.preset.list to view.' } }, delete: { description: "Remove specified preset.", arguments: { preset: "Preset name" }, messages: { only_one_preset: "Cannot delete the only existing preset.", not_found: "Preset not found. Check the name and try again.", confirm_delete: "Delete preset {0}? Y to confirm, any other key to cancel. Note: Associated sessions will be deleted.", timeout: "Operation timed out. Cancelled deleting preset: {0}.", cancelled: "Cancelled deleting preset: {0}", success: "Preset {0} deleted. Restarting to apply changes." } } }, embeddings: { description: "ChatLuna embedding model management.", list: { description: "View embedding models.", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Supported embedding models:", footer: "Set default: chatluna.embeddings.set [model]", pages: "Page: [page] / [total]" } }, set: { description: "Set default embedding model.", arguments: { embeddings: "Model name" }, messages: { usage_hint: "Usage: chatluna.embeddings.set [model]", multiple_models_found: { header: "Multiple models found:", footer: "Please provide a more specific model name", example: "Example: chatluna.embeddings.set {0}" }, model_not_found: "Model not found. Check the name and try again.", success: "Default set to {0}. Restarting plugin to apply." } } }, vectorstore: { description: "ChatLuna vector database management.", list: { description: "View vector databases.", options: { page: "Page number", limit: "Items per page" }, messages: { header: "Supported vector databases:", footer: "Set default: chatluna.vectorstore.set [model] (uses in-memory if none set)", pages: "Page: [page] / [total]" } }, set: { description: "Set default vector database.", arguments: { vectorStore: "Database name" }, messages: { usage_hint: "Usage: chatluna.vectorstore.set [model]", multiple_stores_found: { header: "Multiple databases found:", footer: "Please provide a more specific database name", example: "Example: chatluna.vectorstore.set {0}" }, store_not_found: "Database not found. Check the name and try again.", success: "Default set to {0}. Restarting plugin to apply." } } } } }, chatluna: { aborted: "Current conversation generation stopped successfully.", thinking_message: "Processing... {0} messages in queue. Please wait.", block_message: "You have been blacklisted. Please contact the system administrator.", error_message: "ChatLuna error occurred. Error code: %s. Contact developer for assistance.", middleware_error: "Error in {0}: {1}", chat_limit_exceeded: "Daily chat limit reached. Please try again in {0} minutes.", room: { random_switch: "No room specified. Switched to room {0}.", not_joined: "No room joined. Please join a room first.", not_in_room: "Not a member of this room. Please join room {0} first.", muted: "You are muted in room {0}.", unavailable: "Current room unavailable. Automatic repair in progress.", auto_switch: "User {0} switched to room {1}.", auto_create: "Room {1} created for user {0}.", auto_create_template: "Template clone room {1} created for user {0}.", room_name: "{0} room", template_clone_room_name: "{0} template clone room", config_changed: "Configuration updated for template room {0}." }, cooldown_wait_message: "Message rate limit reached. Please wait {0}s before sending another message." } };
  }
});

// src/index.ts
import { Logger as Logger4, Time as Time3 } from "koishi";
import { ChatLunaService } from "koishi-plugin-chatluna/services/chat";
import { forkScopeToDisposable } from "koishi-plugin-chatluna/utils/koishi";
import {
  clearLogger,
  createLogger as createLogger9,
  setLoggerLevel
} from "koishi-plugin-chatluna/utils/logger";
import * as request from "koishi-plugin-chatluna/utils/request";

// src/authorization/service.ts
import { Decimal } from "decimal.js";
import { Service } from "koishi";
import {
  ChatLunaError,
  ChatLunaErrorCode
} from "koishi-plugin-chatluna/utils/error";
var ChatLunaAuthService = class extends Service {
  constructor(ctx, config) {
    super(ctx, "chatluna_auth");
    this.ctx = ctx;
    this.config = config;
    ctx.on("ready", async () => {
      await this._defineDatabase();
    });
  }
  static {
    __name(this, "ChatLunaAuthService");
  }
  async getUser(session, userId = session.userId) {
    const list = await this.ctx.database.get("chathub_auth_user", {
      userId
    });
    if (list.length === 0) {
      return this._createUser(session, userId);
    } else if (list.length > 1) {
      throw new ChatLunaError(ChatLunaErrorCode.USER_NOT_FOUND);
    }
    return list[0];
  }
  async _createUser(session, userId = session.userId) {
    const user = await this.ctx.database.getUser(session.platform, userId);
    if (user == null) {
      throw new ChatLunaError(
        ChatLunaErrorCode.USER_NOT_FOUND,
        new Error(`
                user not found in platform ${session.platform} and id ${userId}`)
      );
    }
    const resolveAuthType = /* @__PURE__ */ __name((authType2) => authType2 > 2 ? "admin" : authType2 > 1 ? "user" : "guest", "resolveAuthType");
    const copyOfSession = session?.bot?.session(session.event) ?? session;
    copyOfSession.userId = userId;
    let [rawAuthType, balance, authGroup] = await copyOfSession.resolve(
      this.config.authUserDefaultGroup
    ) ?? [0, 0, "guest"];
    const authType = resolveAuthType(
      user.authority > rawAuthType ? user.authority : rawAuthType
    );
    if (authType === "admin") {
      authGroup = authType;
    }
    const authUser = {
      userId,
      balance: balance === 0 ? authType === "admin" ? 1e4 : authType === "user" ? 10 : 1 : balance,
      authType
    };
    await this.ctx.database.upsert("chathub_auth_user", [authUser]);
    await this.addUserToGroup(authUser, authGroup);
    return authUser;
  }
  async createAuthGroup(session, group) {
    const user = await this.getUser(session);
    await this.ctx.database.upsert("chathub_auth_group", [group]);
    await this.addUserToGroup(user, group.name);
  }
  async resolveAuthGroup(session, platform, userId = session.userId) {
    const groups = (await this.ctx.database.get("chathub_auth_group", {
      platform: {
        $or: [void 0, platform]
      }
    })).sort((a2, b2) => {
      if (a2.platform === platform) {
        return -1;
      }
      if (b2.platform === platform) {
        return 1;
      }
      return b2.priority - a2.priority;
    });
    const groupIds = groups.map((g) => g.id);
    const joinedGroups = (await this.ctx.database.get("chathub_auth_joined_user", {
      groupId: {
        // max 50??
        $in: groupIds
      },
      userId
    })).sort(
      (a2, b2) => groupIds.indexOf(a2.groupId) - groupIds.indexOf(b2.groupId)
    );
    if (joinedGroups.length === 0) {
      throw new ChatLunaError(ChatLunaErrorCode.AUTH_GROUP_NOT_JOINED);
    }
    const result2 = groups.find((g) => g.id === joinedGroups[0].groupId);
    if (result2 == null) {
      throw new ChatLunaError(
        ChatLunaErrorCode.AUTH_GROUP_NOT_FOUND,
        new Error(`Group not found for user ${session.username} and platform
                ${platform}`)
      );
    }
    return result2;
  }
  async getAuthGroups(platform) {
    const groups = await this.ctx.database.get("chathub_auth_group", {
      platform
    });
    return groups;
  }
  async getAuthGroup(name2, throwError = true) {
    const result2 = (await this.ctx.database.get("chathub_auth_group", { name: name2 }))?.[0];
    if (result2 == null && throwError) {
      throw new ChatLunaError(ChatLunaErrorCode.AUTH_GROUP_NOT_FOUND);
    }
    return result2;
  }
  async calculateBalance(session, platform, usedTokenNumber, userId = session.userId) {
    const currentAuthGroup = await this.resolveAuthGroup(
      session,
      platform,
      userId
    );
    const usedBalance = new Decimal(1e-3).mul(currentAuthGroup.costPerToken).mul(usedTokenNumber);
    return await this.modifyBalance(session, -usedBalance.toNumber());
  }
  async getBalance(session, userId = session.userId) {
    return (await this.getUser(session, userId)).balance;
  }
  async modifyBalance(session, amount, userId = session.userId) {
    const user = await this.getUser(session, userId);
    user.balance = new Decimal(user.balance).add(amount).toNumber();
    await this.ctx.database.upsert("chathub_auth_user", [user]);
    return user.balance;
  }
  async setBalance(session, amount, userId = session.userId) {
    const user = await this.getUser(session, userId);
    user.balance = amount;
    await this.ctx.database.upsert("chathub_auth_user", [user]);
    return user.balance;
  }
  async _getAuthGroup(authGroupId) {
    const authGroup = (await this.ctx.database.get("chathub_auth_group", {
      id: authGroupId
    }))?.[0];
    if (authGroup == null) {
      throw new ChatLunaError(
        ChatLunaErrorCode.AUTH_GROUP_NOT_FOUND,
        new Error(`Auth group not found for id ${authGroupId}`)
      );
    }
    return authGroup;
  }
  async resetAuthGroup(authGroupId) {
    const authGroup = await this._getAuthGroup(authGroupId);
    const currentTime = /* @__PURE__ */ new Date();
    authGroup.lastCallTime = authGroup.lastCallTime ?? currentTime.getTime();
    const authGroupDate = new Date(authGroup.lastCallTime);
    const currentDayOfStart = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    if (authGroupDate.getTime() < currentDayOfStart) {
      authGroup.currentLimitPerDay = 0;
      authGroup.currentLimitPerMin = 0;
      authGroup.lastCallTime = currentTime.getTime();
      await this.ctx.database.upsert("chathub_auth_group", [authGroup]);
      return authGroup;
    }
    if (currentTime.getTime() - authGroup.lastCallTime >= 6e4) {
      authGroup.currentLimitPerMin = 0;
      authGroup.lastCallTime = currentTime.getTime();
      await this.ctx.database.upsert("chathub_auth_group", [authGroup]);
      return authGroup;
    }
    return authGroup;
  }
  async increaseAuthGroupCount(authGroupId) {
    const authGroup = await this._getAuthGroup(authGroupId);
    const currentTime = /* @__PURE__ */ new Date();
    authGroup.lastCallTime = authGroup.lastCallTime ?? currentTime.getTime();
    const authGroupDate = new Date(authGroup.lastCallTime);
    const currentDayOfStart = (/* @__PURE__ */ new Date()).setHours(0, 0, 0, 0);
    if (authGroupDate.getTime() < currentDayOfStart) {
      authGroup.currentLimitPerDay = 1;
      authGroup.currentLimitPerMin = 1;
      authGroup.lastCallTime = currentTime.getTime();
      await this.ctx.database.upsert("chathub_auth_group", [authGroup]);
      return;
    }
    if (currentTime.getTime() - authGroup.lastCallTime >= 6e4) {
      authGroup.currentLimitPerDay += 1;
      authGroup.currentLimitPerMin = 1;
      authGroup.lastCallTime = currentTime.getTime();
      await this.ctx.database.upsert("chathub_auth_group", [authGroup]);
    }
    authGroup.currentLimitPerDay += 1;
    authGroup.currentLimitPerMin += 1;
    await this.ctx.database.upsert("chathub_auth_group", [authGroup]);
  }
  async addUserToGroup(user, groupName) {
    const group = await this.getAuthGroup(groupName);
    const isJoined = (await this.ctx.database.get("chathub_auth_joined_user", {
      groupName,
      userId: user.userId
    })).length === 1;
    if (isJoined) {
      throw new ChatLunaError(ChatLunaErrorCode.AUTH_GROUP_ALREADY_JOINED);
    }
    await this.ctx.database.upsert("chathub_auth_joined_user", [
      {
        userId: user.userId,
        groupId: group.id,
        groupName: group.name
      }
    ]);
  }
  async removeUserFormGroup(user, groupName) {
    const group = await this.getAuthGroup(groupName);
    await this.ctx.database.remove("chathub_auth_joined_user", {
      userId: user.userId,
      groupName: group.name
    });
  }
  async setAuthGroup(groupName, group) {
    await this.ctx.database.upsert("chathub_auth_group", [
      Object.assign({}, group, {
        name: groupName
      })
    ]);
  }
  async _initAuthGroup() {
    const groups = await this.ctx.database.get("chathub_auth_group", {
      name: {
        $in: ["guest", "user", "admin"]
      }
    });
    let currentGroup;
    if (!groups.some((g) => g.name === "guest")) {
      currentGroup = {
        name: "guest",
        priority: 0,
        limitPerMin: 10,
        limitPerDay: 2e3,
        // 1000 token / 0.3
        costPerToken: 0.3
      };
      await this.ctx.database.upsert("chathub_auth_group", [currentGroup]);
    }
    if (!groups.some((g) => g.name === "user")) {
      currentGroup = {
        name: "user",
        priority: 1,
        limitPerMin: 1e3,
        limitPerDay: 2e5,
        // 1000 token / 0.01
        costPerToken: 0.01
      };
      await this.ctx.database.upsert("chathub_auth_group", [currentGroup]);
    }
    if (!groups.some((g) => g.name === "admin")) {
      currentGroup = {
        name: "admin",
        priority: 2,
        limitPerMin: 1e4,
        limitPerDay: 2e7,
        // 1000 token / 0.001
        costPerToken: 1e-3
      };
      await this.ctx.database.upsert("chathub_auth_group", [currentGroup]);
    }
  }
  async _defineDatabase() {
    const ctx = this.ctx;
    ctx.database.extend(
      "chathub_auth_user",
      {
        userId: {
          type: "string"
        },
        balance: {
          type: "decimal",
          precision: 20,
          scale: 10
        },
        authType: {
          type: "char",
          length: 50
        }
      },
      {
        autoInc: false,
        primary: "userId",
        unique: ["userId"]
      }
    );
    ctx.database.extend(
      "chathub_auth_joined_user",
      {
        userId: "string",
        groupId: "integer",
        groupName: "string",
        id: "integer"
      },
      {
        autoInc: true,
        primary: "id",
        unique: ["id"]
      }
    );
    ctx.database.extend(
      "chathub_auth_group",
      {
        limitPerDay: {
          type: "integer",
          nullable: false
        },
        limitPerMin: {
          type: "integer",
          nullable: false
        },
        lastCallTime: {
          type: "integer",
          length: 7,
          nullable: true
        },
        currentLimitPerDay: {
          type: "integer",
          nullable: true
        },
        currentLimitPerMin: {
          type: "integer",
          nullable: true
        },
        supportModels: {
          type: "json",
          nullable: true
        },
        priority: {
          type: "integer",
          nullable: false,
          initial: 0
        },
        platform: {
          type: "char",
          length: 255,
          nullable: true
        },
        costPerToken: {
          type: "decimal",
          precision: 8,
          scale: 4
        },
        name: {
          type: "char",
          length: 255
        },
        id: {
          type: "integer"
        }
      },
      {
        autoInc: true,
        primary: "id",
        unique: ["id", "name"]
      }
    );
    await this._initAuthGroup();
  }
};

// src/commands/auth.ts
function apply(ctx, config, chain) {
  if (config.authSystem !== true) return;
  ctx.command("chatluna.auth", { authority: 1 });
  ctx.command("chatluna.auth.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").option("platform", "-t <platform:string>").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_auth_group", {
      authPlatform: options.platform,
      page: options.page ?? 1,
      limit: options.limit ?? 3
    });
  });
  ctx.command("chatluna.auth.add <name:string>").option("user", "-u <user:user>").action(async ({ session, options }, name2) => {
    const userId = options.user?.split(":")?.[1] ?? session.userId;
    await chain.receiveCommand(session, "add_user_to_auth_group", {
      auth_group_resolve: { name: name2 },
      authUser: userId
    });
  });
  ctx.command("chatluna.auth.kick <name:string>").option("user", "-u <user:user>").action(async ({ session, options }, name2) => {
    const userId = options.user?.split(":")?.[1] ?? session.userId;
    await chain.receiveCommand(session, "kick_user_form_auth_group", {
      auth_group_resolve: { name: name2 },
      authUser: userId
    });
  });
  ctx.command("chatluna.auth.create").option("name", "-n <name:string>").option("preMin", "-pm <min:number>").option("preDay", "-pd <day:number>").option("platform", "-pf <platform:string>").option("supportModels", "-s [...model]").option("priority", "-p <priority:number>").option("cost", "-c <cost:number>").action(async ({ session, options }) => {
    await chain.receiveCommand(session, "create_auth_group", {
      auth_group_resolve: {
        name: options.name ?? void 0,
        requestPreDay: options.preDay ?? void 0,
        requestPreMin: options.preMin ?? void 0,
        platform: options.platform ?? void 0,
        supportModels: options.supportModels ?? void 0,
        priority: options.priority ?? void 0
      }
    });
  });
  ctx.command("chatluna.auth.set").option("name", "-n <name:string>").option("preMin", "-pm <min:number>").option("preDay", "-pd <day:number>").option("platform", "-pf <platform:string>").option("supportModels", "-s [...model]").option("priority", "-p <priority:number>").option("cost", "-c <cost:number>").action(async ({ session, options }) => {
    await chain.receiveCommand(session, "set_auth_group", {
      auth_group_resolve: {
        name: options.name ?? void 0,
        requestPreDay: options.preDay ?? void 0,
        requestPreMin: options.preMin ?? void 0,
        platform: options.platform ?? void 0,
        supportModels: options.supportModels ?? void 0,
        priority: options.priority ?? void 0
      }
    });
  });
  ctx.command("chatluna.balance");
  ctx.command("chatluna.balance.clear <user:user>", { authority: 3 }).action(
    async ({ session }, user) => {
      const userId = user?.split(":")?.[1] ?? user;
      await chain.receiveCommand(session, "clear_balance", {
        authUser: userId
      });
    }
  );
  ctx.command("chatluna.balance.set <balance:number>", { authority: 3 }).option("user", "-u <user:user>").action(async ({ options, session }, balance) => {
    const userId = options.user?.split(":")?.[1] ?? session.userId;
    await chain.receiveCommand(session, "set_balance", {
      authUser: userId,
      balance
    });
  });
  ctx.command("chatluna.balance.query [user:user]").action(
    async ({ session }, user) => {
      const userId = user?.split(":")?.[1] ?? session.userId;
      await chain.receiveCommand(session, "query_balance", {
        authUser: userId
      });
    }
  );
}
__name(apply, "apply");

// src/commands/chat.ts
import { h } from "koishi";
function apply2(ctx, config, chain) {
  ctx.command("chatluna", {
    authority: 1
  }).alias("chatluna");
  ctx.command("chatluna.chat", {
    authority: 1
  });
  ctx.command("chatluna.chat.text <message:text>").option("room", "-r <room:string>").option("type", "-t <type: string>").action(async ({ options, session }, message) => {
    const renderType = options.type ?? config.outputMode;
    if (!ctx.chatluna.renderer.rendererTypeList.some(
      (type) => type === renderType
    )) {
      return session.text(".invalid-render-type");
    }
    const elements = h.parse(message);
    await chain.receiveCommand(
      session,
      "",
      {
        message: elements,
        room_resolve: {
          name: options.room
        },
        renderOptions: {
          session,
          split: config.splitMessage,
          type: renderType
        }
      },
      ctx
    );
  });
  ctx.command("chatluna.chat.rollback [message:text]").option("room", "-r <room:string>").option("i", "-i <i: string>").action(async ({ options, session }, message) => {
    const elements = message ? h.parse(message) : void 0;
    await chain.receiveCommand(
      session,
      "rollback",
      {
        message: elements,
        room_resolve: {
          name: options.room
        },
        renderOptions: {
          session,
          split: config.splitMessage,
          type: config.outputMode
        },
        rollback_round: options.i ?? 1
      },
      ctx
    );
  });
  ctx.command("chatluna.chat.stop").option("room", "-r <room:string>").action(async ({ options, session }, message) => {
    await chain.receiveCommand(
      session,
      "stop_chat",
      {
        room_resolve: {
          name: options.room
        }
      },
      ctx
    );
  });
  ctx.command("chatluna.chat.voice <message:text>").option("room", "-r <room:string>").option("speaker", "-s <speakerId:number>", { authority: 1 }).action(async ({ options, session }, message) => {
    const elements = message ? h.parse(message) : void 0;
    await chain.receiveCommand(
      session,
      "",
      {
        message: elements,
        renderOptions: {
          split: config.splitMessage,
          type: "voice",
          voice: {
            speakerId: options.speaker
          },
          session
        },
        room_resolve: {
          name: options.room
        }
      },
      ctx
    );
  });
  ctx.command("chatluna.wipe", { authority: 3 }).action(
    async ({ session }) => {
      await chain.receiveCommand(session, "wipe");
    }
  );
  ctx.command("chatluna.restart").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "restart");
  });
}
__name(apply2, "apply");

// src/commands/memory.ts
function apply3(ctx, config, chain) {
  ctx.inject(["chatluna_long_memory"], (ctx2) => {
    ctx2.command("chatluna.memory", { authority: 1 });
    ctx2.command("chatluna.memory.search <query:string>").option("type", "-t <type:string>").option("limit", "-l <limit:number>").option("page", "-p <page:number>").option("view", "-v <view:string>").action(async ({ options, session }, query) => {
      await chain.receiveCommand(session, "search_memory", {
        type: options.type,
        page: options.page ?? 1,
        limit: options.limit ?? 6,
        view: options.view,
        query
      });
    });
    ctx2.command("chatluna.memory.delete <...ids>").option("type", "-t <type:string>").option("view", "-v <view:string>").action(async ({ session, options }, ...ids) => {
      await chain.receiveCommand(session, "delete_memory", {
        ids,
        type: options.type,
        view: options.view
      });
    });
    ctx2.command("chatluna.memory.clear").option("type", "-t <type:string>").option("view", "-v <view:string>").action(async ({ session, options }) => {
      await chain.receiveCommand(session, "clear_memory", {
        type: options.type,
        view: options.view
      });
    });
    ctx2.command("chatluna.memory.add <content:text>").option("type", "-t <type:string>").option("view", "-v <view:string>").action(async ({ session, options }, content) => {
      await chain.receiveCommand(session, "add_memory", {
        type: options.type,
        view: options.view,
        content
      });
    });
    ctx2.command("chatluna.memory.edit <id:string>").option("type", "-t <type:string>").option("view", "-v <view:string>").action(async ({ session, options }, id, content) => {
      await chain.receiveCommand(session, "edit_memory", {
        memoryId: id,
        content,
        type: options.type,
        view: options.view
      });
    });
  });
}
__name(apply3, "apply");

// src/commands/model.ts
function apply4(ctx, config, chain) {
  ctx.command("chatluna.model", {
    authority: 1
  });
  ctx.command("chatluna.model.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_model", {
      page: options.page ?? 1,
      limit: options.limit ?? 5
    });
  });
  ctx.command("chatluna.model.search <query:string>").option("page", "-p <page:number>").option("limit", "-l <limit:number>").action(async ({ options, session }, query) => {
    await chain.receiveCommand(session, "search_model", {
      query,
      page: options.page ?? 1,
      limit: options.limit ?? 5
    });
  });
}
__name(apply4, "apply");

// src/commands/preset.ts
function apply5(ctx, config, chain) {
  ctx.command("chatluna.preset", { authority: 1 });
  ctx.command("chatluna.preset.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_preset", {
      page: options.page ?? 1,
      limit: options.limit ?? 3
    });
  });
  ctx.command("chatluna.preset.add <preset:string>").action(
    async ({ session }, preset) => {
      await chain.receiveCommand(session, "add_preset", {
        addPreset: preset
      });
    }
  );
  ctx.command(
    "chatluna.preset.clone <originPreset:string> [newPresetName:string]",
    { authority: 3 }
  ).action(async ({ session }, preset, newPreset) => {
    await chain.receiveCommand(session, "clone_preset", {
      clonePreset: {
        name: preset,
        newName: newPreset ?? preset + "(1)"
      }
    });
  });
  ctx.command("chatluna.preset.set <preset:string>", { authority: 3 }).action(
    async ({ session }, preset) => {
      await chain.receiveCommand(session, "set_preset", {
        setPreset: preset
      });
    }
  );
  ctx.command("chatluna.preset.delete <preset:string>", {
    authority: 3
  }).action(async ({ session }, preset) => {
    await chain.receiveCommand(session, "delete_preset", {
      deletePreset: preset
    });
  });
}
__name(apply5, "apply");

// src/commands/providers.ts
function apply6(ctx, config, chain) {
  ctx.command("chatluna.embeddings", { authority: 1 });
  ctx.command("chatluna.vectorstore", { authority: 1 });
  ctx.command("chatluna.embeddings.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_embeddings", {
      page: options.page ?? 1,
      limit: options.limit ?? 5
    });
  });
  ctx.command("chatluna.vectorstore.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_vector_store", {
      page: options.page ?? 1,
      limit: options.limit ?? 5
    });
  });
  ctx.command("chatluna.embeddings.set <embeddings:string>", {
    authority: 3
  }).action(async ({ session }, embeddings) => {
    await chain.receiveCommand(session, "set_embeddings", {
      setEmbeddings: embeddings
    });
  });
  ctx.command("chatluna.vectorstore.set <vectorStore:string>", {
    authority: 3
  }).action(async ({ session }, vectorStore) => {
    await chain.receiveCommand(session, "set_vector_store", {
      setVectorStore: vectorStore
    });
  });
}
__name(apply6, "apply");

// src/commands/room.ts
function apply7(ctx, config, chain) {
  ctx.command("chatluna.room");
  ctx.command("chatluna.room.create").option("name", "-n <name:string>").option("preset", "-p <preset:string>").option("model", "-m <model:string>").option("chatMode", "-c <chatMode:string>").option("password", "-w <password:string>").option("visibility", "-v <visibility:string>").action(async ({ session, options }) => {
    await chain.receiveCommand(session, "create_room", {
      room_resolve: {
        name: options.name ?? void 0,
        preset: options.preset ?? void 0,
        model: options.model ?? void 0,
        chatMode: options.chatMode ?? void 0,
        password: options.password ?? void 0,
        visibility: options.visibility ?? void 0
      }
    });
  });
  ctx.command("chatluna.room.delete [room:text]").action(
    async ({ session }, room) => {
      await chain.receiveCommand(session, "delete_room", {
        room_resolve: {
          name: room
        }
      });
    }
  );
  ctx.command("chatluna.room.auto-update <status:string>").option("room", "-r <room:string>").action(async ({ session, options }, status) => {
    if (status.toLowerCase() !== "true" && status.toLowerCase() !== "false") {
      return session.text(".messages.invalid-status");
    }
    await chain.receiveCommand(session, "set_auto_update_room", {
      room_resolve: {
        name: options.room
      },
      auto_update_room: status.toLowerCase() === "true"
    });
  });
  ctx.command("chatluna.room.kick <...arg:user>").action(
    async ({ session }, ...user) => {
      const users = user.map((u) => u.split(":")[1]);
      await chain.receiveCommand(session, "kick_member", {
        resolve_user: {
          id: users
        }
      });
    }
  );
  ctx.command("chatluna.room.invite <...arg:user>").action(
    async ({ session }, ...user) => {
      const users = user.map((u) => u.split(":")[1]);
      await chain.receiveCommand(session, "invite_room", {
        resolve_user: {
          id: users
        }
      });
    }
  );
  ctx.command("chatluna.room.join <id:text>").action(
    async ({ session }, name2) => {
      await chain.receiveCommand(session, "join_room", {
        room_resolve: {
          name: name2
        }
      });
    }
  );
  ctx.command("chatluna.room.leave [room:text]").action(
    async ({ session, options }, room) => {
      await chain.receiveCommand(session, "leave_room", {
        room_resolve: {
          name: room,
          id: room
        }
      });
    }
  );
  ctx.command("chatluna.room.clear [room:text]").alias("chatluna.chat.clear").action(async ({ session }, room) => {
    await chain.receiveCommand(session, "clear_room", {
      room_resolve: {
        name: room
      }
    });
  });
  ctx.command("chatluna.room.set").option("name", "-n <name:string>").option("preset", "-p <preset:string>").option("model", "-m <model:string>").option("chatMode", "-c <chatMode:string>").option("password", "-w <password:string>").option("visibility", "-v <visibility:string>").action(async ({ session, options }) => {
    await chain.receiveCommand(session, "set_room", {
      room_resolve: {
        name: options.name ?? void 0,
        preset: options.preset ?? void 0,
        model: options.model ?? void 0,
        chatMode: options.chatMode ?? void 0,
        password: options.password ?? void 0,
        visibility: options.visibility ?? void 0
      }
    });
  });
  ctx.command("chatluna.room.list").option("page", "-p <page:number>").option("limit", "-l <limit:number>").option("all", "-a").action(async ({ options, session }) => {
    await chain.receiveCommand(session, "list_room", {
      page: options.page ?? 1,
      limit: options.limit ?? 2,
      all_room: options.all ?? false
    });
  });
  ctx.command("chatluna.room.transfer <arg:user>").action(
    async ({ session }, user) => {
      await chain.receiveCommand(session, "transfer_room", {
        resolve_user: {
          id: user.split(":")[1]
        }
      });
    }
  );
  ctx.command("chatluna.room.info [room:text]").action(
    async ({ session }, room) => {
      await chain.receiveCommand(session, "room_info", {
        room_resolve: {
          name: room
        }
      });
    }
  );
  ctx.command("chatluna.room.switch <name:text>").action(
    async ({ session }, name2) => {
      await chain.receiveCommand(session, "switch_room", {
        room_resolve: {
          name: name2,
          id: name2
        }
      });
    }
  );
  ctx.command("chatluna.room.permission <user:user>").action(
    async ({ session }, user) => {
      await chain.receiveCommand(session, "room_permission", {
        resolve_user: {
          id: user.split(":")[1]
        }
      });
    }
  );
  ctx.command("chatluna.room.mute <...user:user>").option("room", "-r <room:string>").action(async ({ session, options }, ...user) => {
    await chain.receiveCommand(session, "mute_user", {
      room_resolve: {
        name: options.room
      },
      resolve_user: {
        id: user.map((u) => u.split(":")[1])
      }
    });
  });
}
__name(apply7, "apply");

// src/command.ts
async function command(ctx, config) {
  const middlewares = (
    // middleware start
    [apply, apply2, apply3, apply4, apply5, apply6, apply7]
  );
  for (const middleware2 of middlewares) {
    await middleware2(ctx, config, ctx.chatluna.chatChain);
  }
}
__name(command, "command");

// src/llm-core/chat/default.ts
import { Schema } from "koishi";
import { logger as logger2 } from "koishi-plugin-chatluna";
import {
  ModelType
} from "koishi-plugin-chatluna/llm-core/platform/types";

// src/llm-core/chain/chat_chain.ts
import { AIMessage } from "@langchain/core/messages";
import {
  callChatLunaChain,
  ChatLunaLLMChain,
  ChatLunaLLMChainWrapper
} from "koishi-plugin-chatluna/llm-core/chain/base";
import { ChatLunaChatPrompt } from "koishi-plugin-chatluna/llm-core/chain/prompt";
var ChatHubChatChain = class _ChatHubChatChain extends ChatLunaLLMChainWrapper {
  static {
    __name(this, "ChatHubChatChain");
  }
  botName;
  chain;
  historyMemory;
  preset;
  variableService;
  constructor({
    botName,
    historyMemory,
    preset,
    chain,
    variableService
  }) {
    super();
    this.botName = botName;
    this.historyMemory = historyMemory;
    this.preset = preset;
    this.variableService = variableService;
    this.chain = chain;
  }
  static fromLLM(llm, {
    botName,
    historyMemory,
    preset,
    variableService
  }) {
    const prompt = new ChatLunaChatPrompt({
      preset,
      tokenCounter: /* @__PURE__ */ __name((text) => llm.getNumTokens(text), "tokenCounter"),
      sendTokenLimit: llm.invocationParams().maxTokenLimit ?? llm.getModelMaxContextSize(),
      variableService
    });
    const chain = new ChatLunaLLMChain({ llm, prompt });
    return new _ChatHubChatChain({
      botName,
      historyMemory,
      variableService,
      preset,
      chain
    });
  }
  async call({
    message,
    stream,
    events,
    conversationId,
    variables,
    signal,
    maxToken
  }) {
    const requests = {
      input: message
    };
    const chatHistory = await this.historyMemory.loadMemoryVariables(requests);
    requests["chat_history"] = chatHistory[this.historyMemory.memoryKey];
    requests["variables"] = variables ?? {};
    requests["id"] = conversationId;
    const response = await callChatLunaChain(
      this.chain,
      {
        ...requests,
        stream,
        maxTokens: maxToken,
        signal
      },
      events
    );
    if (response.text == null) {
      throw new Error("response.text is null");
    }
    const aiMessage = response.message ?? new AIMessage(response.text);
    response.message = aiMessage;
    return response;
  }
  get model() {
    return this.chain.llm;
  }
};

// src/llm-core/chain/plugin_chat_chain.ts
import { AIMessage as AIMessage2 } from "@langchain/core/messages";
import {
  ChatLunaLLMChainWrapper as ChatLunaLLMChainWrapper2
} from "koishi-plugin-chatluna/llm-core/chain/base";
import {
  AgentExecutor,
  createOpenAIAgent,
  createReactAgent
} from "koishi-plugin-chatluna/llm-core/agent";
import {
  ChatLunaError as ChatLunaError2,
  ChatLunaErrorCode as ChatLunaErrorCode2
} from "koishi-plugin-chatluna/utils/error";
import { ChatLunaChatPrompt as ChatLunaChatPrompt2 } from "koishi-plugin-chatluna/llm-core/chain/prompt";
var ChatLunaPluginChain = class _ChatLunaPluginChain extends ChatLunaLLMChainWrapper2 {
  static {
    __name(this, "ChatLunaPluginChain");
  }
  executor;
  historyMemory;
  systemPrompts;
  llm;
  embeddings;
  activeTools = [];
  tools;
  baseMessages = void 0;
  variableService;
  prompt;
  preset;
  agentMode;
  constructor({
    historyMemory,
    prompt,
    llm,
    tools,
    preset,
    embeddings,
    agentMode
  }) {
    super();
    this.historyMemory = historyMemory;
    this.prompt = prompt;
    this.tools = tools;
    this.embeddings = embeddings;
    this.llm = llm;
    this.agentMode = agentMode ?? "react";
    this.preset = preset;
  }
  static async fromLLMAndTools(llm, tools, {
    historyMemory,
    preset,
    embeddings,
    agentMode,
    variableService
  }) {
    const prompt = new ChatLunaChatPrompt2({
      preset,
      tokenCounter: /* @__PURE__ */ __name((text) => llm.getNumTokens(text), "tokenCounter"),
      variableService,
      sendTokenLimit: llm.invocationParams().maxTokenLimit ?? llm.getModelMaxContextSize()
    });
    return new _ChatLunaPluginChain({
      historyMemory,
      prompt,
      llm,
      agentMode,
      embeddings,
      tools,
      preset,
      variableService
    });
  }
  async _createExecutor(llm, tools) {
    if (this.agentMode === "react") {
      return AgentExecutor.fromAgentAndTools({
        tags: ["react"],
        agent: await createReactAgent({
          llm,
          tools,
          prompt: this.prompt,
          instructions: await this.preset().then((preset) => {
            return preset.config.reActInstruction;
          })
        }),
        tools,
        memory: void 0,
        verbose: false,
        handleParsingErrors: true
      });
    }
    return AgentExecutor.fromAgentAndTools({
      tags: ["tool-calling"],
      agent: createOpenAIAgent({
        llm,
        tools,
        prompt: this.prompt
      }),
      tools,
      memory: void 0,
      verbose: false
    });
  }
  _getActiveTools(session, messages2) {
    const tools = this.activeTools;
    const newActiveTools = this.tools.map(
      (tool) => {
        const base = tool.selector(messages2);
        if (tool.authorization) {
          return [tool, tool.authorization(session) && base];
        }
        return [tool, base];
      }
    );
    const differenceTools = newActiveTools.filter((tool) => {
      const include = tools.includes(tool[0]);
      return !include || include && tool[1] === false;
    });
    if (differenceTools.length > 0) {
      for (const differenceTool of differenceTools) {
        if (differenceTool[1] === false) {
          const index = tools.findIndex(
            (tool) => tool === differenceTool[0]
          );
          if (index > -1) {
            tools.splice(index, 1);
          }
        } else {
          tools.push(differenceTool[0]);
        }
      }
      return [this.activeTools, true];
    }
    return [
      this.tools,
      this.tools.some((tool) => tool?.alwaysRecreate === true)
    ];
  }
  async call({
    message,
    signal,
    session,
    events,
    conversationId,
    variables,
    maxToken
  }) {
    const requests = {
      input: message
    };
    this.baseMessages = await this.historyMemory.chatHistory.getMessages();
    requests["chat_history"] = this.baseMessages;
    requests["id"] = conversationId;
    requests["variables"] = variables ?? {};
    const [activeTools, recreate] = this._getActiveTools(
      session,
      this.baseMessages.concat(message)
    );
    if (recreate || this.executor == null) {
      const preset = await this.preset();
      const tools = activeTools.map(
        (tool) => tool.createTool(
          {
            model: this.llm,
            embeddings: this.embeddings,
            conversationId,
            preset: preset.triggerKeyword[0],
            userId: session.userId
          },
          session
        )
      );
      this.executor = await this._createExecutor(
        this.llm,
        await Promise.all(tools)
      );
      this.baseMessages = await this.historyMemory.chatHistory.getMessages();
      requests["chat_history"] = this.baseMessages;
    }
    let usedToken = 0;
    let response;
    const request2 = /* @__PURE__ */ __name(() => {
      return this.executor.invoke(
        {
          ...requests,
          maxTokens: maxToken
        },
        {
          signal,
          callbacks: [
            {
              handleLLMEnd(output) {
                usedToken += output.llmOutput?.tokenUsage?.totalTokens ?? 0;
              },
              handleAgentAction(action) {
                events?.["llm-call-tool"](
                  action.tool,
                  action.toolInput,
                  action.log
                );
              },
              handleLLMNewToken(token) {
                events?.["llm-new-token"](token);
              }
            }
          ]
        }
      );
    }, "request");
    for (let i = 0; i < 3; i++) {
      if (signal.aborted) {
        throw new ChatLunaError2(ChatLunaErrorCode2.ABORTED);
      }
      try {
        response = await request2();
        break;
      } catch (e) {
        if (e.message.includes("Aborted")) {
          throw new ChatLunaError2(ChatLunaErrorCode2.ABORTED);
        }
        logger.error(e);
      }
    }
    await events?.["llm-used-token-count"]?.(usedToken);
    const responseString = response.output;
    response.message = new AIMessage2(responseString);
    return response;
  }
  get model() {
    return this.llm;
  }
};

// src/llm-core/chat/default.ts
async function defaultFactory(ctx, service) {
  ctx.on("chatluna/chat-chain-added", (service2) => {
    updateChatChains(ctx, service2);
  });
  ctx.on("chatluna/chat-chain-removed", (service2) => {
    updateChatChains(ctx, service2);
  });
  ctx.on("chatluna/model-added", (service2) => {
    updateModels(ctx, service2);
  });
  ctx.on("chatluna/model-removed", (service2) => {
    updateModels(ctx, service2);
  });
  ctx.on("chatluna/embeddings-added", (service2) => {
    updateEmbeddings(ctx, service2);
  });
  ctx.on("chatluna/embeddings-removed", (service2) => {
    updateEmbeddings(ctx, service2);
  });
  ctx.on("chatluna/vector-store-added", (service2) => {
    updateVectorStores(ctx, service2);
  });
  ctx.on("chatluna/vector-store-removed", (service2) => {
    updateVectorStores(ctx, service2);
  });
  ctx.on("chatluna/tool-updated", () => {
    const wrapper = ctx.chatluna.getCachedInterfaceWrapper();
    if (wrapper == null) {
      return;
    }
    wrapper.getCachedConversations().filter(
      ([_, conversation]) => conversation?.chatInterface?.chatMode === "plugin" || conversation?.chatInterface?.chatMode === "browsing"
    ).forEach(async ([id, info]) => {
      const result2 = await wrapper.clearCache(info.room);
      if (result2) {
        logger2?.debug(`Cleared cache for room ${id}`);
      }
    });
  });
  service.registerChatChain(
    "chat",
    { "zh-CN": "聊天模式", "en-US": "Chat mode" },
    async (params) => {
      return ChatHubChatChain.fromLLM(params.model, {
        variableService: ctx.chatluna.variable,
        botName: params.botName,
        preset: params.preset,
        historyMemory: params.historyMemory
      });
    }
  );
  service.registerChatChain(
    "plugin",
    {
      "zh-CN": "插件模式（基于 LangChain 的 Agent）",
      "en-US": "Plugin mode (based on LangChain Agent)"
    },
    async (params) => {
      return ChatLunaPluginChain.fromLLMAndTools(
        params.model,
        getTools(service, (_) => true),
        {
          variableService: ctx.chatluna.variable,
          preset: params.preset,
          historyMemory: params.historyMemory,
          embeddings: params.embeddings,
          agentMode: params.supportChatChain ? "tool-calling" : "react"
        }
      );
    }
  );
}
__name(defaultFactory, "defaultFactory");
function updateModels(ctx, service) {
  ctx.schema.set("model", Schema.union(getModelNames(service)));
}
__name(updateModels, "updateModels");
function updateChatChains(ctx, service) {
  ctx.schema.set("chat-mode", Schema.union(getChatChainNames(service)));
}
__name(updateChatChains, "updateChatChains");
function updateEmbeddings(ctx, service) {
  ctx.schema.set(
    "embeddings",
    Schema.union(getModelNames(service, ModelType.embeddings))
  );
}
__name(updateEmbeddings, "updateEmbeddings");
function getVectorStoreRetrieverNames(service) {
  return service.getVectorStores();
}
__name(getVectorStoreRetrieverNames, "getVectorStoreRetrieverNames");
function updateVectorStores(ctx, service) {
  const rawVectorStoreNames = getVectorStoreRetrieverNames(service);
  const vectorStoreRetrieverNames = rawVectorStoreNames.concat("无").map((name2) => Schema.const(name2));
  if (rawVectorStoreNames.length === 0) {
    ctx.schema.set("long-memory", Schema.boolean().disabled());
  } else {
    ctx.schema.set("long-memory", Schema.boolean());
  }
  ctx.schema.set("vector-store", Schema.union(vectorStoreRetrieverNames));
}
__name(updateVectorStores, "updateVectorStores");
function getTools(service, filter) {
  const tools = service.getTools().filter(filter);
  return tools.map((name2) => service.getTool(name2));
}
__name(getTools, "getTools");
function getChatChainNames(service) {
  return service.getChatChains().map((info) => Schema.const(info.name).i18n(info.description));
}
__name(getChatChainNames, "getChatChainNames");
function getModelNames(service, type = ModelType.llm) {
  const models = service.getAllModels(type).concat("无");
  return models.map((model) => Schema.const(model).description(model));
}
__name(getModelNames, "getModelNames");

// src/llm-core/memory/lore_book/index.ts
import { logger as logger3 } from "koishi-plugin-chatluna";
import { AIMessage as AIMessage3 } from "@langchain/core/messages";
function apply8(ctx, config) {
  const cache = /* @__PURE__ */ new Map();
  ctx.on(
    "chatluna/before-chat",
    async (conversationId, message, promptVariables, chatInterface, chain) => {
      const preset = await chatInterface.preset;
      if (!preset.loreBooks || preset.loreBooks.items.length === 0) {
        return;
      }
      let matcher = cache.get(preset);
      if (!matcher) {
        const loreBooks = preset.loreBooks.items;
        matcher = new LoreBookMatcher(loreBooks, {
          scanDepth: preset.loreBooks?.scanDepth,
          recursiveScan: preset.loreBooks?.recursiveScan,
          maxRecursionDepth: preset.loreBooks?.maxRecursionDepth
        });
        cache.set(preset, matcher);
      }
      const messages2 = [
        ...await chatInterface.chatHistory.getMessages()
      ];
      messages2.push(message);
      const matchedLores = matcher.matchLoreBooks(messages2);
      if (matchedLores.length > 0) {
        logger3.debug(
          `Found ${matchedLores.length} matched lore books: ${JSON.stringify(
            matchedLores.map((lore) => lore.keywords)
          )}`
        );
        promptVariables["lore_books"] = matchedLores;
      }
    }
  );
  ctx.on(
    "chatluna/clear-chat-history",
    async (conversationId, chatInterface) => {
      cache.clear();
    }
  );
}
__name(apply8, "apply");
var LoreBookMatcher = class {
  static {
    __name(this, "LoreBookMatcher");
  }
  loreBooks;
  defaultConfig;
  regexCache;
  constructor(loreBooks, defaultConfig = {}) {
    this.loreBooks = loreBooks;
    this.defaultConfig = {
      scanDepth: defaultConfig.scanDepth ?? 2,
      recursiveScan: defaultConfig.recursiveScan ?? true,
      maxRecursionDepth: defaultConfig.maxRecursionDepth ?? 3,
      matchWholeWord: defaultConfig.matchWholeWord ?? false,
      caseSensitive: defaultConfig.caseSensitive ?? true
    };
    this.regexCache = /* @__PURE__ */ new Map();
  }
  matchLoreBooks(messages2) {
    const matchedLores = /* @__PURE__ */ new Set();
    const recentMessages = messages2.slice().reverse();
    this.stackMatch(recentMessages, matchedLores);
    return Array.from(matchedLores).sort(
      (a2, b2) => (a2.order ?? 0) - (b2.order ?? 0)
    );
  }
  stackMatch(messages2, matchedLores) {
    const stack = [[messages2, 0]];
    while (stack.length > 0) {
      const [currentMessages, depth] = stack.pop();
      for (const loreBook of this.loreBooks) {
        if (loreBook.enabled === false || matchedLores.has(loreBook)) {
          continue;
        }
        const config = this.getConfig(loreBook);
        if (depth >= config.maxRecursionDepth) {
          continue;
        }
        const relevantMessages = currentMessages.slice(
          0,
          config.scanDepth
        );
        for (const message of relevantMessages) {
          const content = message.content;
          const contentParts = this.splitContent(config, content);
          for (const part of contentParts) {
            if (!this.matchKeywords(part, loreBook) && !loreBook.constant) {
              continue;
            }
            matchedLores.add(loreBook);
            if (config.recursiveScan) {
              stack.push([
                this.splitContent(config, loreBook.content).map(
                  (c) => new AIMessage3(c)
                ),
                depth + 1
              ]);
            }
            break;
          }
        }
      }
    }
  }
  matchKeywords(content, loreBook) {
    return loreBook.keywords.some((keyword) => {
      const regex = this.getRegexFromKeyword(keyword, loreBook);
      return regex.test(content);
    });
  }
  getRegexFromKeyword(keyword, loreBook) {
    if (keyword instanceof RegExp) {
      return keyword;
    }
    const cacheKey = `${keyword}:${loreBook.caseSensitive}:${loreBook.matchWholeWord}`;
    let regex = this.regexCache.get(cacheKey);
    if (!regex) {
      regex = this.createRegexFromKeyword(keyword, loreBook);
      this.regexCache.set(cacheKey, regex);
    }
    return regex;
  }
  splitContent(config, content) {
    if (config.matchWholeWord) {
      return content.split(/[。！？；；.!?;,，。！？、；：\s]+/g).filter(Boolean);
    }
    return [content];
  }
  createRegexFromKeyword(keyword, loreBook) {
    let flags = "g";
    if (!loreBook.caseSensitive) {
      flags += "i";
    }
    const pattern = loreBook.matchWholeWord ? `\\b${keyword}\\b` : keyword;
    return new RegExp(pattern, flags);
  }
  getConfig(loreBook) {
    return {
      scanDepth: loreBook.scanDepth ?? this.defaultConfig.scanDepth,
      recursiveScan: loreBook.recursiveScan ?? this.defaultConfig.recursiveScan,
      maxRecursionDepth: loreBook.maxRecursionDepth ?? this.defaultConfig.maxRecursionDepth,
      matchWholeWord: loreBook.matchWholeWord ?? this.defaultConfig.matchWholeWord,
      caseSensitive: loreBook.caseSensitive ?? this.defaultConfig.caseSensitive
    };
  }
};

// src/llm-core/memory/authors_note/index.ts
function apply9(ctx, config) {
  const cache = /* @__PURE__ */ new Map();
  ctx.on(
    "chatluna/before-chat",
    async (conversationId, message, promptVariables, chatInterface, chain) => {
      const preset = await chatInterface.preset;
      const authorsNote = preset.authorsNote;
      if (!authorsNote || authorsNote.insertFrequency === 0) {
        return;
      }
      const authorsNoteCache = cache.get(conversationId) || {
        chatCount: 1
      };
      if (authorsNote.insertFrequency > 0 && authorsNoteCache.chatCount % authorsNote.insertFrequency !== 0) {
        return;
      }
      cache.set(conversationId, authorsNoteCache);
      promptVariables["authors_note"] = authorsNote;
    }
  );
  ctx.on("chatluna/after-chat", async (conversationId, chatInterface) => {
    let authorsNoteCache = cache.get(conversationId);
    if (!authorsNoteCache) {
      authorsNoteCache = {
        chatCount: 0
      };
      cache.set(conversationId, authorsNoteCache);
    }
    authorsNoteCache.chatCount++;
  });
  ctx.on(
    "chatluna/clear-chat-history",
    async (conversationId, chatInterface) => {
      cache.delete(conversationId);
    }
  );
}
__name(apply9, "apply");

// src/chains/chain.ts
import { EventEmitter } from "events";
import { h as h2 } from "koishi";
import {
  ChatLunaError as ChatLunaError3,
  ChatLunaErrorCode as ChatLunaErrorCode3,
  setErrorFormatTemplate
} from "koishi-plugin-chatluna/utils/error";
import { createLogger } from "koishi-plugin-chatluna/utils/logger";

// src/middlewares/lifecycle.ts
function apply10(ctx, config, chain) {
  chain.middleware("lifecycle-check", async (session, context) => 0).before("lifecycle-prepare");
  chain.middleware("lifecycle-prepare", async (session, context) => 0).after("lifecycle-check").before("lifecycle-request_model");
  chain.middleware("lifecycle-handle_command", async (session, context) => 0).after("lifecycle-prepare").before("lifecycle-request_model");
  chain.middleware("lifecycle-request_model", async (session, context) => 0).after("lifecycle-prepare").before("lifecycle-send");
  chain.middleware("lifecycle-send", async (session, context) => 0).after("lifecycle-request_model");
}
__name(apply10, "apply");

// src/middlewares/add_preset.ts
import { dump } from "js-yaml";
import fs from "fs/promises";
function apply11(ctx, _, chain) {
  chain.middleware("add_preset", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "add_preset")
      return 0 /* SKIPPED */;
    const presetName = context.options.addPreset;
    const preset = ctx.chatluna.preset;
    try {
      await preset.getPreset(presetName);
      await context.send(session.text(".conflict"));
      return 1 /* STOP */;
    } catch (e) {
    }
    await context.send(session.text(".prompt"));
    const result2 = await session.prompt(1e3 * 30);
    if (!result2) {
      context.message = session.text(".timeout", [presetName]);
      return 1 /* STOP */;
    }
    const presetObject = {
      keywords: [presetName],
      prompts: [
        {
          role: "system",
          content: result2
        }
      ]
    };
    const yamlText = dump(presetObject);
    await fs.writeFile(
      preset.resolvePresetDir() + `/${presetName}.yml`,
      yamlText
    );
    context.message = session.text(".success", [presetName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply11, "apply");

// src/chains/rooms.ts
import { randomInt } from "crypto";
import { $ } from "koishi";
import { ModelType as ModelType2 } from "koishi-plugin-chatluna/llm-core/platform/types";
import { parseRawModelName } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";
import {
  ChatLunaError as ChatLunaError4,
  ChatLunaErrorCode as ChatLunaErrorCode4
} from "koishi-plugin-chatluna/utils/error";

// src/llm-core/utils/chunk.ts
var chunkArray = /* @__PURE__ */ __name((arr, chunkSize) => arr.reduce((chunks, elem, index) => {
  const chunkIndex = Math.floor(index / chunkSize);
  const chunk = chunks[chunkIndex] || [];
  chunks[chunkIndex] = chunk.concat([elem]);
  return chunks;
}, []), "chunkArray");

// src/chains/rooms.ts
async function queryJoinedConversationRoom(ctx, session, name2) {
  if (name2 != null) {
    const joinedRooms = await getAllJoinedConversationRoom(ctx, session);
    return joinedRooms.find(
      (it) => it.roomName === name2 || it.roomId === parseInt(name2)
    );
  }
  const userRoomInfoList = await ctx.database.get("chathub_user", {
    userId: session.userId,
    groupId: session.isDirect ? "0" : session.guildId
  });
  if (userRoomInfoList.length > 1) {
    throw new ChatLunaError4(
      ChatLunaErrorCode4.UNKNOWN_ERROR,
      new Error("User has multiple default rooms, this is impossible!")
    );
  } else if (userRoomInfoList.length === 0) {
    return void 0;
  }
  const userRoomInfo = userRoomInfoList[0];
  return await resolveConversationRoom(ctx, userRoomInfo.defaultRoomId);
}
__name(queryJoinedConversationRoom, "queryJoinedConversationRoom");
function queryPublicConversationRooms(ctx, session) {
  if (session.isDirect) {
    return Promise.resolve([]);
  }
  return ctx.database.get("chathub_room_group_member", {
    groupId: session.guildId,
    roomVisibility: {
      // TODO: better type
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      $in: ["template_clone", "public"]
      //    $in: ['template_clone', 'public']
    }
  });
}
__name(queryPublicConversationRooms, "queryPublicConversationRooms");
async function queryPublicConversationRoom(ctx, session) {
  const groupRoomInfoList = await queryPublicConversationRooms(ctx, session);
  const templateCloneRoom = groupRoomInfoList.find(
    (it) => it.roomVisibility === "template_clone"
  );
  let roomId;
  if (templateCloneRoom != null) {
    roomId = templateCloneRoom.roomId;
  } else if (groupRoomInfoList.length < 1) {
    return void 0;
  } else if (groupRoomInfoList.length === 1) {
    roomId = groupRoomInfoList[0].roomId;
  } else {
    const groupRoomInfo = groupRoomInfoList[randomInt(groupRoomInfoList.length)];
    roomId = groupRoomInfo.roomId;
  }
  const room = await resolveConversationRoom(ctx, roomId);
  if (room == null && roomId !== 0) {
    await deleteConversationRoomByRoomId(ctx, roomId);
    return void 0;
  }
  await joinConversationRoom(ctx, session, room);
  return room;
}
__name(queryPublicConversationRoom, "queryPublicConversationRoom");
async function checkConversationRoomAvailability(ctx, room) {
  const platformService = ctx.chatluna.platform;
  const presetService = ctx.chatluna.preset;
  const [platformName, modelName] = parseRawModelName(room.model);
  const platformModels = platformService.getModels(
    platformName,
    ModelType2.llm
  );
  if (platformModels.length < 1) {
    return false;
  }
  if (!platformModels.some((it) => it.name === modelName)) {
    return false;
  }
  if (!await presetService.getPreset(room.preset)) {
    return false;
  }
  return true;
}
__name(checkConversationRoomAvailability, "checkConversationRoomAvailability");
async function fixConversationRoomAvailability(ctx, config, room) {
  const platformService = ctx.chatluna.platform;
  const presetService = ctx.chatluna.preset;
  const [platformName, modelName] = parseRawModelName(room.model);
  const platformModels = platformService.getModels(
    platformName,
    ModelType2.llm
  );
  if (platformModels.length < 1) {
    room.model = (await getTemplateConversationRoom(ctx, config)).model;
  } else if (!platformModels.some((it) => it.name === modelName)) {
    room.model = platformName + "/" + platformModels[0].name;
  }
  if (!await presetService.getPreset(room.preset)) {
    room.preset = (await presetService.getDefaultPreset()).triggerKeyword[0];
  }
  await ctx.database.upsert("chathub_room", [room]);
}
__name(fixConversationRoomAvailability, "fixConversationRoomAvailability");
async function getTemplateConversationRoom(ctx, config) {
  const selectModelAndPreset = /* @__PURE__ */ __name(async () => {
    if (config.defaultModel === "无" || config.defaultModel == null) {
      const models = ctx.chatluna.platform.getAllModels(ModelType2.llm);
      const model = models.find((model2) => model2.includes("4o")) ?? models[0];
      config.defaultModel = model;
    } else {
      const [platformName, modelName] = parseRawModelName(
        config.defaultModel
      );
      const platformModels = ctx.chatluna.platform.getModels(
        platformName,
        ModelType2.llm
      );
      if (platformModels.length < 1) {
        const models = ctx.chatluna.platform.getAllModels(ModelType2.llm);
        const model = models.find((model2) => model2.includes("4o")) ?? models[0];
        config.defaultModel = model;
      } else if (!platformModels.some((model) => model.name === modelName)) {
        const model = platformName + "/" + platformModels.find((model2) => model2.name === modelName).name;
        config.defaultModel = model;
      }
    }
    if (config.defaultPreset == null) {
      const preset = await ctx.chatluna.preset.getDefaultPreset();
      config.defaultPreset = preset.triggerKeyword[0];
    }
    ctx.scope.parent.scope.update(config, true);
  }, "selectModelAndPreset");
  if (config.defaultChatMode == null || config.defaultModel === "无" || config.defaultPreset == null) {
    if (config.defaultChatMode == null) {
      throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_TEMPLATE_INVALID);
    }
    await selectModelAndPreset();
  }
  let room = {
    roomId: 0,
    roomName: "模板房间",
    roomMasterId: "0",
    preset: config.defaultPreset,
    conversationId: "0",
    chatMode: config.defaultChatMode,
    password: "",
    model: config.defaultModel,
    visibility: "public",
    autoUpdate: true,
    updatedTime: /* @__PURE__ */ new Date()
  };
  if (!await checkConversationRoomAvailability(ctx, room)) {
    await selectModelAndPreset();
    room = {
      roomId: 0,
      roomName: "模板房间",
      roomMasterId: "0",
      preset: config.defaultPreset,
      conversationId: "0",
      chatMode: config.defaultChatMode,
      password: "",
      model: config.defaultModel,
      visibility: "public",
      autoUpdate: true,
      updatedTime: /* @__PURE__ */ new Date()
    };
  }
  return room;
}
__name(getTemplateConversationRoom, "getTemplateConversationRoom");
async function getConversationRoomCount(ctx) {
  const count = await ctx.database.select("chathub_room").execute((row) => $.max(row.roomId));
  return count;
}
__name(getConversationRoomCount, "getConversationRoomCount");
async function transferConversationRoom(ctx, session, room, userId) {
  const memberList = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  if (memberList.length === 0) {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_FOUND);
  }
  await ctx.database.upsert("chathub_room", [
    { roomId: room.roomId, roomMasterId: userId }
  ]);
  const oldMaster = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    roomPermission: "owner"
  });
  if (oldMaster.length === 1) {
    await ctx.database.upsert("chathub_room_member", [
      {
        userId: oldMaster[0].userId,
        roomId: room.roomId,
        roomPermission: "member"
      }
    ]);
  } else {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_FOUND_MASTER);
  }
  await ctx.database.upsert("chathub_room_member", [
    { userId, roomId: room.roomId, roomPermission: "owner" }
  ]);
  await ctx.database.upsert("chathub_user", [
    {
      userId,
      defaultRoomId: room.roomId,
      groupId: session.isDirect ? "0" : session.guildId
    }
  ]);
}
__name(transferConversationRoom, "transferConversationRoom");
async function switchConversationRoom(ctx, session, id) {
  let joinedRoom = await getAllJoinedConversationRoom(ctx, session);
  const parsedId = typeof id === "number" ? id : parseInt(id);
  let room = joinedRoom.find((it) => it.roomId === parsedId);
  if (room != null) {
    await ctx.database.upsert("chathub_user", [
      {
        userId: session.userId,
        defaultRoomId: room.roomId,
        groupId: session.isDirect ? "0" : session.guildId
      }
    ]);
    return room;
  }
  joinedRoom = joinedRoom.filter((it) => it.roomName === id);
  if (joinedRoom.length > 1) {
    throw new ChatLunaError4(
      ChatLunaErrorCode4.THE_NAME_FIND_IN_MULTIPLE_ROOMS
    );
  } else if (joinedRoom.length === 0) {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_FOUND);
  } else {
    room = joinedRoom[0];
  }
  await ctx.database.upsert("chathub_user", [
    {
      userId: session.userId,
      defaultRoomId: room.roomId,
      groupId: session.isDirect ? "0" : session.guildId
    }
  ]);
  return room;
}
__name(switchConversationRoom, "switchConversationRoom");
async function getAllJoinedConversationRoom(ctx, session, queryAll = false) {
  const conversationRoomList = chunkArray(
    await ctx.database.get("chathub_room_member", {
      userId: session.userId
    }),
    35
  );
  const rooms = [];
  for (const conversationRoomChunk of conversationRoomList) {
    const roomIds = conversationRoomChunk.map((it) => it.roomId);
    const roomList = await ctx.database.get("chathub_room", {
      roomId: { $in: roomIds }
    });
    let memberList = [];
    if (queryAll === false) {
      memberList = await ctx.database.get("chathub_room_group_member", {
        roomId: { $in: roomIds },
        // 设置 undefined 来全量搜索
        groupId: session.guildId ?? void 0
      });
    }
    for (const room of roomList) {
      const memberOfTheRoom = memberList.some(
        (it) => it.roomId === room.roomId
      );
      if (
        // 模版克隆房间或者公共房间需要指定房间的范围不能干预到私聊的
        !session.isDirect && memberOfTheRoom || // 同上
        session.isDirect && room.visibility !== "template_clone" || // 私有房间跨群
        room.visibility === "private" || room.visibility === "template_clone" && session.isDirect && !memberOfTheRoom || queryAll === true
      ) {
        rooms.push(room);
      }
    }
  }
  return rooms;
}
__name(getAllJoinedConversationRoom, "getAllJoinedConversationRoom");
async function leaveConversationRoom(ctx, session, room) {
  await ctx.database.remove("chathub_room_member", {
    userId: session.userId,
    roomId: room.roomId
  });
  await ctx.database.remove("chathub_user", {
    userId: session.userId,
    defaultRoomId: room.roomId
  });
}
__name(leaveConversationRoom, "leaveConversationRoom");
async function queryConversationRoom(ctx, session, name2) {
  const roomId = typeof name2 === "number" ? name2 : parseInt(name2);
  const roomName = typeof name2 === "string" ? name2 : void 0;
  const roomList = Number.isNaN(roomId) ? await ctx.database.get("chathub_room", { roomName }) : await ctx.database.get("chathub_room", { roomId });
  if (roomList.length === 1) {
    return roomList[0];
  } else if (roomList.length > 1) {
    if (session.isDirect || Number.isNaN(roomId)) {
      throw new ChatLunaError4(
        ChatLunaErrorCode4.THE_NAME_FIND_IN_MULTIPLE_ROOMS
      );
    }
    const groupRoomList = await ctx.database.get(
      "chathub_room_group_member",
      {
        groupId: session.guildId,
        roomId: { $in: roomList.map((it) => it.roomId) }
      }
    );
    if (groupRoomList.length === 1) {
      return roomList.find((it) => it.roomId === groupRoomList[0].roomId);
    } else if (groupRoomList.length > 1) {
      throw new ChatLunaError4(
        ChatLunaErrorCode4.THE_NAME_FIND_IN_MULTIPLE_ROOMS
      );
    }
  } else if (roomList.length === 0) {
    return void 0;
  }
}
__name(queryConversationRoom, "queryConversationRoom");
async function resolveConversationRoom(ctx, roomId) {
  const roomList = await ctx.database.get("chathub_room", { roomId });
  if (roomList.length > 1) {
    throw new ChatLunaError4(
      ChatLunaErrorCode4.THE_NAME_FIND_IN_MULTIPLE_ROOMS
    );
  } else if (roomList.length === 0) {
    return void 0;
  }
  return roomList[0];
}
__name(resolveConversationRoom, "resolveConversationRoom");
async function deleteConversationRoom(ctx, room) {
  const chatBridger = ctx.chatluna.queryInterfaceWrapper(room, false);
  await chatBridger?.clearChatHistory(room);
  await deleteConversationRoomByRoomId(ctx, room.roomId);
  await ctx.database.remove("chathub_message", {
    conversation: room.conversationId
  });
  await ctx.database.remove("chathub_conversation", {
    id: room.conversationId
  });
}
__name(deleteConversationRoom, "deleteConversationRoom");
async function deleteConversationRoomByRoomId(ctx, roomId) {
  await ctx.database.remove("chathub_room", { roomId });
  await ctx.database.remove("chathub_room_member", { roomId });
  await ctx.database.remove("chathub_room_group_member", { roomId });
  await ctx.database.remove("chathub_user", { defaultRoomId: roomId });
}
__name(deleteConversationRoomByRoomId, "deleteConversationRoomByRoomId");
async function joinConversationRoom(ctx, session, roomId, isDirect = session.isDirect, userId = session.userId) {
  const room = typeof roomId === "number" ? await resolveConversationRoom(ctx, roomId) : roomId;
  await ctx.database.upsert("chathub_user", [
    {
      userId,
      defaultRoomId: room.roomId,
      groupId: session.isDirect ? "0" : session.guildId
    }
  ]);
  if (isDirect === false) {
    const groupMemberList = await ctx.database.get(
      "chathub_room_group_member",
      { groupId: session.guildId, roomId: room.roomId }
    );
    if (groupMemberList.length === 0) {
      await ctx.database.create("chathub_room_group_member", {
        groupId: session.guildId,
        roomId: room.roomId,
        roomVisibility: room.visibility
      });
    }
  }
  const memberList = await ctx.database.get("chathub_room_member", {
    userId,
    roomId: room.roomId
  });
  if (memberList.length === 0) {
    await ctx.database.create("chathub_room_member", {
      userId,
      roomId: room.roomId,
      roomPermission: userId === room.roomMasterId ? "owner" : "member"
    });
  }
}
__name(joinConversationRoom, "joinConversationRoom");
async function getConversationRoomUser(ctx, session, roomId, userId = session.userId) {
  const room = typeof roomId === "number" ? await resolveConversationRoom(ctx, roomId) : roomId;
  const memberList = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  return memberList?.[0];
}
__name(getConversationRoomUser, "getConversationRoomUser");
async function setUserPermission(ctx, session, roomId, permission, userId = session.userId) {
  const room = typeof roomId === "number" ? await resolveConversationRoom(ctx, roomId) : roomId;
  const memberList = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  if (memberList.length === 0) {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_FOUND);
  }
  await ctx.database.upsert("chathub_room_member", [
    { userId, roomId: room.roomId, roomPermission: permission }
  ]);
}
__name(setUserPermission, "setUserPermission");
async function muteUserFromConversationRoom(ctx, session, roomId, userId) {
  const room = typeof roomId === "number" ? await resolveConversationRoom(ctx, roomId) : roomId;
  const memberList = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  if (memberList.length === 0) {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_JOINED);
  }
  await ctx.database.upsert("chathub_room_member", [
    { userId, roomId: room.roomId, mute: memberList[0].mute !== true }
  ]);
}
__name(muteUserFromConversationRoom, "muteUserFromConversationRoom");
async function kickUserFromConversationRoom(ctx, session, roomId, userId) {
  const room = typeof roomId === "number" ? await resolveConversationRoom(ctx, roomId) : roomId;
  const memberList = await ctx.database.get("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  if (memberList.length === 0) {
    throw new ChatLunaError4(ChatLunaErrorCode4.ROOM_NOT_JOINED);
  }
  await ctx.database.remove("chathub_room_member", {
    roomId: room.roomId,
    userId
  });
  await ctx.database.remove("chathub_user", {
    userId,
    defaultRoomId: room.roomId
  });
}
__name(kickUserFromConversationRoom, "kickUserFromConversationRoom");
async function checkAdmin(session) {
  const tested = await session.app.permissions.test("chatluna:admin", session);
  if (tested) {
    return true;
  }
  const user = await session.getUser(session.userId, [
    "authority"
  ]);
  return user?.authority >= 3;
}
__name(checkAdmin, "checkAdmin");
async function updateChatTime(ctx, room) {
  await ctx.database.upsert("chathub_room", [
    { roomId: room.roomId, updatedTime: /* @__PURE__ */ new Date() }
  ]);
}
__name(updateChatTime, "updateChatTime");
async function createConversationRoom(ctx, session, room) {
  await ctx.database.create("chathub_room", room);
  await ctx.database.create("chathub_room_member", {
    userId: session.userId,
    roomId: room.roomId,
    roomPermission: session.userId === room.roomMasterId ? "owner" : "member"
  });
  await joinConversationRoom(ctx, session, room);
}
__name(createConversationRoom, "createConversationRoom");

// src/middlewares/add_user_to_auth_group.ts
function apply12(ctx, config, chain) {
  chain.middleware("add_user_to_auth_group", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "add_user_to_auth_group")
      return 0 /* SKIPPED */;
    const {
      authUser: userId,
      auth_group_resolve: { name: name2 }
    } = context.options;
    if (!await checkAdmin(session)) {
      context.message = session.text(".permission_denied");
      return 1 /* STOP */;
    }
    const service = ctx.chatluna_auth;
    const user = await service.getUser(session, userId);
    await service.addUserToGroup(user, name2);
    context.message = session.text(".success", [userId, name2]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply12, "apply");

// src/middlewares/allow_reply.ts
import { h as h3 } from "koishi";
function apply13(ctx, config, chain) {
  chain.middleware("allow_reply", async (session, context) => {
    if (ctx.bots[session.uid]) return 1 /* STOP */;
    context.options.reply_status = false;
    const content = h3.select(session.elements, "text").join("").trimStart();
    if (session.isDirect && config.allowPrivate && (context.command != null || config.privateChatWithoutCommand)) {
      return await checkReplyPermission();
    }
    const botId = session.bot.userId;
    if (config.allowAtReply) {
      let appel = session.stripped.atSelf;
      if (appel) {
        return await checkReplyPermission();
      }
      appel = session.elements?.some(
        (element) => element.type === "at" && element.attrs?.["id"] === botId
      ) ?? false;
      if (appel) {
        return await checkReplyPermission();
      }
    }
    if (config.allowQuoteReply && session.quote?.user?.id === botId) {
      return await checkReplyPermission();
    }
    if (config.isNickname && config.botNames.some((name2) => content.startsWith(name2)) || config.isNickNameWithContent && config.botNames.some((name2) => content.includes(name2))) {
      return await checkReplyPermission();
    }
    if (Math.random() < await session.resolve(config.randomReplyFrequency)) {
      return await checkReplyPermission();
    }
    if (context.command != null) {
      return 2 /* CONTINUE */;
    }
    if (config.allowChatWithRoomName) {
      return 2 /* CONTINUE */;
    }
    return 1 /* STOP */;
    async function checkReplyPermission() {
      const notReply = await ctx.serial(
        "chatluna/before-check-sender",
        session
      );
      const status = notReply ? 1 /* STOP */ : 2 /* CONTINUE */;
      context.options.reply_status = status === 2 /* CONTINUE */;
      return status;
    }
    __name(checkReplyPermission, "checkReplyPermission");
  }).after("lifecycle-check");
}
__name(apply13, "apply");

// src/middlewares/black_list.ts
import { createLogger as createLogger2 } from "koishi-plugin-chatluna/utils/logger";
var logger4;
function apply14(ctx, config, chain) {
  logger4 = createLogger2(ctx);
  chain.middleware("black_list", async (session, context) => {
    const resolved = await session.resolve(config.blackList);
    if (resolved === true) {
      logger4.debug(
        `[黑名单] ${session.username}(${session.userId}): ${session.content}`
      );
      context.message = session.text("chatluna.block_message");
      return 1 /* STOP */;
    }
    return 2 /* CONTINUE */;
  }).after("allow_reply");
}
__name(apply14, "apply");

// src/middlewares/censor.ts
function apply15(ctx, config, chain) {
  chain.middleware("censor", async (session, context) => {
    const message = context.options.responseMessage;
    if (!config.censor || message == null) {
      return 0 /* SKIPPED */;
    }
    message.content = await ctx.censor.transform(
      message.content,
      session
    );
  }).after("request_model");
}
__name(apply15, "apply");

// src/middlewares/chat_time_limit_check.ts
import { parseRawModelName as parseRawModelName2 } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";
import {
  ChatLunaError as ChatLunaError5,
  ChatLunaErrorCode as ChatLunaErrorCode5
} from "koishi-plugin-chatluna/utils/error";

// src/cache.ts
import { Time } from "koishi";
var Cache = class {
  constructor(ctx, config, tableName) {
    this.config = config;
    this.tableName = tableName;
    this._cache = new DatabaseCache(ctx);
  }
  static {
    __name(this, "Cache");
  }
  _cache;
  get(tableNameOrId, id) {
    if (typeof id === "string") {
      return this._cache.get(tableNameOrId, id);
    }
    return this._cache.get(this.tableName, tableNameOrId);
  }
  set(tableNameOrId, idOrValue, value) {
    if (value != null) {
      return this._cache.set(tableNameOrId, idOrValue, value);
    }
    return this._cache.set(this.tableName, tableNameOrId, idOrValue);
  }
  delete(tableNameOrId, id) {
    if (typeof id === "string") {
      return this._cache.delete(tableNameOrId, id);
    }
    return this._cache.delete(this.tableName, tableNameOrId);
  }
  async clear(tableName) {
    if (tableName) {
      await this._cache.clear(tableName);
    } else {
      await this._cache.clear(this.tableName);
    }
  }
};
var DatabaseCache = class {
  constructor(ctx) {
    this.ctx = ctx;
    ctx.model.extend(
      "cache",
      {
        table: "string(63)",
        key: "string(63)",
        value: "text",
        expire: "timestamp"
      },
      {
        primary: ["table", "key"]
      }
    );
    ctx.setInterval(async () => {
      await ctx.database.remove("cache", { expire: { $lt: /* @__PURE__ */ new Date() } });
    }, 10 * Time.minute);
  }
  static {
    __name(this, "DatabaseCache");
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  encode(data) {
    return JSON.stringify(data);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  decode(record) {
    return JSON.parse(record);
  }
  async clear(table) {
    await this.ctx.database.remove("cache", { table });
  }
  async get(table, key) {
    const [entry] = await this.ctx.database.get("cache", { table, key }, [
      "expire",
      "value"
    ]);
    if (!entry) return;
    if (entry.expire && +entry.expire < Date.now()) return;
    return this.decode(entry.value);
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async set(table, key, value, maxAge) {
    const expire = maxAge ? new Date(Date.now() + maxAge) : null;
    await this.ctx.database.upsert("cache", [
      {
        table,
        key,
        value: this.encode(value),
        expire
      }
    ]);
  }
  async delete(table, key) {
    await this.ctx.database.remove("cache", { table, key });
  }
  async *keys(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "key"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => entry.key);
  }
  async *values(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "value"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => this.decode(entry.value));
  }
  async *entries(table) {
    const entries = await this.ctx.database.get("cache", { table }, [
      "expire",
      "key",
      "value"
    ]);
    yield* entries.filter((entry) => !entry.expire || +entry.expire > Date.now()).map((entry) => [entry.key, this.decode(entry.value)]);
  }
};

// src/middlewares/chat_time_limit_check.ts
import crypto from "crypto";
function apply16(ctx, config, chain) {
  const chatLimitCache = new Cache(ctx, config, "chathub/chat_limit");
  const platformService = ctx.chatluna.platform;
  const authService = ctx.chatluna_auth;
  chain.middleware("chat_time_limit_check", async (session, context) => {
    if (config.authSystem !== true) {
      return await oldChatLimitCheck(session, context);
    }
    const {
      room: { model }
    } = context.options;
    const authUser = await authService.getUser(session);
    if (authUser && authUser.balance <= 0) {
      context.message = session.text(
        "chatluna.insufficient_balance",
        [authUser.balance]
      );
      return 1 /* STOP */;
    }
    let authGroup = await authService.resolveAuthGroup(
      session,
      parseRawModelName2(model)[0]
    );
    if (authGroup.supportModels != null && authGroup.supportModels.find((m) => m === model) == null) {
      context.message = session.text("chatluna.unsupported_model", [
        authGroup.name,
        model
      ]);
      return 1 /* STOP */;
    }
    authGroup = await authService.resetAuthGroup(authGroup.id);
    context.options.authGroup = authGroup;
    if ((authGroup.currentLimitPerMin ?? 0) + 1 > authGroup.limitPerMin) {
      context.message = session.text(
        "chatluna.limit_per_minute_exceeded",
        [
          authGroup.name,
          authGroup.limitPerMin,
          authGroup.currentLimitPerMin
        ]
      );
      return 1 /* STOP */;
    }
    if ((authGroup.currentLimitPerDay ?? 0) + 1 > authGroup.limitPerDay) {
      context.message = session.text(
        "chatluna.limit_per_day_exceeded",
        [
          authGroup.name,
          authGroup.limitPerDay,
          authGroup.currentLimitPerDay
        ]
      );
      return 1 /* STOP */;
    }
    return 2 /* CONTINUE */;
  }).after("resolve_model").before("request_model");
  async function oldChatLimitCheck(session, context) {
    const {
      room: { model, conversationId }
    } = context.options;
    const config2 = platformService.getConfigs(
      parseRawModelName2(model)[0]
    )?.[0];
    if (!config2) {
      throw new ChatLunaError5(
        ChatLunaErrorCode5.MODEL_ADAPTER_NOT_FOUND,
        new Error(`Can't find model adapter for ${model}`)
      );
    }
    const chatLimitRaw = config2.value.chatLimit;
    const chatLimitComputed = await session.resolve(chatLimitRaw);
    let key = conversationId + "-" + session.userId;
    key = crypto.createHash("md5").update(key).digest("hex");
    let chatLimitOnDataBase = await chatLimitCache.get(key);
    if (chatLimitOnDataBase) {
      if (Date.now() - chatLimitOnDataBase.time > 1e3 * 60 * 60) {
        chatLimitOnDataBase = {
          time: Date.now(),
          count: 0
        };
      } else {
        if (chatLimitOnDataBase.count >= chatLimitComputed) {
          const time = Math.ceil(
            (1e3 * 60 * 60 - (Date.now() - chatLimitOnDataBase.time)) / 1e3 / 60
          );
          context.message = session.text(
            "chatluna.chat_limit_exceeded",
            [time]
          );
          return 1 /* STOP */;
        } else {
          chatLimitOnDataBase.count++;
        }
      }
    } else {
      chatLimitOnDataBase = {
        time: Date.now(),
        count: 0
      };
    }
    await chatLimitCache.set(key, chatLimitOnDataBase);
    context.options.chatLimit = chatLimitOnDataBase;
    context.options.chatLimitCache = chatLimitCache;
    return 2 /* CONTINUE */;
  }
  __name(oldChatLimitCheck, "oldChatLimitCheck");
}
__name(apply16, "apply");

// src/middlewares/chat_time_limit_save.ts
import crypto2 from "crypto";
function apply17(ctx, config, chain) {
  const authService = ctx.chatluna_auth;
  chain.middleware("chat_time_limit_save", async (session, context) => {
    if (config.authSystem !== true) {
      return await oldChatLimitSave(session, context);
    }
    await authService.increaseAuthGroupCount(
      context.options.authGroup.id
    );
    return 2 /* CONTINUE */;
  }).after("render_message");
  async function oldChatLimitSave(session, context) {
    const {
      chatLimit,
      chatLimitCache,
      room: { conversationId }
    } = context.options;
    let key = conversationId + "-" + session.userId;
    key = crypto2.createHash("md5").update(key).digest("hex");
    chatLimit.count++;
    await chatLimitCache.set(key, chatLimit);
    return 2 /* CONTINUE */;
  }
  __name(oldChatLimitSave, "oldChatLimitSave");
}
__name(apply17, "apply");

// src/middlewares/check_room.ts
function apply18(ctx, config, chain) {
  chain.middleware("check_room", async (session, context) => {
    let room = context.options.room;
    const rooms = await getAllJoinedConversationRoom(ctx, session);
    if (room == null && rooms.length > 0) {
      room = rooms[Math.floor(Math.random() * rooms.length)];
      await switchConversationRoom(ctx, session, room.roomId);
      await context.send(
        session.text("chatluna.room.random_switch", [room.roomName])
      );
    } else if (room == null && rooms.length === 0) {
      context.message = session.text("chatluna.room.not_joined");
      return 1 /* STOP */;
    } else if (!rooms.some(
      (searchRoom) => searchRoom.roomName === room.roomName || searchRoom.roomId === room.roomId
    )) {
      context.message = session.text("chatluna.room.not_in_room", [
        room.roomName
      ]);
      return 1 /* STOP */;
    }
    const user = await getConversationRoomUser(ctx, session, room);
    if (user.mute === true) {
      context.message = session.text("chatluna.room.muted", [
        room.roomName
      ]);
      return 1 /* STOP */;
    }
    context.options.room = room;
    return 2 /* CONTINUE */;
  }).before("request_model");
}
__name(apply18, "apply");

// src/middlewares/clear_balance.ts
function apply19(ctx, config, chain) {
  chain.middleware("clear_balance", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "clear_balance")
      return 0 /* SKIPPED */;
    const { authUser: userId } = context.options;
    const service = ctx.chatluna_auth;
    const modifiedBalance = await service.setBalance(session, 0, userId);
    context.message = session.text(".success", [
      userId,
      modifiedBalance
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply19, "apply");

// src/middlewares/clear_room.ts
function apply20(ctx, config, chain) {
  chain.middleware("clear_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "clear_room")
      return 0 /* SKIPPED */;
    let targetRoom = context.options.room;
    if (targetRoom == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      targetRoom = rooms.find(
        (room) => room.roomName === context.options.room_resolve?.name || room.roomId === roomId
      );
    }
    if (targetRoom == null) {
      context.message = session.text(".no-room");
      return 1 /* STOP */;
    }
    await ctx.chatluna.clearChatHistory(targetRoom);
    context.message = session.text(".success", [targetRoom.roomName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply20, "apply");

// src/middlewares/clone_preset.ts
import fs2 from "fs/promises";
import { dump as dump2, load } from "js-yaml";
function apply21(ctx, config, chain) {
  chain.middleware("clone_preset", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "clone_preset") {
      return 0 /* SKIPPED */;
    }
    const { newName, name: name2 } = context.options.clonePreset;
    const presetService = ctx.chatluna.preset;
    const oldPreset = await presetService.getPreset(name2);
    try {
      await presetService.getPreset(newName);
      await context.send(session.text(".conflict"));
      return 1 /* STOP */;
    } catch (e) {
    }
    await context.send(session.text(".confirm", [name2]));
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (result2 !== "Y") {
      context.message = session.text(".cancelled");
      return 1 /* STOP */;
    }
    const loaded = load(oldPreset.rawText);
    loaded.keywords.push(newName);
    await fs2.writeFile(
      presetService.resolvePresetDir() + `/${newName}_clone.yml`,
      dump2(loaded)
    );
    context.message = session.text(".success", [newName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply21, "apply");

// src/middlewares/cooldown_time.ts
var lastChatTime = 0;
function apply22(ctx, config, chain) {
  chain.middleware("cooldown_time", async (session, context) => {
    const currentChatTime = Date.now();
    if (currentChatTime - lastChatTime < config.msgCooldown * 1e3) {
      const waitTime = (config.msgCooldown * 1e3 - (currentChatTime - lastChatTime)) / 1e3;
      context.message = session.text(
        "chatluna.cooldown_wait_message",
        [waitTime.toFixed(1)]
      );
      return 1 /* STOP */;
    }
    lastChatTime = currentChatTime;
    return 2 /* CONTINUE */;
  }).after("allow_reply");
}
__name(apply22, "apply");

// src/middlewares/create_auth_group.ts
import { ModelType as ModelType3 } from "koishi-plugin-chatluna/llm-core/platform/types";
function apply23(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  const authService = ctx.chatluna_auth;
  chain.middleware("create_auth_group", async (session, context) => {
    const {
      command: command2,
      options: { auth_group_resolve: authGroupResolve }
    } = context;
    if (command2 !== "create_auth_group")
      return 0 /* SKIPPED */;
    if (!authGroupResolve) return 0 /* SKIPPED */;
    let {
      name: name2,
      supportModels,
      requestPreDay,
      requestPreMin,
      platform,
      priority,
      costPerToken: constPerToken
    } = authGroupResolve;
    if (Object.values(authGroupResolve).filter((value) => value != null).length > 0 && name2 != null && requestPreDay != null && requestPreMin != null) {
      await context.send(session.text(".confirm_create"));
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      }
      if (result3 === "Y") {
        authGroupResolve.priority = priority == null ? 0 : priority;
        if (await checkAuthGroupName(authService, name2) === false) {
          context.message = session.text(".name_exists");
          return 1 /* STOP */;
        }
        if (supportModels != null && !checkModelList(service, supportModels)) {
          context.message = session.text(".invalid_models");
          return 1 /* STOP */;
        }
        await createAuthGroup(
          ctx,
          context,
          session,
          context.options
        );
        return 1 /* STOP */;
      } else if (result3 !== "N") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      }
    }
    while (true) {
      if (name2 == null) {
        await context.send(session.text(".enter_name"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.name"),
            name2
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (await checkAuthGroupName(authService, result3) === false) {
        context.message = session.text(".name_exists");
        continue;
      } else if (result3 === "N" && name2 != null) {
        break;
      } else if (result3 !== "N") {
        name2 = result3.trim();
        authGroupResolve.name = name2;
        break;
      }
    }
    while (true) {
      if (requestPreMin == null) {
        await context.send(session.text(".enter_limit_per_min"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.set"),
            session.text(".field.limit_per_min"),
            requestPreMin.toString()
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "N" && requestPreMin != null) {
        break;
      } else if (isNaN(Number(result3)) || Number(result3) <= 0) {
        await context.send(
          session.text(".invalid_input", [
            session.text(".field.limit_per_min")
          ])
        );
        continue;
      }
      requestPreMin = Number(result3);
      authGroupResolve.requestPreMin = requestPreMin;
      break;
    }
    while (true) {
      if (requestPreDay == null) {
        await context.send(session.text(".enter_limit_per_day"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.set"),
            session.text(".field.limit_per_day"),
            requestPreDay.toString()
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "N" && requestPreDay != null) {
        break;
      } else if (isNaN(Number(result3)) || Number(result3) < requestPreMin) {
        await context.send(
          session.text(".invalid_input", [
            session.text(".field.limit_per_day")
          ])
        );
        continue;
      }
      requestPreDay = Number(result3);
      authGroupResolve.requestPreDay = requestPreDay;
      break;
    }
    if (platform == null) {
      await context.send(session.text(".enter_platform"));
    } else {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".action.select"),
          session.text(".field.platform"),
          platform
        ])
      );
    }
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (result2 !== "N") {
      platform = result2;
      authGroupResolve.platform = platform;
    }
    while (true) {
      if (priority == null) {
        await context.send(session.text(".enter_priority"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.priority"),
            priority.toString()
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "N" && priority != null) {
        break;
      } else if (isNaN(Number(result3))) {
        await context.send(
          session.text(".invalid_input", [
            session.text(".field.priority")
          ])
        );
        continue;
      }
      priority = Number(result3);
      authGroupResolve.priority = priority;
      break;
    }
    while (true) {
      if (constPerToken == null) {
        await context.send(session.text(".enter_cost"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.cost"),
            constPerToken.toString()
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "N" && constPerToken != null) {
        break;
      } else if (isNaN(Number(result3))) {
        await context.send(
          session.text(".invalid_input", [
            session.text(".field.cost")
          ])
        );
        continue;
      }
      constPerToken = Number(result3);
      authGroupResolve.costPerToken = constPerToken;
      break;
    }
    while (true) {
      if (supportModels == null) {
        await context.send(session.text(".enter_models"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.models"),
            supportModels.join(",")
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      const parsedResult = result3?.split(",")?.map((item) => item.trim());
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      } else if (checkModelList(service, parsedResult)) {
        await context.send(session.text(".invalid_models"));
        continue;
      } else {
        supportModels = parsedResult;
        authGroupResolve.supportModels = parsedResult;
        break;
      }
    }
    await createAuthGroup(ctx, context, session, context.options);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply23, "apply");
async function checkAuthGroupName(service, name2) {
  const authGroup = await service.getAuthGroup(name2, false);
  return authGroup == null;
}
__name(checkAuthGroupName, "checkAuthGroupName");
function checkModelList(service, models) {
  const availableModels = service.getAllModels(ModelType3.llm);
  return models.some((model) => !availableModels.includes(model));
}
__name(checkModelList, "checkModelList");
async function createAuthGroup(ctx, context, session, options) {
  const resolve = options.auth_group_resolve;
  const group = {
    name: resolve.name,
    priority: resolve.priority ?? 0,
    limitPerMin: resolve.requestPreMin,
    limitPerDay: resolve.requestPreDay,
    costPerToken: resolve.costPerToken,
    id: null,
    supportModels: resolve.supportModels ?? null
  };
  delete group.id;
  if (resolve.supportModels == null) {
    delete resolve.supportModels;
  }
  await ctx.chatluna_auth.createAuthGroup(session, group);
  context.message = session.text(".success", [group.name]);
}
__name(createAuthGroup, "createAuthGroup");

// src/middlewares/create_room.ts
import { randomUUID } from "crypto";
import { ModelType as ModelType4 } from "koishi-plugin-chatluna/llm-core/platform/types";
function apply24(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  chain.middleware("create_room", async (session, context) => {
    const {
      command: command2,
      options: { room_resolve: roomResolve }
    } = context;
    if (command2 !== "create_room")
      return 0 /* SKIPPED */;
    if (!roomResolve) return 0 /* SKIPPED */;
    let { model, preset, name: name2, chatMode, password, visibility } = roomResolve;
    if (Object.values(roomResolve).filter((value) => value != null).length > 0 && visibility !== "template") {
      await context.send(session.text(".confirm_create"));
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      }
      if (result2 === "Y") {
        roomResolve.preset = roomResolve.preset ?? config.defaultPreset;
        roomResolve.name = roomResolve.name ?? "Unnamed Room";
        roomResolve.chatMode = roomResolve.chatMode ?? config.defaultChatMode;
        roomResolve.password = roomResolve.password ?? null;
        roomResolve.visibility = roomResolve.visibility ?? "private";
        roomResolve.model = roomResolve.model ?? config.defaultModel;
        await createRoom(ctx, context, session, context.options);
        return 1 /* STOP */;
      } else if (result2 !== "N") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      }
    }
    if (name2 == null) {
      await context.send(session.text(".enter_name"));
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result2 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      }
      name2 = result2.trim();
      roomResolve.name = name2;
    } else {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".action.input"),
          session.text(".field.name"),
          name2
        ])
      );
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result2 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result2 !== "N") {
        name2 = result2.trim();
        roomResolve.name = name2;
      }
    }
    while (true) {
      let preModel = model;
      if (preModel == null) {
        await context.send(session.text(".enter_model"));
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        }
        preModel = result2.trim();
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.select"),
            session.text(".field.model"),
            preModel
          ])
        );
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 !== "N") {
          preModel = result2.trim();
        }
      }
      const findModel = service.getAllModels(ModelType4.llm).find((searchModel) => searchModel === preModel);
      if (findModel == null) {
        await context.send(
          session.text(".model_not_found", [preModel])
        );
        preModel = null;
        roomResolve.model = null;
        continue;
      } else {
        model = preModel;
        roomResolve.model = model;
        break;
      }
    }
    const presetInstance = ctx.chatluna.preset;
    while (true) {
      let prePreset = preset;
      if (preset == null) {
        await context.send(session.text(".enter_preset"));
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 === "N") {
          prePreset = "chatgpt";
        } else {
          prePreset = result2.trim();
        }
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.select"),
            session.text(".field.preset"),
            prePreset
          ])
        );
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 !== "N") {
          prePreset = result2.trim();
        }
      }
      try {
        await presetInstance.getPreset(prePreset);
        preset = prePreset;
        roomResolve.preset = preset;
        break;
      } catch {
        await context.send(
          session.text(".preset_not_found", [prePreset])
        );
        roomResolve.preset = null;
        continue;
      }
    }
    while (true) {
      if (visibility == null) {
        await context.send(session.text(".enter_visibility"));
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 === "N") {
          roomResolve.visibility = "private";
        } else {
          roomResolve.visibility = result2.trim();
        }
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.select"),
            session.text(".field.visibility"),
            visibility
          ])
        );
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 !== "N") {
          roomResolve.visibility = result2.trim();
        }
      }
      visibility = roomResolve.visibility;
      if (visibility === "private" || visibility === "public") {
        break;
      }
      await context.send(
        session.text(".visibility_not_recognized", [visibility])
      );
    }
    while (true) {
      if (chatMode == null) {
        await context.send(session.text(".enter_chat_mode"));
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 === "N") {
          roomResolve.chatMode = "chat";
        } else {
          roomResolve.chatMode = result2.trim();
        }
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".field.chat_mode"),
            chatMode
          ])
        );
        const result2 = await session.prompt(1e3 * 30);
        if (result2 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result2 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result2 !== "N") {
          roomResolve.chatMode = result2.trim();
        }
      }
      chatMode = roomResolve.chatMode;
      const availableChatModes = ctx.chatluna.platform.getChatChains().map((chain2) => chain2.name);
      if (availableChatModes.includes(chatMode)) {
        break;
      }
      await context.send(
        session.text(".invalid_chat_mode", [
          chatMode,
          availableChatModes.join(", ")
        ])
      );
    }
    if (session.isDirect && visibility === "private" && password == null) {
      await context.send(session.text(".enter_password"));
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result2 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result2 === "N") {
        roomResolve.password = null;
      } else {
        roomResolve.password = result2.trim();
      }
    }
    await createRoom(ctx, context, session, context.options);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply24, "apply");
async function createRoom(ctx, context, session, options) {
  const { model, preset, name: name2, chatMode, password, visibility } = options.room_resolve;
  const createRoom2 = {
    conversationId: randomUUID(),
    model,
    preset,
    roomName: name2 ?? "Unnamed Room",
    roomMasterId: session.userId,
    roomId: await getConversationRoomCount(ctx) + 1,
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    visibility,
    chatMode,
    password: password ?? null,
    updatedTime: /* @__PURE__ */ new Date()
  };
  await createConversationRoom(ctx, session, createRoom2);
  if (visibility === "template") {
    context.message = session.text(".template_room_created");
  } else {
    context.message = session.text(".room_created", [
      createRoom2.roomId,
      createRoom2.roomName
    ]);
  }
}
__name(createRoom, "createRoom");

// src/middlewares/delete_preset.ts
import { createLogger as createLogger3 } from "koishi-plugin-chatluna/utils/logger";
import fs3 from "fs/promises";
var logger5;
function apply25(ctx, config, chain) {
  logger5 = createLogger3(ctx);
  chain.middleware("delete_preset", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "delete_preset")
      return 0 /* SKIPPED */;
    const presetName = context.options.deletePreset;
    const preset = ctx.chatluna.preset;
    let presetTemplate;
    try {
      presetTemplate = await preset.getPreset(presetName);
      const allPreset = await preset.getAllPreset();
      if (allPreset.length === 1) {
        await context.send(session.text(".only_one_preset"));
        return 1 /* STOP */;
      }
    } catch (e) {
      logger5.error(e);
      await context.send(session.text(".not_found"));
      return 1 /* STOP */;
    }
    await context.send(session.text(".confirm_delete", [presetName]));
    const result2 = await session.prompt(1e3 * 30);
    if (!result2) {
      context.message = session.text(".timeout", [presetName]);
      return 1 /* STOP */;
    }
    if (result2 !== "Y") {
      context.message = session.text(".cancelled", [presetName]);
      return 1 /* STOP */;
    }
    await fs3.rm(presetTemplate.path);
    const defaultPreset = await preset.getDefaultPreset();
    logger5.debug(
      `${context.options.senderInfo} ${defaultPreset.triggerKeyword[0]}`
    );
    const roomList = await ctx.database.get("chathub_room", {
      preset: presetName
    });
    for (const room of roomList) {
      room.preset = defaultPreset.triggerKeyword[0];
    }
    await ctx.database.upsert("chathub_room", roomList);
    context.message = session.text(".success", [presetName]);
    ctx.scope.parent.scope.update(config, true);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply25, "apply");

// src/middlewares/delete_room.ts
function apply26(ctx, config, chain) {
  chain.middleware("delete_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "delete_room")
      return 0 /* SKIPPED */;
    let targetRoom = context.options.room;
    if (targetRoom == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      targetRoom = rooms.find(
        (room) => room.roomName === context.options.room_resolve?.name || room.roomId === roomId
      );
    }
    if (targetRoom == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (targetRoom.roomMasterId !== session.userId && !await checkAdmin(session)) {
      context.message = session.text(".not_room_master");
      return 1 /* STOP */;
    }
    await context.send(
      session.text(".confirm_delete", [targetRoom.roomName])
    );
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (result2 !== "Y") {
      context.message = session.text(".cancelled");
      return 1 /* STOP */;
    }
    await deleteConversationRoom(ctx, targetRoom);
    context.message = session.text(".success", [targetRoom.roomName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply26, "apply");

// src/middlewares/invite_room.ts
function apply27(ctx, config, chain) {
  chain.middleware("invite_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "invite_room")
      return 0 /* SKIPPED */;
    const targetRoom = context.options.room;
    if (targetRoom == null) {
      context.message = session.text(".no_room_specified");
      return 1 /* STOP */;
    }
    const userInfo = await getConversationRoomUser(
      ctx,
      session,
      targetRoom,
      session.userId
    );
    if (userInfo.roomPermission === "member" && !await checkAdmin(session)) {
      context.message = session.text(".not_admin", [
        targetRoom.roomName
      ]);
      return 1 /* STOP */;
    }
    const targetUser = context.options.resolve_user.id;
    for (const user of targetUser) {
      await joinConversationRoom(
        ctx,
        session,
        targetRoom,
        session.isDirect,
        user
      );
    }
    context.message = session.text(".success", [
      targetUser.join(","),
      targetRoom.roomName
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply27, "apply");

// src/middlewares/join_room.ts
function apply28(ctx, config, chain) {
  chain.middleware("join_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "join_room") return 0 /* SKIPPED */;
    const targetRoom = await queryConversationRoom(
      ctx,
      session,
      context.options.room_resolve.name
    );
    if (targetRoom == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (!session.isDirect && targetRoom.visibility === "public") {
      const roomInGroup = (await ctx.database.get("chathub_room_group_member", {
        groupId: session.guildId,
        roomId: targetRoom.roomId
      })).length === 1;
      if (!roomInGroup) {
        context.message = session.text(".not_in_group");
        return 1 /* STOP */;
      }
    }
    if (await checkAdmin(session)) {
    } else if (targetRoom.visibility === "private" && targetRoom.password == null) {
      context.message = session.text(".private_no_password");
      return 1 /* STOP */;
    } else if (targetRoom.visibility === "private" && targetRoom.password != null && !session.isDirect) {
      context.message = session.text(".private_group_join");
      return 1 /* STOP */;
    }
    if (targetRoom.password) {
      await context.send(
        session.text(".enter_password", [targetRoom.roomName])
      );
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result2 !== targetRoom.password) {
        context.message = session.text(".wrong_password");
        return 1 /* STOP */;
      }
    }
    await joinConversationRoom(ctx, session, targetRoom);
    context.message = session.text(".success", [targetRoom.roomName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply28, "apply");

// src/middlewares/kick_member.ts
function apply29(ctx, config, chain) {
  chain.middleware("kick_member", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "kick_member")
      return 0 /* SKIPPED */;
    const targetRoom = context.options.room;
    if (targetRoom == null) {
      context.message = session.text(".no_room_specified");
      return 1 /* STOP */;
    }
    const userInfo = await getConversationRoomUser(
      ctx,
      session,
      targetRoom,
      session.userId
    );
    if (userInfo.roomPermission === "member" && !await checkAdmin(session)) {
      context.message = session.text(".not_admin", [
        targetRoom.roomName
      ]);
      return 1 /* STOP */;
    }
    const targetUser = context.options.resolve_user.id;
    for (const user of targetUser) {
      await kickUserFromConversationRoom(
        ctx,
        session,
        targetRoom,
        user
      );
    }
    context.message = session.text(".success", [
      targetRoom.roomName,
      targetUser.join(",")
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply29, "apply");

// src/middlewares/kick_user_form_auth_group.ts
function apply30(ctx, config, chain) {
  chain.middleware("kick_user_form_auth_group", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "kick_user_form_auth_group")
      return 0 /* SKIPPED */;
    const {
      authUser: userId,
      auth_group_resolve: { name: name2 }
    } = context.options;
    if (!await checkAdmin(session)) {
      context.message = session.text(".permission_denied");
      return 1 /* STOP */;
    }
    const service = ctx.chatluna_auth;
    const user = await service.getUser(session, userId);
    await service.removeUserFormGroup(user, name2);
    context.message = session.text(".success", [userId, name2]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply30, "apply");

// src/middlewares/leave_room.ts
function apply31(ctx, config, chain) {
  chain.middleware("leave_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "leave_room")
      return 0 /* SKIPPED */;
    let targetRoom = context.options.room;
    if (targetRoom == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      targetRoom = rooms.find(
        (room) => room.roomName === context.options.room_resolve?.name || room.roomId === roomId
      );
    }
    if (targetRoom == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (targetRoom.roomMasterId === session.userId) {
      await context.send(session.text(".confirm_delete"));
      const result2 = await session.prompt(1e3 * 30);
      if (result2 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result2 !== "Y") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      }
    }
    await leaveConversationRoom(ctx, session, targetRoom);
    if (targetRoom.roomMasterId === session.userId) {
      await deleteConversationRoom(ctx, targetRoom);
    }
    context.message = session.text(".success", [targetRoom.roomName]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply31, "apply");

// src/middlewares/list_all_embeddings.ts
import { ModelType as ModelType5 } from "koishi-plugin-chatluna/llm-core/platform/types";
import { Pagination } from "koishi-plugin-chatluna/utils/pagination";
function apply32(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  const pagination = new Pagination({
    formatItem: /* @__PURE__ */ __name((value) => value, "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_all_embeddings", async (session, context) => {
    const {
      command: command2,
      options: { page, limit }
    } = context;
    if (command2 !== "list_embeddings")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    const models = service.getAllModels(ModelType5.embeddings);
    await pagination.push(models);
    context.message = await pagination.getFormattedPage(page, limit);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply32, "apply");

// src/middlewares/list_all_model.ts
import { ModelType as ModelType6 } from "koishi-plugin-chatluna/llm-core/platform/types";
import { Pagination as Pagination2 } from "koishi-plugin-chatluna/utils/pagination";
function apply33(ctx, config, chain) {
  const services = ctx.chatluna.platform;
  const pagination = new Pagination2({
    formatItem: /* @__PURE__ */ __name((value) => value, "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_all_model", async (session, context) => {
    const {
      command: command2,
      options: { page, limit }
    } = context;
    if (command2 !== "list_model")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    const models = services.getAllModels(ModelType6.llm);
    await pagination.push(models);
    context.message = await pagination.getFormattedPage(page, limit);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply33, "apply");

// src/middlewares/list_all_preset.ts
import { Pagination as Pagination3 } from "koishi-plugin-chatluna/utils/pagination";
function apply34(ctx, config, chain) {
  const pagination = new Pagination3({
    formatItem: /* @__PURE__ */ __name((value) => value, "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_all_preset", async (session, context) => {
    const {
      command: command2,
      options: { page, limit }
    } = context;
    const preset = ctx.chatluna.preset;
    if (command2 !== "list_preset")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    pagination.updateFormatItem(
      (value) => formatPreset(ctx, session, value)
    );
    const presets = await preset.getAllPreset(false);
    await pagination.push(presets);
    context.message = await pagination.getFormattedPage(page, limit);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply34, "apply");
async function formatPreset(ctx, session, presetName) {
  const buffer = [];
  const preset = await ctx.chatluna.preset.getPreset(presetName);
  const previewContent = preset.messages.map((value) => value.content).join("\n\n").substring(0, 130).concat("......");
  buffer.push(
    session.text(".preset_keyword", [preset.triggerKeyword.join(", ")])
  );
  buffer.push(session.text(".preset_content", [previewContent]));
  return buffer.join("\n");
}
__name(formatPreset, "formatPreset");

// src/middlewares/list_all_vectorstore.ts
import { Pagination as Pagination4 } from "koishi-plugin-chatluna/utils/pagination";
function apply35(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  const pagination = new Pagination4({
    formatItem: /* @__PURE__ */ __name((value) => value, "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_all_vectorstore", async (session, context) => {
    const {
      command: command2,
      options: { page, limit }
    } = context;
    if (command2 !== "list_vector_store")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    const vectorStoreProviders = service.getVectorStores();
    await pagination.push(vectorStoreProviders);
    context.message = await pagination.getFormattedPage(page, limit);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply35, "apply");

// src/middlewares/list_auth_group.ts
import { Pagination as Pagination5 } from "koishi-plugin-chatluna/utils/pagination";
function apply36(ctx, config, chain) {
  const pagination = new Pagination5({
    formatItem: /* @__PURE__ */ __name((value) => "", "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_auth_group", async (session, context) => {
    const {
      command: command2,
      options: { page, limit, authPlatform }
    } = context;
    if (command2 !== "list_auth_group")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    pagination.updateFormatItem(
      (value) => formatAuthGroup(session, value)
    );
    const authGroups = await ctx.chatluna_auth.getAuthGroups(authPlatform);
    await pagination.push(authGroups);
    context.message = await pagination.getFormattedPage(page, limit);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply36, "apply");
function formatAuthGroup(session, group) {
  const buffer = [];
  buffer.push(session.text(".name", [group.name]));
  buffer.push(
    session.text(".platform", [group.platform ?? session.text(".general")])
  );
  buffer.push(session.text(".cost", [group.costPerToken]));
  buffer.push(session.text(".priority", [group.priority]));
  buffer.push(
    session.text(".support_models", [
      group.supportModels?.join(", ") ?? session.text(".general")
    ])
  );
  buffer.push(session.text(".limit_per_min", [group.limitPerMin]));
  buffer.push(session.text(".limit_per_day", [group.limitPerDay]));
  buffer.push("\n");
  return buffer.join("\n");
}
__name(formatAuthGroup, "formatAuthGroup");

// src/middlewares/list_room.ts
import { Pagination as Pagination6 } from "koishi-plugin-chatluna/utils/pagination";
function apply37(ctx, config, chain) {
  const pagination = new Pagination6({
    formatItem: /* @__PURE__ */ __name((value) => "", "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("list_room", async (session, context) => {
    const {
      command: command2,
      options: { page, limit, all_room }
    } = context;
    if (command2 !== "list_room") return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    pagination.updateFormatItem(
      (value) => formatRoomInfo(ctx, session, value)
    );
    const rooms = await getAllJoinedConversationRoom(ctx, session);
    if (all_room) {
      const publicRooms = await queryPublicConversationRooms(
        ctx,
        session
      );
      for (const room of publicRooms) {
        if (!rooms.find((r) => r.roomId === room.roomId)) {
          rooms.push(
            await queryConversationRoom(
              ctx,
              session,
              room.roomId
            )
          );
        }
      }
    }
    const key = session.isDirect ? session.userId : session.guildId + "-" + session.userId;
    await pagination.push(rooms, key);
    context.message = await pagination.getFormattedPage(
      page,
      limit,
      key
    );
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply37, "apply");
async function formatRoomInfo(ctx, session, room) {
  const buffer = [];
  buffer.push(session.text(".room_name", [room.roomName]));
  buffer.push(session.text(".room_id", [room.roomId]));
  buffer.push(session.text(".room_preset", [room.preset]));
  buffer.push(session.text(".room_model", [room.model]));
  buffer.push(session.text(".room_visibility", [room.visibility]));
  buffer.push(session.text(".room_chat_mode", [room.chatMode]));
  buffer.push(session.text(".room_master_id", [room.roomMasterId]));
  buffer.push(
    session.text(".room_availability", [
      await checkConversationRoomAvailability(ctx, room)
    ])
  );
  buffer.push("\n");
  return buffer.join("\n");
}
__name(formatRoomInfo, "formatRoomInfo");

// src/middlewares/message_delay.ts
import { createLogger as createLogger4 } from "koishi-plugin-chatluna/utils/logger";
import { withResolver } from "koishi-plugin-chatluna/utils/promise";
import { ObjectLock } from "koishi-plugin-chatluna/utils/lock";
var logger6;
var messages = {};
var timeouts = {};
var promises = {};
var queueLock = {};
function apply38(ctx, config, chain) {
  logger6 = createLogger4(ctx);
  chain.middleware("message_delay", async (session, context) => {
    if (config.messageDelay === 0 || context.command != null && context.command.length > 0) {
      return 2 /* CONTINUE */;
    }
    const { room, inputMessage } = context.options;
    const lock = queueLock[room.conversationId] || new ObjectLock();
    queueLock[room.conversationId] = lock;
    const unlock = await lock.lock();
    messages[room.conversationId] = messages[room.conversationId] || [];
    messages[room.conversationId].push(inputMessage);
    const timeout = timeouts[room.conversationId];
    if (timeout) {
      logger6.debug(`trigger message delay, stop the chain`);
      clearTimeout(timeout);
      resetTimeout(room.conversationId, config.messageDelay);
      unlock();
      return 1 /* STOP */;
    }
    unlock();
    const { promise, resolve } = withResolver();
    promises[room.conversationId] = resolve;
    resetTimeout(room.conversationId, config.messageDelay);
    const delayMessages = await promise;
    messages[room.conversationId] = [];
    context.options.inputMessage = mergeMessages(delayMessages);
    return 2 /* CONTINUE */;
  }).after("resolve_room");
}
__name(apply38, "apply");
async function resetTimeout(conversationId, delay) {
  timeouts[conversationId] = setTimeout(() => {
    delete timeouts[conversationId];
    delete queueLock[conversationId];
    promises[conversationId](messages[conversationId]);
  }, delay);
}
__name(resetTimeout, "resetTimeout");
function mergeMessages(messages2) {
  const newMessage = {
    content: messages2.map((message) => message.content).join("\n\n"),
    name: messages2[0].name,
    conversationId: messages2[0].conversationId,
    additional_kwargs: messages2[0].additional_kwargs
  };
  for (const message of messages2) {
    if (message.additional_kwargs) {
      newMessage.additional_kwargs = {
        ...newMessage.additional_kwargs,
        ...message.additional_kwargs
      };
    }
  }
  return newMessage;
}
__name(mergeMessages, "mergeMessages");

// src/middlewares/mute_user.ts
function apply39(ctx, config, chain) {
  chain.middleware("mute_user", async (session, context) => {
    let {
      command: command2,
      options: { room }
    } = context;
    if (command2 !== "mute_user") return 0 /* SKIPPED */;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    const userInfo = await getConversationRoomUser(
      ctx,
      session,
      room,
      session.userId
    );
    if (userInfo.roomPermission === "member" && !await checkAdmin(session)) {
      context.message = session.text(".not_admin", [room.roomName]);
      return 1 /* STOP */;
    }
    const targetUser = context.options.resolve_user.id;
    for (const user of targetUser) {
      await muteUserFromConversationRoom(ctx, session, room, user);
    }
    context.message = session.text(".success", [
      targetUser.join(","),
      room.roomName
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply39, "apply");

// src/middlewares/query_balance.ts
function apply40(ctx, config, chain) {
  chain.middleware("query_balance", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "query_balance")
      return 0 /* SKIPPED */;
    const { authUser: userId } = context.options;
    const service = ctx.chatluna_auth;
    const user = await service.getUser(session, userId);
    context.message = session.text(".success", [userId, user.balance]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply40, "apply");

// src/middlewares/read_chat_message.ts
import { h as h4 } from "koishi";
import { hashString } from "koishi-plugin-chatluna/utils/string";
function apply41(ctx, config, chain) {
  chain.middleware("read_chat_message", async (session, context) => {
    let message = context.command != null ? context.message : session.elements;
    message = message;
    if (typeof message === "string") {
      message = [h4.text(message)];
    }
    const transformedMessage = await ctx.chatluna.messageTransformer.transform(
      session,
      message
    );
    if (transformedMessage.content.length < 1) {
      return 1 /* STOP */;
    }
    context.options.inputMessage = transformedMessage;
    return 2 /* CONTINUE */;
  }).after("lifecycle-prepare").before("resolve_room");
  ctx.chatluna.messageTransformer.intercept(
    "text",
    async (session, element, message) => {
      message.content += element.attrs["content"];
    }
  );
  ctx.chatluna.messageTransformer.intercept(
    "at",
    async (session, element, message) => {
      const name2 = element.attrs["name"];
      const id = element.attrs["id"];
      if (id !== session.bot.selfId) {
        message.content += `<at ${name2 != null ? `name="${name2}"` : ""} id="${id}"/>`;
      }
    }
  );
  ctx.chatluna.messageTransformer.intercept(
    "img",
    async (session, element, message) => {
      const images = message.additional_kwargs.images ?? [];
      const imageHashs = message.additional_kwargs.imageHashs ?? [];
      const url = element.attrs.url ?? element.attrs.src;
      logger.debug(`image url: ${url}`);
      const readImage = /* @__PURE__ */ __name(async (url2) => {
        const response = await ctx.http(url2, {
          responseType: "arraybuffer",
          method: "get",
          headers: {
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"
          }
        });
        let ext = url2.match(/\.([^.]*)$/)?.[1];
        if (!["png", "jpeg"].includes(ext)) {
          ext = "jpeg";
        }
        const buffer = response.data;
        const base64 = Buffer.from(buffer).toString("base64");
        images.push(`data:image/${ext ?? "jpeg"};base64,${base64}`);
      }, "readImage");
      const imageHash = await hashString(url, 8);
      imageHashs.push(imageHash);
      element.attrs["imageHash"] = imageHash;
      if (url.startsWith("data:image") && url.includes("base64")) {
        images.push(url);
      } else {
        try {
          await readImage(url);
        } catch (error) {
          logger.warn(
            `read image ${url} error, check your chat adapter`,
            error
          );
          return;
        }
      }
      message.additional_kwargs.images = images;
      message.additional_kwargs.imageHashs = imageHashs;
      if (message.content?.length < 1) {
        message.content = "[image]";
      }
    }
  );
  ctx.inject(["sst"], (ctx2) => {
    logger.debug("sst service loaded.");
    ctx2.effect(
      () => ctx2.chatluna.messageTransformer.intercept(
        "audio",
        async (session, element, message) => {
          const content = await ctx2.sst.audio2text(session);
          logger.debug(`audio2text: ${content}`);
          message.content += content;
        }
      )
    );
  });
}
__name(apply41, "apply");

// src/middlewares/render_message.ts
function apply42(ctx, config, chain) {
  chain.middleware("render_message", async (session, context) => {
    if (context.options.responseMessage == null) {
      return 0 /* SKIPPED */;
    }
    return await renderMessage(
      ctx,
      context.options.responseMessage,
      context.options.renderOptions
    );
  }).after("lifecycle-send");
}
__name(apply42, "apply");
async function renderMessage(ctx, message, options) {
  return (await ctx.chatluna.renderer.render(message, options)).map(
    (message2) => {
      const elements = message2.element;
      if (elements instanceof Array) {
        return elements;
      } else {
        return [elements];
      }
    }
  );
}
__name(renderMessage, "renderMessage");

// src/middlewares/request_model.ts
import { sleep as sleep2 } from "koishi";
import { parseRawModelName as parseRawModelName3 } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";
import {
  ChatLunaError as ChatLunaError6,
  ChatLunaErrorCode as ChatLunaErrorCode6
} from "koishi-plugin-chatluna/utils/error";
import { createLogger as createLogger5 } from "koishi-plugin-chatluna/utils/logger";
import {
  ChainMiddlewareRunStatus as ChainMiddlewareRunStatus2
} from "koishi-plugin-chatluna/chains";
import {
  getCurrentWeekday,
  getNotEmptyString,
  getTimeDiffFormat,
  PresetPostHandler
} from "koishi-plugin-chatluna/utils/string";

// src/utils/buffer_text.ts
import { sleep } from "koishi";
import { ObjectLock as ObjectLock2 } from "koishi-plugin-chatluna/utils/lock";
var BufferText = class {
  constructor(sleepTime = 3, prefix, postfix) {
    this.sleepTime = sleepTime;
    this.prefix = prefix;
    this.postfix = postfix;
  }
  static {
    __name(this, "BufferText");
  }
  queue = [];
  currentText = "";
  lock = new ObjectLock2();
  isEnd = false;
  isTextStarted = false;
  rawText = "";
  async addText(text) {
    if (this.isEnd) {
      return;
    }
    const unlock = await this.lock.lock();
    this.queue.push(...text.split(""));
    this.currentText = text;
    unlock();
  }
  async *getText() {
    while (this.queue.length > 0 || !this.isEnd) {
      const text = await this.processChar();
      if (text == null) {
        await sleep(this.sleepTime);
        continue;
      }
      this.rawText += text;
      yield text;
    }
  }
  async processChar() {
    if (this.queue.length < 1) {
      return void 0;
    }
    const unlock = await this.lock.lock();
    const text = this.queue.shift();
    unlock();
    if (!this.isEnd) {
      await sleep(this.sleepTime);
    }
    return text;
  }
  async *get() {
    let bufferText = "";
    let inContent = this.prefix == null;
    for await (const char of this.getText()) {
      bufferText += char;
      if (!inContent) {
        if (this.prefix && bufferText.endsWith(this.prefix)) {
          inContent = true;
          bufferText = "";
        }
      } else {
        if (this.postfix && bufferText.endsWith(this.postfix)) {
          yield* bufferText.slice(0, -this.postfix.length);
          this.isEnd = true;
          break;
        } else if (this.postfix == null || bufferText.length > this.postfix.length) {
          yield bufferText[0];
          bufferText = bufferText.slice(1);
        }
      }
    }
    if (inContent && !this.isEnd) {
      yield* bufferText;
    }
  }
  async *splitByMarkdown() {
    let bufferText = "";
    for await (const char of this.get()) {
      bufferText += char;
      const lastTwoChars = bufferText.slice(-2);
      if (lastTwoChars === "\n\n") {
        yield bufferText.slice(0, -2);
        bufferText = "";
      }
    }
    if (bufferText.length > 0) {
      yield bufferText;
    }
  }
  async *splitByPunctuations() {
    const punctuations = ["，", ".", "。", "!", "！", "?", "？"];
    const sendTogglePunctuations = [".", "!", "！", "?", "？"];
    let bufferText = "";
    for await (const char of this.get()) {
      const inPunctuation = punctuations.includes(char);
      const includeSendPunctuation = sendTogglePunctuations.includes(char);
      if (includeSendPunctuation) {
        bufferText += char;
      }
      if (inPunctuation) {
        yield bufferText;
        bufferText = "";
        continue;
      }
      bufferText += char;
    }
    if (bufferText.length > 0) {
      yield bufferText;
    }
  }
  async *getCached(endText = "●") {
    let bufferText = "";
    for await (const char of this.get()) {
      bufferText += char;
      yield bufferText + endText;
    }
    yield bufferText;
  }
  end() {
    this.isEnd = true;
  }
};

// src/middlewares/request_model.ts
import { v4 as uuidv4 } from "uuid";
var logger7;
var requestIdCache = /* @__PURE__ */ new Map();
function apply43(ctx, config, chain) {
  logger7 = createLogger5(ctx);
  chain.middleware("request_model", async (session, context) => {
    const { room, inputMessage } = context.options;
    const presetTemplate = await ctx.chatluna.preset.getPreset(
      room.preset
    );
    if (presetTemplate.formatUserPromptString != null) {
      context.message = await formatUserPromptString(
        config,
        presetTemplate,
        session,
        inputMessage.content,
        room
      );
      inputMessage.content = context.message;
    }
    const bufferText = new BufferText(
      3,
      presetTemplate.config?.postHandler?.prefix,
      presetTemplate.config?.postHandler?.postfix
    );
    const postHandler = presetTemplate.config?.postHandler ? new PresetPostHandler(
      ctx,
      config,
      presetTemplate.config?.postHandler
    ) : void 0;
    let isFirstResponse = true;
    if (config.streamResponse) {
      setTimeout(async () => {
        await handleMessage(
          context,
          session,
          config,
          bufferText,
          (message) => sendMessage(context, message, config)
        );
      }, 0);
    }
    let responseMessage;
    inputMessage.conversationId = room.conversationId;
    inputMessage.name = session.author?.name ?? session.author?.id ?? session.username;
    const requestId = createRequestId(session, room);
    logger7.debug(
      `create request id: ${requestId} for ${session.userId} in ${room.roomName}-${room.conversationId}`
    );
    try {
      responseMessage = await ctx.chatluna.chat(
        session,
        room,
        inputMessage,
        {
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "llm-new-token": /* @__PURE__ */ __name(async (token) => {
            if (token === "") {
              return;
            }
            if (isFirstResponse) {
              await bufferText.addText(token);
              isFirstResponse = false;
              await context?.recallThinkingMessage();
              return;
            }
            await bufferText.addText(token);
          }, "llm-new-token"),
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "llm-queue-waiting": /* @__PURE__ */ __name(async (count) => {
            context.options.queueCount = count;
          }, "llm-queue-waiting"),
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "llm-call-tool": /* @__PURE__ */ __name(async (tool, arg, log) => {
            if (!config.showThoughtMessage) {
              return;
            }
            context.send(formatToolCall(tool, arg, log));
          }, "llm-call-tool"),
          // eslint-disable-next-line @typescript-eslint/naming-convention
          "llm-used-token-count": /* @__PURE__ */ __name(async (tokens) => {
            if (config.authSystem !== true) {
              return;
            }
            const balance = await ctx.chatluna_auth.calculateBalance(
              session,
              parseRawModelName3(room.model)[0],
              tokens
            );
            logger7.debug(`current balance: ${balance}`);
          }, "llm-used-token-count")
        },
        config.streamResponse,
        getSystemPromptVariables(session, config, room),
        postHandler,
        requestId
      );
    } catch (e) {
      if (e?.message?.includes("output values have 1 keys")) {
        throw new ChatLunaError6(
          ChatLunaErrorCode6.MODEL_RESPONSE_IS_EMPTY
        );
      } else {
        throw e;
      }
    } finally {
      bufferText.end();
    }
    if (!config.streamResponse) {
      context.options.responseMessage = responseMessage;
    } else {
      context.options.responseMessage = null;
      context.message = null;
    }
    await updateChatTime(ctx, room);
    return ChainMiddlewareRunStatus2.CONTINUE;
  }).after("lifecycle-request_model");
}
__name(apply43, "apply");
async function handleMessage(context, session, config, bufferText, sendMessageFunc) {
  const isEditMessage = session.bot.editMessage != null;
  if (isEditMessage) {
    try {
      await handleEditMessage(
        context,
        session,
        config,
        bufferText,
        sendMessageFunc
      );
      return;
    } catch (error) {
      logger7.error("Error handling edit message:", error);
    }
  }
  const getText = (() => {
    if (config.splitMessage) {
      return bufferText.splitByPunctuations.bind(bufferText);
    }
    return bufferText.splitByMarkdown.bind(bufferText);
  })();
  for await (const text of getText()) {
    try {
      await sendMessageFunc(text);
    } catch (error) {
      logger7.error("Error sending message:", error);
    }
  }
}
__name(handleMessage, "handleMessage");
async function handleEditMessage(context, session, config, bufferText, sendMessage2) {
  const { ctx } = context;
  let messageId = null;
  const queue = [];
  let isFinished = false;
  const editMessage = /* @__PURE__ */ __name(async (text) => {
    try {
      await session.bot.editMessage(
        session.channelId,
        messageId,
        text
        // await markdownRenderMessage(text)
      );
    } catch (error) {
      logger7.error("Error editing message:", error);
    }
  }, "editMessage");
  const processQueue = /* @__PURE__ */ __name(async () => {
    while (!isFinished) {
      const firstQueue = queue.shift();
      if (firstQueue == null) {
        await sleep2(2);
        continue;
      }
      await editMessage(firstQueue);
    }
    if (queue.length > 0) {
      await editMessage(queue.shift());
    }
  }, "processQueue");
  setTimeout(async () => {
    await processQueue();
  }, 0);
  for await (let text of bufferText.getCached()) {
    if (config.censor) {
      text = await ctx.censor.transform(text, session);
    }
    if (messageId == null) {
      try {
        messageId = await session.bot.sendMessage(session.channelId, text).then((messageIds) => messageIds[0]);
      } catch (error) {
        logger7.error("Error sending message:", error);
      }
      continue;
    }
    queue.unshift(text);
  }
  isFinished = true;
}
__name(handleEditMessage, "handleEditMessage");
function getSystemPromptVariables(session, config, room) {
  return {
    name: config.botNames[0],
    date: (/* @__PURE__ */ new Date()).toLocaleString(),
    bot_id: session.bot.selfId,
    is_group: (!session.isDirect || session.guildId != null).toString(),
    is_private: session.isDirect?.toString(),
    user_id: session.author?.user?.id ?? session.event?.user?.id ?? "0",
    user: getNotEmptyString(
      session.author?.nick,
      session.author?.name,
      session.event.user?.name,
      session.username
    ),
    noop: "",
    time: (/* @__PURE__ */ new Date()).toLocaleTimeString(),
    weekday: getCurrentWeekday(),
    idle_duration: getTimeDiffFormat(
      (/* @__PURE__ */ new Date()).getTime(),
      room.updatedTime.getTime()
    )
  };
}
__name(getSystemPromptVariables, "getSystemPromptVariables");
function getRequestId(session, room) {
  const userKey = session.userId + "-" + (session.guildId ?? "") + "-" + room.conversationId;
  return requestIdCache.get(userKey);
}
__name(getRequestId, "getRequestId");
function createRequestId(session, room) {
  const requestId = uuidv4();
  const userKey = session.userId + "-" + (session.guildId ?? "") + "-" + room.conversationId;
  requestIdCache.set(userKey, requestId);
  return requestId;
}
__name(createRequestId, "createRequestId");
function formatToolCall(tool, arg, log) {
  let rawArg = arg;
  if (Object.keys(rawArg).length === 1) {
    rawArg = rawArg?.input ?? rawArg?.arguments ?? rawArg;
  }
  if (typeof rawArg !== "string") {
    rawArg = JSON.stringify(rawArg, null, 2) || "";
  }
  return `{
  tool: '${tool}',
  arg: '${rawArg}',
  log: '${log}'
}`;
}
__name(formatToolCall, "formatToolCall");
async function formatUserPromptString(config, presetTemplate, session, prompt, room) {
  return await session.app.chatluna.variable.formatPresetTemplateString(
    presetTemplate.formatUserPromptString,
    {
      sender_id: session.author?.user?.id ?? session.event?.user?.id ?? "0",
      sender: getNotEmptyString(
        session.author?.nick,
        session.author?.name,
        session.event.user?.name,
        session.username
      ),
      prompt,
      ...getSystemPromptVariables(session, config, room)
    }
  );
}
__name(formatUserPromptString, "formatUserPromptString");
async function sendMessage(context, text, config) {
  if (text == null || text.trim() === "") {
    return;
  }
  const renderedMessage = await renderMessage(
    context.ctx,
    {
      content: text
    },
    context.options.renderOptions
  );
  if (config.censor) {
    for (const key in renderedMessage) {
      renderedMessage[key] = await context.ctx.censor.transform(
        renderedMessage[key],
        context.session
      );
    }
  }
  await context.send(renderedMessage);
}
__name(sendMessage, "sendMessage");

// src/middlewares/resolve_model.ts
function apply44(ctx, config, chain) {
  chain.middleware("resolve_model", async (session, context) => {
    const { room } = context.options;
    const isAvailable = await checkConversationRoomAvailability(
      ctx,
      room
    );
    if (isAvailable) {
      return 2 /* CONTINUE */;
    }
    await context.send(session.text("chatluna.room.unavailable"));
    await fixConversationRoomAvailability(ctx, config, room);
    return 2 /* CONTINUE */;
  }).before("request_model");
}
__name(apply44, "apply");

// src/middlewares/resolve_room.ts
import { h as h5 } from "koishi";
import { v4 as uuidv42 } from "uuid";
import { createLogger as createLogger6 } from "koishi-plugin-chatluna/utils/logger";
var logger8;
function apply45(ctx, config, chain) {
  logger8 = createLogger6(ctx);
  chain.middleware("resolve_room", async (session, context) => {
    let joinRoom = await queryJoinedConversationRoom(
      ctx,
      session,
      context.options?.room_resolve?.name
    );
    if (config.allowChatWithRoomName) {
      const needContinue = context.command == null;
      const rawMessageContent = context.message;
      const messageContent = typeof rawMessageContent === "string" ? rawMessageContent : h5.select(rawMessageContent, "text").join("").trimStart();
      const splitContent = messageContent.split(" ");
      let matchedRoom;
      if (splitContent.length > 1) {
        matchedRoom = await queryJoinedConversationRoom(
          ctx,
          session,
          splitContent.shift()
        );
      }
      if (matchedRoom == null || !needContinue) {
        return 1 /* STOP */;
      }
      if (matchedRoom != null) {
        joinRoom = matchedRoom;
        context.options.inputMessage = await ctx.chatluna.messageTransformer.transform(
          session,
          [h5.text(splitContent.concat(" "))]
        );
      }
    }
    if (joinRoom == null) {
      const joinedRooms = await getAllJoinedConversationRoom(
        ctx,
        session
      );
      if (joinedRooms.length > 0) {
        joinRoom = // 优先加入自己创建的房间
        joinedRooms.find(
          (room) => room.visibility === "private" && room.roomMasterId === session.userId
        ) ?? // 优先加入自己创建的房间
        joinedRooms.find(
          (room) => room.visibility === "template_clone" && room.roomMasterId === session.userId
        );
        if (config.autoCreateRoomFromUser !== true && joinRoom == null) {
          joinRoom = // 优先加入模版克隆房间
          joinedRooms.find(
            (room) => room.visibility === "template_clone"
          ) ?? joinedRooms[Math.floor(Math.random() * joinedRooms.length)];
        }
        if (joinRoom != null) {
          await switchConversationRoom(
            ctx,
            session,
            joinRoom.roomId
          );
          logger8.success(
            session.text("chatluna.room.auto_switch", [
              session.userId,
              joinRoom.roomName
            ])
          );
        }
      }
    }
    if (joinRoom == null && config.autoCreateRoomFromUser !== true && !session.isDirect && (context.command?.length ?? 0) < 1) {
      joinRoom = await queryPublicConversationRoom(ctx, session);
      if (joinRoom != null) {
        logger8.success(
          session.text("chatluna.room.auto_switch", [
            session.userId,
            joinRoom.roomName
          ])
        );
      }
    }
    if (joinRoom == null && (context.command?.length ?? 0) < 1) {
      const templateRoom = await getTemplateConversationRoom(
        ctx,
        config
      );
      if (templateRoom == null) {
        return 0 /* SKIPPED */;
      }
      const cloneRoom = structuredClone(templateRoom);
      cloneRoom.conversationId = uuidv42();
      if (config.autoCreateRoomFromUser) {
        cloneRoom.roomMasterId = session.userId;
        cloneRoom.visibility = "private";
        cloneRoom.roomId = await getConversationRoomCount(ctx) + 1;
        cloneRoom.roomName = session.text(
          "chatluna.room.room_name",
          [
            session.isDirect ? `${session.username ?? session.userId}` : `${session.event.guild.name ?? session.username ?? session.event.guild.id.toString()}`
          ]
        );
        logger8.success(
          session.text("chatluna.room.auto_create", [
            session.userId,
            cloneRoom.roomName
          ])
        );
      } else {
        cloneRoom.roomMasterId = session.userId;
        cloneRoom.visibility = "template_clone";
        cloneRoom.roomId = await getConversationRoomCount(ctx) + 1;
        cloneRoom.roomName = session.text(
          "chatluna.room.template_clone_room_name",
          [
            session.isDirect ? `${session.username ?? session.userId}` : `${session.event.guild.name ?? session.username ?? session.event.guild.id.toString()}`
          ]
        );
        logger8.success(
          session.text("chatluna.room.auto_create_template", [
            session.userId,
            cloneRoom.roomName
          ])
        );
      }
      cloneRoom.autoUpdate = config.autoUpdateRoomMode !== "disable" || cloneRoom.visibility === "template_clone";
      await createConversationRoom(ctx, session, cloneRoom);
      joinRoom = cloneRoom;
    }
    if (joinRoom != null && joinRoom.autoUpdate !== true && config.autoUpdateRoomMode === "all") {
      joinRoom.autoUpdate = true;
    }
    if (joinRoom?.autoUpdate === true) {
      let needUpdate = false;
      if (joinRoom.preset !== config.defaultPreset || joinRoom.chatMode !== config.defaultChatMode || joinRoom.model !== config.defaultModel) {
        needUpdate = true;
      }
      joinRoom.model = config.defaultModel;
      joinRoom.preset = config.defaultPreset;
      joinRoom.chatMode = config.defaultChatMode;
      if (joinRoom.preset !== config.defaultPreset) {
        logger8.debug(
          `The room ${joinRoom.roomName} preset changed to ${joinRoom.preset}. Clearing chat history.`
        );
        await ctx.chatluna.clearChatHistory(joinRoom);
      }
      if (needUpdate) {
        await ctx.chatluna.clearCache(joinRoom);
        await ctx.database.upsert("chathub_room", [joinRoom]);
        logger8.debug(
          session.text("chatluna.room.config_changed", [
            joinRoom.roomName
          ])
        );
      }
    }
    context.options.room = joinRoom;
    return 2 /* CONTINUE */;
  }).after("lifecycle-prepare");
}
__name(apply45, "apply");

// src/middlewares/restart.ts
function apply46(ctx, config, chain) {
  chain.middleware("restart", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "restart") return 0 /* SKIPPED */;
    ctx.scope.parent.scope.update(config, true);
    context.message = session.text(".success");
    return 1 /* STOP */;
  }).before("black_list");
}
__name(apply46, "apply");

// src/middlewares/rollback_chat.ts
import { h as h6 } from "koishi";
function apply47(ctx, config, chain) {
  chain.middleware("rollback_chat", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "rollback") return 0 /* SKIPPED */;
    let room = context.options.room;
    const rollbackRound = context.options.rollback_round ?? 1;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    await ctx.chatluna.clearCache(room);
    const conversation = (await ctx.database.get("chathub_conversation", {
      id: room.conversationId
    }))?.[0];
    if (conversation === null) {
      context.message = session.text(".conversation_not_exist");
      return 1 /* STOP */;
    }
    let parentId = conversation.latestId;
    const messages2 = [];
    while (messages2.length < rollbackRound * 2) {
      const message = await ctx.database.get("chathub_message", {
        conversation: room.conversationId,
        id: parentId
      });
      parentId = message[0]?.parent;
      messages2.unshift(...message);
      if (parentId == null) {
        break;
      }
    }
    if (messages2.length < rollbackRound * 2) {
      context.message = session.text(".no_chat_history");
      return 1 /* STOP */;
    }
    const lastMessage = parentId == null ? void 0 : await ctx.database.get("chathub_message", {
      conversation: room.conversationId,
      id: parentId
    }).then((message) => message?.[0]);
    const humanMessage = messages2[messages2.length - 2];
    await ctx.database.upsert("chathub_conversation", [
      {
        id: room.conversationId,
        latestId: parentId == null ? null : lastMessage.id
      }
    ]);
    if ((context.options.message?.length ?? 0) < 1) {
      context.options.inputMessage = await ctx.chatluna.messageTransformer.transform(session, [
        h6.text(humanMessage.text)
      ]);
    }
    await ctx.database.remove("chathub_message", {
      id: messages2.map((message) => message.id)
    });
    await session.send(
      session.text(".rollback_success", [rollbackRound])
    );
    logger.debug(
      `rollback chat ${room.roomName} ${context.options.inputMessage}`
    );
    return 2 /* CONTINUE */;
  }).after("lifecycle-handle_command");
}
__name(apply47, "apply");

// src/middlewares/room_info.ts
function apply48(ctx, config, chain) {
  chain.middleware("room_info", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "room_info") return 0 /* SKIPPED */;
    let room = context.options.room;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    const buffer = [session.text(".header") + "\n"];
    buffer.push(session.text(".room_name", [room.roomName]));
    buffer.push(session.text(".room_id", [room.roomId]));
    buffer.push(session.text(".room_preset", [room.preset]));
    buffer.push(session.text(".room_model", [room.model]));
    buffer.push(session.text(".room_visibility", [room.visibility]));
    buffer.push(session.text(".room_chat_mode", [room.chatMode]));
    buffer.push(session.text(".room_master_id", [room.roomMasterId]));
    context.message = buffer.join("\n");
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply48, "apply");

// src/middlewares/room_permission.ts
function apply49(ctx, config, chain) {
  chain.middleware("room_permission", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "room_permission")
      return 0 /* SKIPPED */;
    let targetRoom = context.options.room;
    if (targetRoom == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      targetRoom = rooms.find(
        (room) => room.roomName === context.options.room_resolve?.name || room.roomId === roomId
      );
    }
    if (targetRoom == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (targetRoom.roomMasterId !== session.userId && !await checkAdmin(session)) {
      context.message = session.text(".not_admin");
      return 1 /* STOP */;
    }
    const user = context.options.resolve_user.id;
    await context.send(
      session.text(".confirm_set", [user, targetRoom.roomName])
    );
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (["admin", "member", "a", "m"].every(
      (text) => result2.toLowerCase() !== text
    )) {
      context.message = session.text(".invalid_permission");
      return 1 /* STOP */;
    }
    const currentPermission = result2.startsWith("a") ? "admin" : "member";
    await setUserPermission(
      ctx,
      session,
      targetRoom,
      currentPermission,
      user
    );
    context.message = session.text(".success", [
      user,
      targetRoom.roomName,
      currentPermission
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply49, "apply");

// src/middlewares/search_model.ts
import { ModelType as ModelType7 } from "koishi-plugin-chatluna/llm-core/platform/types";
import { Pagination as Pagination7 } from "koishi-plugin-chatluna/utils/pagination";
function apply50(ctx, config, chain) {
  const services = ctx.chatluna.platform;
  const pagination = new Pagination7({
    formatItem: /* @__PURE__ */ __name((value) => value, "formatItem"),
    formatString: {
      top: "",
      bottom: "",
      pages: ""
    }
  });
  chain.middleware("search_model", async (session, context) => {
    const {
      command: command2,
      options: { page, limit, query }
    } = context;
    if (command2 !== "search_model")
      return 0 /* SKIPPED */;
    pagination.updateFormatString({
      top: session.text(".header") + "\n",
      bottom: "\n" + session.text(".footer"),
      pages: "\n" + session.text(".pages")
    });
    const models = services.getAllModels(ModelType7.llm);
    await pagination.push(models);
    context.message = await pagination.searchPage(
      (value) => value.includes(query),
      page,
      limit
    );
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply50, "apply");

// src/middlewares/set_auth_group.ts
import { ModelType as ModelType8 } from "koishi-plugin-chatluna/llm-core/platform/types";
function apply51(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  const authService = ctx.chatluna_auth;
  chain.middleware("set_auth_group", async (session, context) => {
    const {
      command: command2,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      options: { auth_group_resolve }
    } = context;
    if (command2 !== "set_auth_group")
      return 0 /* SKIPPED */;
    if (!auth_group_resolve) return 0 /* SKIPPED */;
    let {
      name: name2,
      supportModels,
      requestPreDay,
      requestPreMin,
      platform,
      priority,
      costPerToken: constPerToken
    } = auth_group_resolve;
    let currentAuthGroupName = "guest";
    while (true) {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".action.select"),
          session.text(".field.name"),
          currentAuthGroupName
        ])
      );
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (await ctx.chatluna_auth.getAuthGroup(
        currentAuthGroupName,
        false
      ) == null) {
        await context.send(session.text(".invalid_name"));
        continue;
      } else {
        currentAuthGroupName = result3.trim();
        break;
      }
    }
    if (Object.values(auth_group_resolve).filter(
      (value) => value != null
    ).length > 0 && name2 != null && requestPreDay != null && requestPreMin != null) {
      await context.send(session.text(".confirm_set"));
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      }
      if (result3 === "Y") {
        auth_group_resolve.priority = priority == null ? 0 : priority;
        if (await checkAuthGroupName2(authService, name2) === false) {
          context.message = session.text(".name_exists");
          return 1 /* STOP */;
        }
        if (supportModels != null && !checkModelList2(service, supportModels)) {
          context.message = session.text(".invalid_models");
          return 1 /* STOP */;
        }
        await setAuthGroup(
          ctx,
          session,
          context,
          currentAuthGroupName,
          context.options
        );
        return 1 /* STOP */;
      } else if (result3 !== "N") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      }
    }
    while (true) {
      if (name2 == null) {
        await context.send(session.text(".enter_name"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.name"),
            name2
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (await checkAuthGroupName2(authService, result3) === false) {
        await context.send(session.text(".name_exists"));
        continue;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (result3 === "N" && name2 != null) {
        break;
      } else if (result3 !== "N") {
        name2 = result3.trim();
        auth_group_resolve.name = name2;
        break;
      }
    }
    while (true) {
      if (requestPreMin == null) {
        await context.send(session.text(".enter_requestPreMin"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.requestPreMin"),
            requestPreMin
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "N" && requestPreMin != null) {
        break;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (isNaN(Number(result3)) && Number(result3) !== 0) {
        await context.send(session.text(".invalid_requestPreMin"));
        continue;
      }
      requestPreMin = Number(result3);
      auth_group_resolve.requestPreMin = requestPreMin;
      break;
    }
    while (true) {
      if (requestPreDay == null) {
        await context.send(session.text(".enter_requestPreDay"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.requestPreDay"),
            requestPreDay
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "N" && requestPreDay != null) {
        break;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (isNaN(Number(result3)) || Number(result3) < requestPreMin) {
        await context.send(session.text(".invalid_requestPreDay"));
        continue;
      }
      requestPreDay = Number(result3);
      auth_group_resolve.requestPreDay = requestPreDay;
      break;
    }
    if (platform == null) {
      await context.send(session.text(".enter_platform"));
    } else {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".action.input"),
          session.text(".field.platform"),
          platform
        ])
      );
    }
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout_cancel");
      return 1 /* STOP */;
    } else if (result2 !== "N") {
      platform = result2;
      auth_group_resolve.platform = platform;
    }
    while (true) {
      if (priority == null) {
        await context.send(session.text(".enter_priority"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.priority"),
            priority
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (result3 === "N" && priority != null) {
        break;
      } else if (isNaN(Number(result3))) {
        await context.send(session.text(".invalid_priority"));
        continue;
      }
      priority = Number(result3);
      auth_group_resolve.priority = priority;
      break;
    }
    while (true) {
      if (constPerToken == null) {
        await context.send(session.text(".enter_costPerToken"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.costPerToken"),
            constPerToken
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "N" && constPerToken != null) {
        break;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (isNaN(Number(result3))) {
        await context.send(session.text(".invalid_costPerToken"));
        continue;
      }
      constPerToken = Number(result3);
      auth_group_resolve.costPerToken = constPerToken;
      break;
    }
    while (true) {
      if (supportModels == null) {
        await context.send(session.text(".enter_models"));
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".action.input"),
            session.text(".field.models"),
            supportModels.join(", ")
          ])
        );
      }
      const result3 = await session.prompt(1e3 * 30);
      const parsedResult = result3?.split(",")?.map((item) => item.trim());
      if (result3 == null) {
        context.message = session.text(".timeout_cancel");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      } else if (result3 === "Q") {
        context.message = session.text(".cancel_set");
        return 1 /* STOP */;
      } else if (checkModelList2(service, parsedResult)) {
        await context.send(session.text(".invalid_models"));
        continue;
      } else {
        supportModels = parsedResult;
        auth_group_resolve.supportModels = parsedResult;
        break;
      }
    }
    await setAuthGroup(
      ctx,
      session,
      context,
      currentAuthGroupName,
      context.options
    );
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply51, "apply");
async function checkAuthGroupName2(service, name2) {
  const authGroup = await service.getAuthGroup(name2);
  return authGroup == null;
}
__name(checkAuthGroupName2, "checkAuthGroupName");
function checkModelList2(service, models) {
  const availableModels = service.getAllModels(ModelType8.llm);
  return models.some((model) => !availableModels.includes(model));
}
__name(checkModelList2, "checkModelList");
async function setAuthGroup(ctx, session, context, oldAuthGroupName, options) {
  const resolve = options.auth_group_resolve;
  const group = {
    name: resolve.name,
    priority: resolve.priority ?? 0,
    limitPerMin: resolve.requestPreMin,
    limitPerDay: resolve.requestPreDay,
    // 1000 token / 0.3
    costPerToken: resolve.costPerToken,
    id: null,
    supportModels: resolve.supportModels ?? null
  };
  delete group.id;
  if (resolve.supportModels == null) {
    delete resolve.supportModels;
  }
  for (const key in group) {
    if (group[key] == null) {
      delete group[key];
    }
  }
  await ctx.chatluna_auth.setAuthGroup(oldAuthGroupName, group);
  context.message = session.text(".success", [group.name]);
}
__name(setAuthGroup, "setAuthGroup");

// src/middlewares/set_auto_update_room.ts
function apply52(ctx, config, chain) {
  chain.middleware("set_auto_update_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "set_auto_update_room")
      return 0 /* SKIPPED */;
    let { room: targetRoom, auto_update_room: autoUpdateRoom } = context.options;
    if (targetRoom == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      targetRoom = rooms.find(
        (room) => room.roomName === context.options.room_resolve?.name || room.roomId === roomId
      );
    }
    if (targetRoom == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (targetRoom.roomMasterId !== session.userId && !await checkAdmin(session)) {
      context.message = session.text(".not_admin");
      return 1 /* STOP */;
    }
    targetRoom.autoUpdate = context.options.auto_update_room;
    await ctx.database.upsert("chathub_room", [targetRoom]);
    context.message = session.text(".success", [
      targetRoom.roomName,
      autoUpdateRoom
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply52, "apply");

// src/middlewares/set_balance.ts
function apply53(ctx, config, chain) {
  chain.middleware("set_balance", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "set_balance")
      return 0 /* SKIPPED */;
    const { authUser: userId, balance } = context.options;
    const service = ctx.chatluna_auth;
    const modifiedBalance = await service.setBalance(
      session,
      balance,
      userId
    );
    context.message = session.text(".success", [
      userId,
      modifiedBalance
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply53, "apply");

// src/middlewares/set_default_embeddings.ts
import { ModelType as ModelType9 } from "koishi-plugin-chatluna/llm-core/platform/types";
import { parseRawModelName as parseRawModelName4 } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";
function apply54(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  chain.middleware("set_default_embeddings", async (session, context) => {
    const { command: command2, options } = context;
    if (command2 !== "set_embeddings")
      return 0 /* SKIPPED */;
    const { setEmbeddings } = options;
    if (!setEmbeddings) {
      context.message = session.text(".usage_hint");
      return 1 /* STOP */;
    }
    const embeddings = service.getAllModels(ModelType9.embeddings);
    const [, modelName] = parseRawModelName4(setEmbeddings);
    const targetEmbeddings = embeddings.filter((embeddingsName) => {
      return embeddingsName.includes(modelName);
    });
    if (targetEmbeddings.length > 1) {
      const buffer = [];
      buffer.push(session.text(".multiple_models_found.header"));
      for (const embedding of targetEmbeddings) {
        buffer.push(embedding);
      }
      buffer.push(session.text(".multiple_models_found.footer"));
      buffer.push(
        session.text(".multiple_models_found.example", [
          targetEmbeddings[0]
        ])
      );
      context.message = buffer.join("\n");
    } else if (targetEmbeddings.length === 0) {
      context.message = session.text(".model_not_found");
    }
    const fullName = targetEmbeddings[0];
    await context.send(session.text(".success", [fullName]));
    config.defaultEmbeddings = fullName;
    ctx.scope.parent.scope.update(config, true);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply54, "apply");

// src/middlewares/set_default_vectorstore.ts
function apply55(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  chain.middleware("set_default_vectorstore", async (session, context) => {
    const { command: command2, options } = context;
    if (command2 !== "set_vector_store")
      return 0 /* SKIPPED */;
    const { setVectorStore } = options;
    if (!setVectorStore) {
      context.message = session.text(".usage_hint");
      return 1 /* STOP */;
    }
    const targetVectorStoreProviders = service.getVectorStores().filter(
      (vectorStoreProviderName) => vectorStoreProviderName.includes(setVectorStore)
    );
    if (targetVectorStoreProviders.length > 1) {
      const buffer = [];
      buffer.push(session.text(".multiple_stores_found.header"));
      for (const vectorStoreProvider of targetVectorStoreProviders) {
        buffer.push(vectorStoreProvider);
      }
      buffer.push(session.text(".multiple_stores_found.footer"));
      buffer.push(
        session.text(".multiple_stores_found.example", [
          targetVectorStoreProviders[0]
        ])
      );
      context.message = buffer.join("\n");
      return 1 /* STOP */;
    } else if (targetVectorStoreProviders.length === 0) {
      context.message = session.text(".store_not_found");
      return 1 /* STOP */;
    }
    const targetProviderName = targetVectorStoreProviders[0];
    const keysCache = ctx.chatluna.cache;
    await keysCache.set("default-vector-store", targetProviderName);
    await context.send(session.text(".success", [targetProviderName]));
    config.defaultVectorStore = targetProviderName;
    ctx.scope.parent.scope.update(config, true);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply55, "apply");

// src/middlewares/set_preset.ts
import fs4 from "fs/promises";
import { dump as dump3, load as load2 } from "js-yaml";
function apply56(ctx, config, chain) {
  chain.middleware("set_preset", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "set_preset") {
      return 0 /* SKIPPED */;
    }
    const presetName = context.options.setPreset;
    const presetService = ctx.chatluna.preset;
    const preset = await presetService.getPreset(presetName);
    if (!preset) {
      await context.send(session.text(".not_found"));
      return 1 /* STOP */;
    }
    if (preset.messages.length > 1) {
      await context.send(session.text(".not_support", [presetName]));
      return 1 /* STOP */;
    }
    await context.send(session.text(".enter_content"));
    const result2 = await session.prompt(1e3 * 30);
    if (!result2) {
      await context.send(session.text(".timeout"));
      return 1 /* STOP */;
    }
    const presetObject = load2(preset.rawText);
    presetObject.prompts[0].content = result2;
    await fs4.writeFile(preset.path, dump3(presetObject));
    await context.send(session.text(".success", [presetName]));
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply56, "apply");

// src/middlewares/set_room.ts
import { ModelType as ModelType10 } from "koishi-plugin-chatluna/llm-core/platform/types";
function apply57(ctx, config, chain) {
  const service = ctx.chatluna.platform;
  chain.middleware("set_room", async (session, context) => {
    let {
      command: command2,
      // eslint-disable-next-line @typescript-eslint/naming-convention
      options: { room_resolve, room }
    } = context;
    if (command2 !== "set_room") return 0 /* SKIPPED */;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (room.roomMasterId !== session.userId && !await checkAdmin(session)) {
      context.message = session.text(".not_room_master");
      return 1 /* STOP */;
    }
    const oldPreset = room.preset;
    if (Object.values(room_resolve).filter((value) => value != null).length > 0 && room_resolve.visibility !== "template") {
      await context.send(session.text(".confirm_update"));
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      }
      if (result3 === "Y") {
        if ((!session.isDirect || room.visibility !== "private") && room_resolve.password != null) {
          context.message = session.text(".no_password_in_public");
          return 1 /* STOP */;
        }
        room.preset = room_resolve.preset ?? room.preset;
        room.roomName = room_resolve.name ?? room.roomName;
        room.chatMode = room_resolve.chatMode ?? room.chatMode;
        room.password = room_resolve.password ?? room.password;
        room.visibility = room_resolve.visibility ?? room.visibility;
        room.model = room_resolve.model ?? room.model;
        if (!await checkRoomAvailability(
          context,
          session,
          ctx,
          room
        )) {
          context.message = session.text(".failed", [
            room.roomName
          ]);
          return 1 /* STOP */;
        }
        await ctx.database.upsert("chathub_room", [room]);
        if (room.preset !== oldPreset) {
          await ctx.chatluna.clearChatHistory(room);
          context.message = session.text(".success_with_clear", [
            room.roomName
          ]);
        } else {
          await ctx.chatluna.clearCache(room);
          context.message = session.text(".success", [
            room.roomName
          ]);
        }
        return 1 /* STOP */;
      } else if (result3 !== "N") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      }
    }
    let {
      model,
      preset,
      roomName: name2,
      chatMode,
      password,
      visibility
    } = room;
    await context.send(
      session.text(".change_or_keep", [
        session.text(".field.name"),
        name2
      ])
    );
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (result2 === "Q") {
      context.message = session.text(".cancelled");
      return 1 /* STOP */;
    } else if (result2 !== "N") {
      name2 = result2.trim();
      room.roomName = name2;
    }
    while (true) {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".field.model"),
          model
        ])
      );
      const result3 = (await session.prompt(1e3 * 30))?.trim();
      if (!result3) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      }
      const findModel = service.getAllModels(ModelType10.llm).find((searchModel) => searchModel === result3);
      if (findModel == null) {
        await context.send(
          session.text(".model_not_found", [result3])
        );
        continue;
      }
      model = result3;
      room.model = model;
      break;
    }
    const presetInstance = ctx.chatluna.preset;
    while (true) {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".field.preset"),
          preset
        ])
      );
      const result3 = (await session.prompt(1e3 * 30))?.trim();
      if (!result3) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      }
      try {
        await presetInstance.getPreset(result3);
        room.preset = preset = result3;
        break;
      } catch (e) {
        await context.send(
          session.text(".preset_not_found", [result3])
        );
        continue;
      }
    }
    while (true) {
      await context.send(
        session.text(".change_or_keep", [
          session.text(".field.visibility"),
          visibility
        ])
      );
      const result3 = (await session.prompt(1e3 * 30))?.trim();
      if (!result3) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        break;
      }
      if (result3 === "private" || result3 === "public") {
        visibility = room.visibility = result3;
        break;
      }
      await context.send(
        session.text(".invalid_visibility", [result3])
      );
    }
    while (true) {
      if (chatMode == null) {
        await context.send(session.text(".enter_chat_mode"));
        const result3 = await session.prompt(1e3 * 30);
        if (result3 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result3 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result3 === "N") {
          room.chatMode = "chat";
        } else {
          room.chatMode = result3.trim();
        }
      } else {
        await context.send(
          session.text(".change_or_keep", [
            session.text(".field.chat_mode"),
            chatMode
          ])
        );
        const result3 = await session.prompt(1e3 * 30);
        if (result3 == null) {
          context.message = session.text(".timeout");
          return 1 /* STOP */;
        } else if (result3 === "Q") {
          context.message = session.text(".cancelled");
          return 1 /* STOP */;
        } else if (result3 !== "N") {
          room.chatMode = result3.trim();
        }
      }
      chatMode = room.chatMode;
      const availableChatModes = ctx.chatluna.platform.getChatChains().map((chain2) => chain2.name);
      if (availableChatModes.includes(chatMode)) {
        break;
      }
      await context.send(
        session.text(".invalid_chat_mode", [
          visibility,
          availableChatModes.join(", ")
        ])
      );
    }
    if (session.isDirect && visibility === "private" && password == null) {
      await context.send(session.text(".enter_password"));
      const result3 = await session.prompt(1e3 * 30);
      if (result3 == null) {
        context.message = session.text(".timeout");
        return 1 /* STOP */;
      } else if (result3 === "Q") {
        context.message = session.text(".cancelled");
        return 1 /* STOP */;
      } else if (result3 === "N") {
        room.password = null;
      } else {
        room.password = result3.trim();
      }
    }
    await ctx.database.upsert("chathub_room", [room]);
    if (room.preset !== oldPreset) {
      await ctx.chatluna.clearChatHistory(room);
      context.message = session.text(".success_with_clear", [
        room.roomName
      ]);
    } else {
      await ctx.chatluna.clearCache(room);
      context.message = session.text(".success", [room.roomName]);
    }
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply57, "apply");
async function checkRoomAvailability(context, session, ctx, room) {
  const availableChatModes = ctx.chatluna.platform.getChatChains().map((chain) => chain.name);
  if (!availableChatModes.includes(room.chatMode)) {
    await context.send(
      session.text(".invalid_chat_mode", [
        room.chatMode,
        availableChatModes.join(", ")
      ])
    );
    return false;
  }
  const findModel = ctx.chatluna.platform.getAllModels(ModelType10.llm).find((searchModel) => searchModel === room.model);
  if (findModel == null) {
    await context.send(session.text(".model_not_found", [room.model]));
    return false;
  }
  try {
    await ctx.chatluna.preset.getPreset(room.preset);
  } catch (e) {
    await context.send(session.text(".preset_not_found", [room.preset]));
    return false;
  }
  const visibility = room.visibility;
  if (visibility === "private" || visibility === "public") {
    return true;
  }
  await context.send(session.text(".invalid_visibility", [visibility]));
}
__name(checkRoomAvailability, "checkRoomAvailability");

// src/middlewares/stop_chat.ts
function apply58(ctx, config, chain) {
  chain.middleware("stop_chat", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "stop_chat") return 0 /* SKIPPED */;
    let room = context.options.room;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    const requestId = getRequestId(session, room);
    if (requestId == null) {
      context.message = session.text(".no_active_chat");
      return 1 /* STOP */;
    }
    const status = await ctx.chatluna.stopChat(room, requestId);
    if (status === null) {
      context.message = session.text(".no_active_chat");
    } else if (!status) {
      context.message = session.text(".stop_failed");
    }
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply58, "apply");

// src/middlewares/switch_room.ts
function apply59(ctx, config, chain) {
  chain.middleware("switch_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "switch_room")
      return 0 /* SKIPPED */;
    const targetConversationRoom = await switchConversationRoom(
      ctx,
      session,
      context.options.room_resolve?.name
    );
    if (!targetConversationRoom) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    context.message = session.text(".success", [
      targetConversationRoom.roomName
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply59, "apply");

// src/middlewares/thinking_message_recall.ts
function apply60(ctx, config, chain) {
  chain.middleware("thinking_message_recall", async (session, context) => {
    if (!config.sendThinkingMessage) {
      return 0 /* SKIPPED */;
    }
    await context.recallThinkingMessage?.();
    return 2 /* CONTINUE */;
  }).after("render_message");
}
__name(apply60, "apply");

// src/middlewares/thinking_message_send.ts
import { createLogger as createLogger7 } from "koishi-plugin-chatluna/utils/logger";
var logger9;
function apply61(ctx, config, chain) {
  logger9 = createLogger7(ctx);
  chain.middleware("thinking_message_send", async (session, context) => {
    if (!config.sendThinkingMessage || context.command?.length > 0) {
      return 0 /* SKIPPED */;
    }
    const thinkingTimeoutObject = {};
    context.options.thinkingTimeoutObject = thinkingTimeoutObject;
    thinkingTimeoutObject.timeout = setTimeout(async () => {
      const queueCount = await getQueueCount(
        thinkingTimeoutObject,
        context.options
      );
      if (thinkingTimeoutObject.timeout == null || queueCount < 1) {
        return;
      }
      const messageIds = await session.send(
        session.text("chatluna.thinking_message", [
          (queueCount ?? "0").toString()
        ])
      );
      thinkingTimeoutObject.recallFunc = async () => {
        try {
          await session.bot.deleteMessage(
            session.channelId,
            messageIds[0]
          );
        } catch (e) {
          logger9.error(e);
        }
        thinkingTimeoutObject.autoRecallTimeout = void 0;
        thinkingTimeoutObject.timeout = void 0;
      };
      thinkingTimeoutObject.autoRecallTimeout = setTimeout(
        () => {
          thinkingTimeoutObject.recallFunc?.();
          thinkingTimeoutObject.autoRecallTimeout = void 0;
        },
        1e3 * 60 * 2 - 1e3 * 3
      );
    }, config.sendThinkingMessageTimeout);
    return 2 /* CONTINUE */;
  }).before("lifecycle-prepare");
}
__name(apply61, "apply");
async function getQueueCount(obj, options) {
  await new Promise((resolve, reject) => {
    const timer = setInterval(() => {
      if (obj.timeout != null && options.queueCount != null) {
        clearInterval(timer);
        resolve(void 0);
      }
    });
  });
  return options.queueCount;
}
__name(getQueueCount, "getQueueCount");

// src/middlewares/transfer_room.ts
function apply62(ctx, config, chain) {
  chain.middleware("transfer_room", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "transfer_room")
      return 0 /* SKIPPED */;
    let room = context.options.room;
    if (room == null && context.options.room_resolve != null) {
      const rooms = await getAllJoinedConversationRoom(
        ctx,
        session,
        true
      );
      const roomId = parseInt(context.options.room_resolve?.name);
      room = rooms.find(
        (room2) => room2.roomName === context.options.room_resolve?.name || room2.roomId === roomId
      );
    }
    if (room == null) {
      context.message = session.text(".room_not_found");
      return 1 /* STOP */;
    }
    if (room.roomMasterId !== session.userId && !await checkAdmin(session)) {
      context.message = session.text(".not_room_master");
      return 1 /* STOP */;
    }
    const targetUser = context.options.resolve_user.id;
    await context.send(
      session.text(".confirm_transfer", [room.roomName, targetUser])
    );
    const result2 = await session.prompt(1e3 * 30);
    if (result2 == null) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    } else if (result2 !== "Y") {
      context.message = session.text(".cancelled");
      return 1 /* STOP */;
    }
    await transferConversationRoom(ctx, session, room, targetUser);
    context.message = session.text(".success", [
      room.roomName,
      targetUser
    ]);
    return 1 /* STOP */;
  }).after("lifecycle-handle_command");
}
__name(apply62, "apply");

// src/middlewares/wipe.ts
import { createLogger as createLogger8 } from "koishi-plugin-chatluna/utils/logger";
import fs5 from "fs/promises";
var logger10;
function apply63(ctx, config, chain) {
  logger10 = createLogger8(ctx);
  chain.middleware("wipe", async (session, context) => {
    const { command: command2 } = context;
    if (command2 !== "wipe") return 0 /* SKIPPED */;
    const expression = generateExpression();
    await context.send(
      session.text(".confirm_wipe", [expression.expression])
    );
    const result2 = await session.prompt(1e3 * 30);
    if (!result2) {
      context.message = session.text(".timeout");
      return 1 /* STOP */;
    }
    if (result2 !== expression.result.toString()) {
      context.message = session.text(".incorrect_input");
      return 1 /* STOP */;
    }
    await ctx.database.drop("chathub_room_member");
    await ctx.database.drop("chathub_conversation");
    await ctx.database.drop("chathub_message");
    await ctx.database.drop("chathub_room");
    await ctx.database.drop("chathub_room_group_member");
    await ctx.database.drop("chathub_user");
    await ctx.database.drop("chathub_auth_group");
    await ctx.database.drop("chathub_auth_joined_user");
    await ctx.database.drop("chathub_auth_user");
    try {
      await ctx.database.drop("chathub_knowledge");
    } catch (e) {
      logger10.warn(`wipe: ${e}`);
    }
    await ctx.chatluna.cache.clear("chathub/chat_limit");
    await ctx.chatluna.cache.clear("chathub/keys");
    await ctx.chatluna.cache.clear("chathub/client_config");
    try {
      await fs5.rm("data/chathub/vector_store", { recursive: true });
    } catch (e) {
      logger10.warn(`wipe: ${e}`);
    }
    try {
      await fs5.rm("data/chathub/temp", { recursive: true });
    } catch (e) {
      logger10.warn(`wipe: ${e}`);
    }
    context.message = session.text(".success");
    ctx.scope.parent.scope.update(config, true);
    return 1 /* STOP */;
  }).before("black_list");
}
__name(apply63, "apply");
function generateExpression() {
  const operators = ["+", "-", "*"];
  const operator = operators[Math.floor(Math.random() * operators.length)];
  const a = Math.floor(Math.random() * 1e3);
  const b = Math.floor(Math.random() * 1e3);
  const result = eval(`${a}${operator}${b}`);
  return {
    expression: `${a}${operator}${b}`,
    result
  };
}
__name(generateExpression, "generateExpression");

// src/middleware.ts
async function middleware(ctx, config) {
  const middlewares = (
    // middleware start
    [
      apply11,
      apply12,
      apply13,
      apply14,
      apply15,
      apply16,
      apply17,
      apply18,
      apply19,
      apply20,
      apply21,
      apply22,
      apply23,
      apply24,
      apply25,
      apply26,
      apply27,
      apply28,
      apply29,
      apply30,
      apply31,
      apply10,
      apply32,
      apply33,
      apply34,
      apply35,
      apply36,
      apply37,
      apply38,
      apply39,
      apply40,
      apply41,
      apply42,
      apply43,
      apply44,
      apply45,
      apply46,
      apply47,
      apply48,
      apply49,
      apply50,
      apply51,
      apply52,
      apply53,
      apply54,
      apply55,
      apply56,
      apply57,
      apply58,
      apply59,
      apply60,
      apply61,
      apply62,
      apply63
    ]
  );
  for (const middleware2 of middlewares) {
    await middleware2(ctx, config, ctx.chatluna.chatChain);
  }
}
__name(middleware, "middleware");

// src/index.ts
import { deleteConversationRoom as deleteConversationRoom2 } from "koishi-plugin-chatluna/chains";

// src/config.ts
import { Schema as Schema2, Time as Time2 } from "koishi";
var Config2 = Schema2.intersect([
  Schema2.object({
    botNames: Schema2.array(Schema2.string()).default(["香草"]),
    isNickname: Schema2.boolean().default(true),
    isNickNameWithContent: Schema2.boolean().default(false)
  }),
  Schema2.object({
    allowPrivate: Schema2.boolean().default(true),
    allowAtReply: Schema2.boolean().default(true),
    allowQuoteReply: Schema2.boolean().default(false),
    isReplyWithAt: Schema2.boolean().default(false),
    isForwardMsg: Schema2.boolean().default(false),
    privateChatWithoutCommand: Schema2.boolean().default(true),
    allowChatWithRoomName: Schema2.boolean().default(false),
    includeQuoteReply: Schema2.boolean().default(true),
    randomReplyFrequency: Schema2.percent().min(0).max(1).step(0.01).default(0).computed()
  }),
  Schema2.object({
    sendThinkingMessage: Schema2.boolean().default(true),
    sendThinkingMessageTimeout: Schema2.number().default(15e3),
    msgCooldown: Schema2.number().min(0).max(3600).step(1).default(0),
    messageDelay: Schema2.number().min(0).max(60 * Time2.second).step(1).default(0),
    showThoughtMessage: Schema2.boolean().default(false)
  }),
  Schema2.object({
    outputMode: Schema2.dynamic("output-mode").default("text"),
    splitMessage: Schema2.boolean().default(false),
    censor: Schema2.boolean().default(false),
    rawOnCensor: Schema2.boolean().default(false),
    streamResponse: Schema2.boolean().default(false)
  }),
  Schema2.object({
    blackList: Schema2.boolean().computed().default(false)
  }),
  Schema2.object({
    messageCount: Schema2.number().role("slider").min(2).max(500).step(1).default(40),
    autoDelete: Schema2.boolean().default(false),
    autoDeleteTimeout: Schema2.number().default(Time2.day * 10 / Time2.second).min(Time2.hour / Time2.second)
  }),
  Schema2.object({
    defaultEmbeddings: Schema2.dynamic("embeddings").default("无"),
    defaultVectorStore: Schema2.dynamic("vector-store").default("无")
  }),
  Schema2.object({
    autoCreateRoomFromUser: Schema2.boolean().default(false),
    defaultChatMode: Schema2.dynamic("chat-mode").default("chat"),
    defaultModel: Schema2.dynamic("model").default("无"),
    defaultPreset: Schema2.dynamic("preset").default("chatgpt"),
    autoUpdateRoomMode: Schema2.union([
      Schema2.const("all"),
      Schema2.const("manual"),
      Schema2.const("disable")
    ]).default("manual")
  }),
  Schema2.object({
    authSystem: Schema2.boolean().experimental().hidden().default(false),
    isProxy: Schema2.boolean().default(false),
    voiceSpeakId: Schema2.number().default(0),
    isLog: Schema2.boolean().default(false)
  }),
  Schema2.union([
    Schema2.object({
      isProxy: Schema2.const(true).required(),
      proxyAddress: Schema2.string().default("")
    }),
    Schema2.object({})
  ]),
  Schema2.union([
    Schema2.object({
      authSystem: Schema2.const(true).required(),
      authUserDefaultGroup: Schema2.tuple([
        Schema2.number().default(0),
        Schema2.number().default(1),
        Schema2.string().default("guest")
      ]).computed().default([0, 1, "guest"])
    }),
    Schema2.object({})
  ])
]).i18n({
  "zh-CN": require_zh_CN_schema(),
  "en-US": require_en_US_schema()
});

// src/render.ts
import { h as h13, Schema as Schema9 } from "koishi";
import {
  ChatLunaError as ChatLunaError7,
  ChatLunaErrorCode as ChatLunaErrorCode7
} from "koishi-plugin-chatluna/utils/error";

// src/renders/default.ts
var Renderer = class {
  constructor(ctx) {
    this.ctx = ctx;
  }
  static {
    __name(this, "Renderer");
  }
};

// src/renders/text.ts
import { transform } from "koishi-plugin-markdown";
import { h as h7, Schema as Schema3 } from "koishi";
import he from "he";
var TextRenderer = class extends Renderer {
  static {
    __name(this, "TextRenderer");
  }
  async render(message, options) {
    let transformed = transformAndEscape(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return h7("message", element);
      });
    }
    if (transformed[0]?.type === "p") {
      const pElement = transformed.shift();
      const pElementContent = pElement.attrs["content"];
      if (pElementContent) {
        transformed.unshift(h7.text(pElementContent));
      } else {
        transformed.unshift(...pElement.children);
      }
    }
    return {
      element: transformed
    };
  }
  schema = Schema3.const("text").i18n({
    "zh-CN": "将回复作为 markdown 进行渲染",
    "en-US": "Render as markdown"
  });
};
function unescape(element) {
  if (element.type === "text") {
    element.attrs["content"] = he.decode(element.attrs["content"]);
  }
  if (element.children && element.children.length > 0) {
    element.children = element.children.map(unescape);
  }
  return element;
}
__name(unescape, "unescape");
function transformAndEscape(source) {
  const transformed = transform(source).map(unescape);
  return transformed;
}
__name(transformAndEscape, "transformAndEscape");

// src/renders/voice.ts
import { marked } from "marked";
import { logger as logger11 } from "koishi-plugin-chatluna";
import { h as h8, Schema as Schema4 } from "koishi";
var VoiceRenderer = class extends Renderer {
  static {
    __name(this, "VoiceRenderer");
  }
  async render(message, options) {
    const splitMessages = this._splitMessage(message.content).flatMap((text) => text.trim().split("\n\n")).filter((text) => text.length > 0);
    logger11?.debug(`splitMessages: ${JSON.stringify(splitMessages)}`);
    if (options.split) {
      return {
        element: await Promise.all(
          splitMessages.map(async (text) => {
            return h8(
              "message",
              await this._renderToVoice(text, options)
            );
          })
        )
      };
    } else {
      return {
        element: await this._renderToVoice(
          splitMessages.join(""),
          options
        )
      };
    }
  }
  _splitMessage(message) {
    const tokens = renderTokens(marked.lexer(message));
    if (tokens.length === 0 || tokens[0].length === 0) {
      return [message];
    }
    return tokens;
  }
  _renderToVoice(text, options) {
    return this.ctx.vits.say(
      Object.assign(
        {
          speaker_id: options?.voice?.speakerId ?? 0,
          input: text
        },
        {
          session: options.session
        }
      )
    );
  }
  schema = Schema4.const("voice").i18n({
    "zh-CN": "将回复渲染为语音",
    "en-US": "Render as voice"
  });
};
function renderToken(token) {
  if (token.type === "text" || //     token.type === "space" ||
  token.type === "heading" || token.type === "em" || token.type === "strong" || token.type === "del" || token.type === "codespan" || token.type === "list_item" || token.type === "blockquote" || token.type === "code") {
    return token.text;
  }
  return token.raw;
}
__name(renderToken, "renderToken");
function renderTokens(tokens) {
  return tokens.map(renderToken);
}
__name(renderTokens, "renderTokens");

// src/renders/raw.ts
import { h as h9, Schema as Schema5 } from "koishi";
var RawRenderer = class extends Renderer {
  static {
    __name(this, "RawRenderer");
  }
  async render(message, options) {
    return {
      element: h9.text(message.content)
    };
  }
  schema = Schema5.const("raw").i18n({
    "zh-CN": "原始输出",
    "en-US": "Raw text"
  });
};

// src/renders/koishi-element.ts
import { h as h10, Schema as Schema6 } from "koishi";
import he2 from "he";
import { logger as logger12 } from "koishi-plugin-chatluna";
var KoishiElementRenderer = class extends Renderer {
  static {
    __name(this, "KoishiElementRenderer");
  }
  async render(message, options) {
    let transformed = transformAndEscape2(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return h10("message", element);
      });
    }
    return {
      element: transformed
    };
  }
  schema = Schema6.const("koishi-element").i18n({
    "zh-CN": "将回复作为 koishi 消息元素进行渲染",
    "en-US": "Render as koishi message element template"
  });
};
function unescape2(element) {
  if (element.type === "text") {
    element.attrs["content"] = he2.decode(element.attrs["content"]);
  }
  if (element.children && element.children.length > 0) {
    element.children = element.children.map(unescape2);
  }
  return element;
}
__name(unescape2, "unescape");
function transformAndEscape2(source) {
  try {
    return h10.parse(source).map(unescape2);
  } catch (e) {
    logger12.error(e);
    return [h10.text(source)];
  }
}
__name(transformAndEscape2, "transformAndEscape");

// src/renders/mixed-voice.ts
import { marked as marked2 } from "marked";
import { logger as logger13 } from "koishi-plugin-chatluna";
import { h as h11, Schema as Schema7 } from "koishi";
var MixedVoiceRenderer = class extends Renderer {
  static {
    __name(this, "MixedVoiceRenderer");
  }
  async render(message, options) {
    const elements = [];
    const renderText = (await this.renderText(message, options)).element;
    if (renderText instanceof Array) {
      elements.push(...renderText);
    } else {
      elements.push(renderText);
    }
    const renderVoice = (await this.renderVoice(message, options)).element;
    if (renderVoice instanceof Array) {
      elements.push(...renderVoice);
    } else {
      elements.push(renderVoice);
    }
    return {
      element: elements
    };
  }
  async renderText(message, options) {
    let transformed = transformAndEscape(message.content);
    if (options.split) {
      transformed = transformed.map((element) => {
        return h11("message", element);
      });
    }
    return {
      element: transformed
    };
  }
  async renderVoice(message, options) {
    const splitMessages = this._splitMessage(message.content).flatMap((text) => text.trim().split("\n\n")).filter((text) => text.length > 0);
    logger13?.debug(`splitMessages: ${JSON.stringify(splitMessages)}`);
    return {
      element: await this._renderToVoice(splitMessages.join(""), options)
    };
  }
  _splitMessage(message) {
    const tokens = renderTokens2(marked2.lexer(message));
    if (tokens.length === 0 || tokens[0].length === 0) {
      return [message];
    }
    return tokens;
  }
  _renderToVoice(text, options) {
    return this.ctx.vits.say(
      Object.assign(
        {
          speaker_id: options?.voice?.speakerId ?? 0,
          input: text
        },
        {
          session: options.session
        }
      )
    );
  }
  schema = Schema7.const("mixed-voice").i18n({
    "zh-CN": "同时输出语音和文本",
    "en-US": "Output both voice and text"
  });
};
function renderToken2(token) {
  if (token.type === "text" || //     token.type === "space" ||
  token.type === "heading" || token.type === "em" || token.type === "strong" || token.type === "del" || token.type === "codespan" || token.type === "list_item" || token.type === "blockquote") {
    return token.text;
  }
  return token.raw;
}
__name(renderToken2, "renderToken");
function renderTokens2(tokens) {
  return tokens.map(renderToken2);
}
__name(renderTokens2, "renderTokens");

// src/renders/pure-text.ts
import { transform as transform2 } from "koishi-plugin-markdown";
import { h as h12, Schema as Schema8 } from "koishi";

// src/utils/remove-markdown.ts
function removeMarkdown(md, options = {}) {
  options.listUnicodeChar = Object.prototype.hasOwnProperty.call(
    options,
    "listUnicodeChar"
  ) ? options.listUnicodeChar : false;
  options.stripListLeaders = Object.prototype.hasOwnProperty.call(
    options,
    "stripListLeaders"
  ) ? options.stripListLeaders : true;
  options.gfm = Object.prototype.hasOwnProperty.call(options, "gfm") ? options.gfm : true;
  options.useImgAltText = Object.prototype.hasOwnProperty.call(
    options,
    "useImgAltText"
  ) ? options.useImgAltText : true;
  options.abbr = Object.prototype.hasOwnProperty.call(options, "abbr") ? options.abbr : false;
  options.replaceLinksWithURL = Object.prototype.hasOwnProperty.call(
    options,
    "replaceLinksWithURL"
  ) ? options.replaceLinksWithURL : false;
  options.htmlTagsToSkip = Object.prototype.hasOwnProperty.call(
    options,
    "htmlTagsToSkip"
  ) ? options.htmlTagsToSkip : [];
  options.throwError = Object.prototype.hasOwnProperty.call(
    options,
    "throwError"
  ) ? options.throwError : false;
  let output = md || "";
  output = output.replace(
    /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/gm,
    ""
  );
  try {
    if (options.stripListLeaders) {
      if (options.listUnicodeChar)
        output = output.replace(
          /^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm,
          options.listUnicodeChar + " $1"
        );
      else
        output = output.replace(/^([\s\t]*)([\*\-\+]|\d+\.)\s+/gm, "$1");
    }
    if (options.gfm) {
      output = output.replace(/\n={2,}/g, "\n").replace(/~{3}.*\n/g, "").replace(/~~/g, "").replace(/```(?:.*)\n([\s\S]*?)```/g, (_, code) => code.trim());
    }
    if (options.abbr) {
      output = output.replace(/\*\[.*\]:.*\n/, "");
    }
    let htmlReplaceRegex = /<[^>]*>/g;
    if (options.htmlTagsToSkip && options.htmlTagsToSkip.length > 0) {
      const joinedHtmlTagsToSkip = options.htmlTagsToSkip.join("|");
      htmlReplaceRegex = new RegExp(
        `<(?!/?(${joinedHtmlTagsToSkip})(?=>|s[^>]*>))[^>]*>`,
        "g"
      );
    }
    output = output.replace(htmlReplaceRegex, "").replace(/^[=\-]{2,}\s*$/g, "").replace(/\[\^.+?\](\: .*?$)?/g, "").replace(/\s{0,2}\[.*?\]: .*?$/g, "").replace(
      /\!\[(.*?)\][\[\(].*?[\]\)]/g,
      options.useImgAltText ? "$1" : ""
    ).replace(
      /\[([\s\S]*?)\]\s*[\(\[].*?[\)\]]/g,
      options.replaceLinksWithURL ? "$2" : "$1"
    ).replace(/^(\n)?\s{0,3}>\s?/gm, "$1").replace(/^\s{1,2}\[(.*?)\]: (\S+)( ".*?")?\s*$/g, "").replace(
      /^(\n)?\s{0,}#{1,6}\s*( (.+))? +#+$|^(\n)?\s{0,}#{1,6}\s*( (.+))?$/gm,
      "$1$3$4$6"
    ).replace(/([\*]+)(\S)(.*?\S)??\1/g, "$2$3").replace(/(^|\W)([_]+)(\S)(.*?\S)??\2($|\W)/g, "$1$3$4$5").replace(/(`{3,})(.*?)\1/gm, "$2").replace(/`(.+?)`/g, "$1").replace(/~(.*?)~/g, "$1");
  } catch (e) {
    if (options.throwError) throw e;
    console.error("remove-markdown encountered error: %s", e);
    return md;
  }
  return output;
}
__name(removeMarkdown, "removeMarkdown");

// src/renders/pure-text.ts
import he3 from "he";
var PureTextRenderer = class extends Renderer {
  static {
    __name(this, "PureTextRenderer");
  }
  async render(message, options) {
    let transformed = [h12.text(message.content)];
    if (options.split) {
      transformed = transformed.flatMap((element) => {
        const content = element.attrs["content"];
        return content.split("\n\n\n").map((paragraph) => {
          return h12.text(paragraph);
        });
      });
    }
    transformed = transformed.map((element) => {
      const content = element.attrs["content"];
      return h12.text(stripMarkdown(content));
    });
    return {
      element: transformed
    };
  }
  schema = Schema8.const("pure-text").i18n({
    "zh-CN": "将回复渲染为纯文本（去除 markdown 格式）",
    "en-US": "Render as pure text (remove markdown format)"
  });
};
function stripMarkdown(source) {
  return removeMarkdown(source);
}
__name(stripMarkdown, "stripMarkdown");

// src/render.ts
var DefaultRenderer = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
    this.defaultOptions = {
      type: config.outputMode,
      split: config.splitMessage,
      voice: {
        speakerId: config.voiceSpeakId
      }
    };
    ctx.inject(["chatluna"], (ctx2) => {
      this.addRenderer("text", () => new TextRenderer(ctx2));
      this.addRenderer("voice", () => new VoiceRenderer(ctx2));
      this.addRenderer("raw", () => new RawRenderer(ctx2));
      this.addRenderer("mixed-voice", () => new MixedVoiceRenderer(ctx2));
      this.addRenderer(
        "koishi-element",
        () => new KoishiElementRenderer(ctx2)
      );
      this.addRenderer("pure-text", () => new PureTextRenderer(ctx2));
    });
  }
  static {
    __name(this, "DefaultRenderer");
  }
  defaultOptions;
  renderers = {};
  async render(message, options = this.defaultOptions) {
    try {
      const result2 = [];
      const currentRenderer = await this.getRenderer(options.type);
      const rawRenderer = options.type === "raw" ? currentRenderer : await this.getRenderer("raw");
      if (message.additionalReplyMessages) {
        for (const additionalMessage of message.additionalReplyMessages) {
          const elements = await rawRenderer.render(additionalMessage, options).then((r) => r.element);
          result2.push({
            element: h13(
              "message",
              { forward: true },
              Array.isArray(elements) ? elements : [elements]
            )
          });
        }
      }
      result2.push(await currentRenderer.render(message, options));
      return result2;
    } catch (e) {
      throw new ChatLunaError7(ChatLunaErrorCode7.RENDER_ERROR, e);
    }
  }
  addRenderer(type, renderer) {
    this.renderers[type] = renderer(this.ctx, this.config);
    this.updateSchema();
    return () => this.removeRenderer(type);
  }
  removeRenderer(type) {
    delete this.renderers[type];
    this.updateSchema();
  }
  async getRenderer(type) {
    return this.renderers[type];
  }
  updateSchema() {
    if (!this.ctx.scope.isActive) {
      return;
    }
    this.ctx.schema.set(
      "output-mode",
      Schema9.union(this._getAllRendererScheme())
    );
  }
  _getAllRendererScheme() {
    return Object.values(this.renderers).map((key) => key.schema);
  }
  get rendererTypeList() {
    return Object.keys(this.renderers);
  }
};

// src/index.ts
var name = "chatluna";
var inject = {
  required: ["database"],
  optional: ["censor", "vits", "sst"]
};
var inject2 = {
  database: { required: true },
  censor: { required: false },
  vits: { required: false }
};
var logger;
var usage = `
## chatluna v1.1

ChatLuna 插件交流 QQ 群：282381753 （有问题或出现 Bug 先加群问）

群里目前没有搭载该插件的 bot，加群的话最好是来询问问题或者提出意见的。

访问 [https://chatluna.chat](https://chatluna.chat) 来了解如何使用 Chatluna。
也可以访问 [https://preset.chatluna.chat](https://preset.chatluna.chat) 进入在线预设编辑器。更有预设广场来浏览和下载你心仪的预设。
`;
function apply64(ctx, config) {
  logger = createLogger9(ctx);
  setupLogger(config);
  setupI18n(ctx);
  const disposables = [];
  ctx.on("ready", async () => {
    setupProxy(ctx, config);
    await setupServices(ctx, config, disposables);
    await setupPermissions(ctx, disposables);
    await setupEntryPoint(ctx, config, disposables);
  });
  ctx.on("dispose", async () => {
    clearLogger();
    disposables.forEach((disposable) => disposable());
  });
}
__name(apply64, "apply");
async function setupEntryPoint(ctx, config, disposables) {
  const entryPointPlugin = /* @__PURE__ */ __name((ctx2, config2) => {
    ctx2.on("ready", async () => {
      await initializeComponents(ctx2, config2);
    });
    setupMiddleware(ctx2);
  }, "entryPointPlugin");
  const entryPointDisposable = forkScopeToDisposable(
    ctx.plugin(
      {
        apply: entryPointPlugin,
        inject: {
          ...inject2,
          chatluna: { required: true },
          chatluna_auth: { required: false },
          database: { required: false }
        },
        name: "chatluna_entry_point"
      },
      config
    )
  );
  disposables.push(entryPointDisposable);
}
__name(setupEntryPoint, "setupEntryPoint");
async function initializeComponents(ctx, config) {
  await defaultFactory(ctx, ctx.chatluna.platform);
  await middleware(ctx, config);
  await command(ctx, config);
  await ctx.chatluna.preset.init();
  await setupAutoDelete(ctx, config);
  apply8(ctx, config);
  apply9(ctx, config);
}
__name(initializeComponents, "initializeComponents");
function setupMiddleware(ctx) {
  ctx.middleware((session, next) => {
    if (ctx.chatluna == null || ctx.chatluna.chatChain == null) {
      return next();
    }
    return next(async (nextMiddleware) => {
      const messageHandled = await ctx.chatluna.chatChain.receiveMessage(
        session,
        ctx
      );
      if (!messageHandled) {
        return await nextMiddleware();
      }
    });
  });
}
__name(setupMiddleware, "setupMiddleware");
function setupLogger(config) {
  if (config.isLog) {
    setLoggerLevel(Logger4.DEBUG);
  }
}
__name(setupLogger, "setupLogger");
function setupI18n(ctx) {
  ctx.i18n.define("zh-CN", require_zh_CN());
  ctx.i18n.define("en-US", require_en_US());
}
__name(setupI18n, "setupI18n");
function setupProxy(ctx, config) {
  if (config.isProxy) {
    request.setGlobalProxyAddress(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      config.proxyAddress ?? ctx.http.config?.proxyAgent
    );
    logger.debug(
      "global proxy %c",
      config.proxyAddress,
      request.globalProxyAddress
    );
  }
}
__name(setupProxy, "setupProxy");
async function setupServices(ctx, config, disposables) {
  disposables.push(
    forkScopeToDisposable(ctx.plugin(ChatLunaService, config)),
    forkScopeToDisposable(ctx.plugin(ChatLunaAuthService, config))
  );
}
__name(setupServices, "setupServices");
async function setupPermissions(ctx, disposables) {
  const adminPermissionDisposable = ctx.permissions.define("chatluna:admin", {
    inherits: ["authority.3"]
  });
  disposables.push(() => {
    adminPermissionDisposable();
  });
  const adminProviderDisposable = ctx.permissions.provide(
    "chatluna:admin",
    async (name2, session) => {
      return (await session.getUser(session.userId, [
        "authority"
      ]))?.authority >= 3;
    }
  );
  disposables.push(() => {
    adminProviderDisposable();
  });
}
__name(setupPermissions, "setupPermissions");
async function setupAutoDelete(ctx, config) {
  if (!config.autoDelete) {
    return;
  }
  async function execute() {
    if (!ctx.scope.isActive) {
      return;
    }
    const rooms = await ctx.database.get("chathub_room", {
      updatedTime: {
        $lt: new Date(Date.now() - config.autoDeleteTimeout * 1e3)
      }
    });
    if (rooms.length === 0) {
      return;
    }
    logger.info("auto delete task running");
    const success = [];
    for (const room of rooms) {
      try {
        await deleteConversationRoom2(ctx, room);
        success.push(room);
      } catch (e) {
        logger.error(e);
      }
    }
    logger.success(
      `auto delete %c rooms [%c]`,
      rooms.length,
      success.map((room) => room.roomName).join(",")
    );
  }
  __name(execute, "execute");
  await execute();
  ctx.setInterval(async () => {
    await execute();
  }, Time3.minute * 5);
}
__name(setupAutoDelete, "setupAutoDelete");
export {
  Config2 as Config,
  DefaultRenderer,
  Renderer,
  apply64 as apply,
  inject,
  inject2,
  logger,
  name,
  usage
};
