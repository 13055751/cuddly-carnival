var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/llm-core/prompt/index.ts
var prompt_exports = {};
__export(prompt_exports, {
  isRoleBook: () => isRoleBook,
  isRoleBookConfig: () => isRoleBookConfig,
  loadPreset: () => loadPreset,
  tokenize: () => tokenize
});
module.exports = __toCommonJS(prompt_exports);

// src/llm-core/prompt/preset_prompt_parse.ts
var import_messages = require("@langchain/core/messages");
var import_js_yaml = require("js-yaml");
var import_koishi_plugin_chatluna = require("koishi-plugin-chatluna");

// src/llm-core/prompt/type.ts
function isRoleBook(obj) {
  return typeof obj === "object" && obj !== null && "keywords" in obj && "content" in obj;
}
__name(isRoleBook, "isRoleBook");
function isRoleBookConfig(obj) {
  return !isRoleBook(obj) && typeof obj === "object" && obj !== null;
}
__name(isRoleBookConfig, "isRoleBookConfig");

// src/llm-core/prompt/tokenize.ts
function tokenize(input) {
  const tokens = [];
  let i = 0;
  while (i < input.length) {
    const braceStart = input.indexOf("{", i);
    if (braceStart === -1) {
      if (i < input.length) {
        tokens.push({ type: "text", value: input.slice(i) });
      }
      break;
    }
    if (braceStart > i) {
      tokens.push({ type: "text", value: input.slice(i, braceStart) });
    }
    if (braceStart + 1 < input.length && input[braceStart + 1] === "{") {
      const endBraces = input.indexOf("}}", braceStart + 2);
      if (endBraces !== -1) {
        tokens.push({
          type: "text",
          value: input.slice(braceStart, endBraces + 2)
        });
        i = endBraces + 2;
        continue;
      }
    }
    const braceEnd = findMatchingCloseBrace(input, braceStart);
    if (braceEnd === -1) {
      tokens.push({ type: "text", value: input[braceStart] });
      i = braceStart + 1;
      continue;
    }
    const content = input.slice(braceStart + 1, braceEnd);
    const token = parseTokenContent(content);
    tokens.push(token);
    i = braceEnd + 1;
  }
  return tokens;
}
__name(tokenize, "tokenize");
function findMatchingCloseBrace(input, start) {
  let depth = 1;
  let i = start + 1;
  let inString = false;
  let stringDelim = "";
  while (i < input.length && depth > 0) {
    const char = input[i];
    if (!inString) {
      if (char === '"' || char === "'") {
        inString = true;
        stringDelim = char;
      } else if (char === "{") {
        depth++;
      } else if (char === "}") {
        depth--;
      }
    } else {
      if (char === "\\" && i + 1 < input.length) {
        i++;
      } else if (char === stringDelim) {
        inString = false;
        stringDelim = "";
      }
    }
    i++;
  }
  return depth === 0 ? i - 1 : -1;
}
__name(findMatchingCloseBrace, "findMatchingCloseBrace");
function parseTokenContent(content) {
  const parts = [];
  let i = 0;
  while (i < content.length) {
    while (i < content.length && /\s/.test(content[i])) {
      i++;
    }
    if (i >= content.length) break;
    let part = "";
    if (content[i] === '"' || content[i] === "'") {
      const quote = content[i];
      i++;
      while (i < content.length) {
        if (content[i] === "\\" && i + 1 < content.length) {
          const nextChar = content[i + 1];
          switch (nextChar) {
            case "n":
              part += "\n";
              break;
            case "t":
              part += "	";
              break;
            case "r":
              part += "\r";
              break;
            case "b":
              part += "\b";
              break;
            case "f":
              part += "\f";
              break;
            case "v":
              part += "\v";
              break;
            case "0":
              part += "\0";
              break;
            case "\\":
              part += "\\";
              break;
            case '"':
              part += '"';
              break;
            case "'":
              part += "'";
              break;
            case "/":
              part += "/";
              break;
            default:
              part += "\\" + nextChar;
              break;
          }
          i += 2;
        } else if (content[i] === quote) {
          i++;
          break;
        } else {
          part += content[i];
          i++;
        }
      }
    } else {
      while (i < content.length) {
        if (content[i] === ":") {
          if (i + 1 < content.length && content[i + 1] === ":") {
            break;
          } else if (parts.length === 0) {
            break;
          }
        }
        if (content[i] === "+" || content[i] === "-") {
          if (part === "") {
            part += content[i];
            i++;
            continue;
          } else if (parts.length === 0) {
            break;
          }
        }
        part += content[i];
        i++;
      }
    }
    if (part.trim()) {
      parts.push(part.trim());
    }
    if (i < content.length) {
      if (content[i] === ":") {
        if (i + 1 < content.length && content[i + 1] === ":") {
          i += 2;
        } else if (parts.length === 1) {
          i++;
        }
      } else if ((content[i] === "+" || content[i] === "-") && parts.length === 1) {
      }
    }
  }
  if (parts.length <= 1) {
    return {
      type: "variable",
      value: parts[0] || content.trim()
    };
  } else {
    const [funcName, ...args] = parts;
    return {
      type: "function",
      value: funcName,
      args: args.filter((arg) => arg !== "")
    };
  }
}
__name(parseTokenContent, "parseTokenContent");

// src/llm-core/prompt/preset_prompt_parse.ts
function loadPreset(rawText) {
  try {
    return loadYamlPreset(rawText);
  } catch {
    return loadTxtPreset(rawText);
  }
}
__name(loadPreset, "loadPreset");
function createMessage(role, content, type) {
  if (content == null) {
    throw new Error("Content is required");
  }
  const fields = {
    content: content.trim(),
    additional_kwargs: { type }
  };
  switch (role) {
    case "assistant":
    case "ai":
    case "model":
      return new import_messages.AIMessage(fields);
    case "user":
    case "human":
      return new import_messages.HumanMessage(fields);
    case "system":
      return new import_messages.SystemMessage(fields);
    default:
      throw new Error(`Unknown role: ${role}`);
  }
}
__name(createMessage, "createMessage");
function loadYamlPreset(rawText) {
  const rawJson = (0, import_js_yaml.load)(rawText);
  let loreBooks = {
    items: []
  };
  let authorsNote;
  if (rawJson.world_lores) {
    const config = rawJson.world_lores.find(
      isRoleBookConfig
    );
    const items = rawJson.world_lores.filter(isRoleBook).map((item) => ({
      ...item,
      keywords: Array.isArray(item.keywords) ? item.keywords : [item.keywords]
    }));
    loreBooks = {
      ...config,
      items
    };
  } else {
    loreBooks = void 0;
  }
  if (rawJson.authors_note || rawJson["author_notes"]) {
    authorsNote = rawJson.authors_note || rawJson["author_notes"];
    authorsNote.insertFrequency = authorsNote.insertFrequency ?? 1;
    authorsNote.insertPosition = authorsNote.insertPosition ?? "in_chat";
    authorsNote.insertDepth = authorsNote.insertDepth ?? 0;
  }
  return {
    triggerKeyword: rawJson.keywords,
    rawText,
    messages: rawJson.prompts.map(
      (message) => createMessage(message.role, message.content, message.type)
    ),
    formatUserPromptString: rawJson.format_user_prompt,
    loreBooks,
    authorsNote,
    knowledge: rawJson?.knowledge,
    version: rawJson?.version,
    config: rawJson.config ?? {}
  };
}
__name(loadYamlPreset, "loadYamlPreset");
function loadTxtPreset(rawText) {
  const triggerKeyword = [];
  const messages = [];
  let formatUserPromptString = "{prompt}";
  import_koishi_plugin_chatluna.logger?.warn(
    "TXT Preset is deprecated and will be removed in 1.0. Please migrate to YAML preset format. For more migrate information, visit: https://chatluna.chat/guide/preset-system/introduction.html"
  );
  const chunks = rawText.replace(/#.*\r?\n/g, "").replace(/\r\n/g, "\n").split(/\n\n/);
  for (const chunk of chunks) {
    const match = chunk.match(/^\s*([a-zA-Z_]+)\s*:\s*(.*)$/s);
    if (!match) continue;
    const [, role, content] = match;
    if (role === "keyword") {
      triggerKeyword.push(...content.split(",").map((k) => k.trim()));
    } else if (role === "format_user_prompt") {
      formatUserPromptString = content.trim();
    } else {
      messages.push(createMessage(role, content));
    }
  }
  if (triggerKeyword.length === 0) throw new Error("No trigger keyword found");
  if (messages.length === 0) throw new Error("No preset messages found");
  return {
    rawText,
    triggerKeyword,
    messages,
    formatUserPromptString,
    config: {}
  };
}
__name(loadTxtPreset, "loadTxtPreset");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  isRoleBook,
  isRoleBookConfig,
  loadPreset,
  tokenize
});
