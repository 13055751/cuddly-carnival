var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/llm-core/platform/service.ts
var service_exports = {};
__export(service_exports, {
  PlatformService: () => PlatformService
});
module.exports = __toCommonJS(service_exports);
var import_koishi = require("koishi");
var import_client = require("koishi-plugin-chatluna/llm-core/platform/client");
var import_types = require("koishi-plugin-chatluna/llm-core/platform/types");
var import_lru_cache = require("lru-cache");
var import_koishi_plugin_chatluna = require("koishi-plugin-chatluna");
var PlatformService = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.ctx.on("chatluna/clear-chat-history", async (conversationId) => {
      this._tmpVectorStores.clear();
    });
  }
  static {
    __name(this, "PlatformService");
  }
  _platformClients = {};
  _createClientFunctions = {};
  _configPools = {};
  _tools = {};
  _models = {};
  _chatChains = {};
  _vectorStore = {};
  _tmpVectorStores = new import_lru_cache.LRUCache({
    max: 20,
    dispose: /* @__PURE__ */ __name((value, key, reason) => {
      value.free();
    }, "dispose")
  });
  registerClient(name, createClientFunction) {
    if (this._createClientFunctions[name]) {
      throw new Error(`Client ${name} already exists`);
    }
    this._createClientFunctions[name] = createClientFunction;
    return () => this.unregisterClient(name);
  }
  registerConfigPool(name, configPool) {
    if (this._configPools[name]) {
      throw new Error(`Config pool ${name} already exists`);
    }
    this._configPools[name] = configPool;
  }
  registerTool(name, toolCreator) {
    this._tools[name] = toolCreator;
    this.ctx.emit("chatluna/tool-updated", this);
    return () => this.unregisterTool(name);
  }
  unregisterTool(name) {
    delete this._tools[name];
    this.ctx.emit("chatluna/tool-updated", this);
  }
  unregisterClient(platform) {
    const configPool = this._configPools[platform];
    if (!configPool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    const configs = configPool.getConfigs();
    delete this._models[platform];
    for (const config of configs) {
      const client = this.getClientForCache(config.value);
      if (client == null) {
        continue;
      }
      delete this._platformClients[this._getClientConfigAsKey(config.value)];
      if (client instanceof import_client.PlatformModelClient) {
        this.ctx.emit("chatluna/model-removed", this, platform, client);
      } else if (client instanceof import_client.PlatformEmbeddingsClient) {
        this.ctx.emit(
          "chatluna/embeddings-removed",
          this,
          platform,
          client
        );
      } else if (client instanceof import_client.PlatformModelAndEmbeddingsClient) {
        this.ctx.emit(
          "chatluna/embeddings-removed",
          this,
          platform,
          client
        );
        this.ctx.emit("chatluna/model-removed", this, platform, client);
      }
    }
    delete this._configPools[platform];
    delete this._createClientFunctions[platform];
  }
  unregisterVectorStore(name) {
    delete this._vectorStore[name];
    this.ctx.emit("chatluna/vector-store-removed", this, name);
  }
  registerVectorStore(name, vectorStoreRetrieverCreator) {
    this._vectorStore[name] = vectorStoreRetrieverCreator;
    this.ctx.emit("chatluna/vector-store-added", this, name);
    return () => this.unregisterVectorStore(name);
  }
  registerChatChain(name, description, createChatChainFunction) {
    this._chatChains[name] = {
      name,
      description,
      createFunction: createChatChainFunction
    };
    this.ctx.emit("chatluna/chat-chain-added", this, this._chatChains[name]);
    return () => this.unregisterChatChain(name);
  }
  unregisterChatChain(name) {
    const chain = this._chatChains[name];
    delete this._chatChains[name];
    this.ctx.emit("chatluna/chat-chain-removed", this, chain);
  }
  getModels(platform, type) {
    const models = this._models[platform] ?? [];
    if (models.length === 0) {
      return [];
    }
    return models.filter((m) => type === import_types.ModelType.all || m.type === type).sort((a, b) => {
      if (!a?.name || !b?.name) return 0;
      return a.name.localeCompare(b.name, void 0, {
        numeric: true,
        sensitivity: "base"
      });
    });
  }
  getTools() {
    return Object.keys(this._tools);
  }
  getConfigs(platform) {
    return this._configPools[platform]?.getConfigs() ?? [];
  }
  resolveModel(platform, name) {
    return this._models[platform]?.find((m) => m.name === name);
  }
  getAllModels(type) {
    const allModel = [];
    for (const platform in this._models) {
      const models = this._models[platform];
      for (const model of models) {
        if (type === import_types.ModelType.all || model.type === type) {
          allModel.push(platform + "/" + model.name);
        }
      }
    }
    return allModel.sort();
  }
  getVectorStores() {
    return Object.keys(this._vectorStore);
  }
  /**
   * @deprecated Use {@link getVectorStores} instead. Will be removed in the next version.
   */
  getVectorStoreRetrievers() {
    return Object.values(this._vectorStore);
  }
  getChatChains() {
    return Object.values(this._chatChains);
  }
  makeConfigStatus(config, isAvailable) {
    const platform = config.platform;
    const pool = this._configPools[platform];
    if (!pool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    return pool.markConfigStatus(config, isAvailable);
  }
  async createVectorStore(name, params) {
    const vectorStoreRetriever = this._vectorStore[name];
    if (!vectorStoreRetriever) {
      throw new Error(`Vector store retriever ${name} not found`);
    }
    const key = params.key;
    if (key == null) {
      return await vectorStoreRetriever(params);
    }
    const cacheVectorStore = this._tmpVectorStores.get(key);
    if (cacheVectorStore) {
      return cacheVectorStore;
    }
    const vectorStore = await vectorStoreRetriever(params);
    this._tmpVectorStores.set(key, vectorStore);
    return vectorStore;
  }
  async randomConfig(platform, lockConfig = false) {
    return this._configPools[platform]?.getConfig(lockConfig);
  }
  async randomClient(platform, lockConfig = false) {
    const config = await this.randomConfig(platform, lockConfig);
    if (!config) {
      return void 0;
    }
    const client = await this.getClient(config.value);
    return client;
  }
  getClientForCache(config) {
    return this._platformClients[this._getClientConfigAsKey(config)];
  }
  async getClient(config) {
    return this.getClientForCache(config) ?? await this.createClient(config.platform, config);
  }
  async refreshClient(client, platform, config) {
    let isAvailable = false;
    try {
      isAvailable = await client.isAvailable();
    } catch (e) {
      import_koishi_plugin_chatluna.logger.error(e);
    }
    const pool = this._configPools[platform];
    await pool.markConfigStatus(config, isAvailable);
    if (!isAvailable) {
      return void 0;
    }
    let models = null;
    try {
      models = await client.getModels();
    } catch (e) {
      import_koishi_plugin_chatluna.logger.error(e);
    }
    if (models == null) {
      await pool.markConfigStatus(config, false);
      return void 0;
    }
    const availableModels = this._models[platform] ?? [];
    await (0, import_koishi.sleep)(1);
    this._models[platform] = availableModels.concat(
      models.filter(
        (m) => !availableModels.some((am) => am.name === m.name)
      )
    );
    if (client instanceof import_client.PlatformModelClient) {
      this.ctx.emit("chatluna/model-added", this, platform, client);
    } else if (client instanceof import_client.PlatformEmbeddingsClient) {
      this.ctx.emit("chatluna/embeddings-added", this, platform, client);
    } else if (client instanceof import_client.PlatformModelAndEmbeddingsClient) {
      this.ctx.emit("chatluna/embeddings-added", this, platform, client);
      this.ctx.emit("chatluna/model-added", this, platform, client);
    }
  }
  async createClient(platform, config) {
    const createClientFunction = this._createClientFunctions[platform];
    if (!createClientFunction) {
      throw new Error(`Create client function ${platform} not found`);
    }
    const client = createClientFunction(this.ctx, config);
    await this.refreshClient(client, platform, config);
    return client;
  }
  async createClients(platform) {
    const configPool = this._configPools[platform];
    if (!configPool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    const configs = configPool.getConfigs();
    const clients = [];
    for (const config of configs) {
      const client = await this.createClient(platform, config.value);
      if (client == null) {
        continue;
      }
      clients.push(client);
      this._platformClients[this._getClientConfigAsKey(config.value)] = client;
    }
    return clients;
  }
  getTool(name) {
    return this._tools[name];
  }
  createChatChain(name, params) {
    const chatChain = this._chatChains[name];
    if (!chatChain) {
      throw new Error(`Chat chain ${name} not found`);
    }
    return chatChain.createFunction(params);
  }
  _getClientConfigAsKey(config) {
    return `${config.platform}/${config.apiKey}/${config.apiEndpoint}/${config.maxRetries}/${config.concurrentMaxSize}/${config.timeout}`;
  }
  dispose() {
    this._tmpVectorStores.clear();
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PlatformService
});
