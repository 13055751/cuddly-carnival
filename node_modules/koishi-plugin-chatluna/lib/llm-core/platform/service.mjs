var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/llm-core/platform/service.ts
import { sleep } from "koishi";
import {
  PlatformEmbeddingsClient,
  PlatformModelAndEmbeddingsClient,
  PlatformModelClient
} from "koishi-plugin-chatluna/llm-core/platform/client";
import {
  ModelType
} from "koishi-plugin-chatluna/llm-core/platform/types";
import { LRUCache } from "lru-cache";
import { logger } from "koishi-plugin-chatluna";
var PlatformService = class {
  constructor(ctx) {
    this.ctx = ctx;
    this.ctx.on("chatluna/clear-chat-history", async (conversationId) => {
      this._tmpVectorStores.clear();
    });
  }
  static {
    __name(this, "PlatformService");
  }
  _platformClients = {};
  _createClientFunctions = {};
  _configPools = {};
  _tools = {};
  _models = {};
  _chatChains = {};
  _vectorStore = {};
  _tmpVectorStores = new LRUCache({
    max: 20,
    dispose: /* @__PURE__ */ __name((value, key, reason) => {
      value.free();
    }, "dispose")
  });
  registerClient(name, createClientFunction) {
    if (this._createClientFunctions[name]) {
      throw new Error(`Client ${name} already exists`);
    }
    this._createClientFunctions[name] = createClientFunction;
    return () => this.unregisterClient(name);
  }
  registerConfigPool(name, configPool) {
    if (this._configPools[name]) {
      throw new Error(`Config pool ${name} already exists`);
    }
    this._configPools[name] = configPool;
  }
  registerTool(name, toolCreator) {
    this._tools[name] = toolCreator;
    this.ctx.emit("chatluna/tool-updated", this);
    return () => this.unregisterTool(name);
  }
  unregisterTool(name) {
    delete this._tools[name];
    this.ctx.emit("chatluna/tool-updated", this);
  }
  unregisterClient(platform) {
    const configPool = this._configPools[platform];
    if (!configPool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    const configs = configPool.getConfigs();
    delete this._models[platform];
    for (const config of configs) {
      const client = this.getClientForCache(config.value);
      if (client == null) {
        continue;
      }
      delete this._platformClients[this._getClientConfigAsKey(config.value)];
      if (client instanceof PlatformModelClient) {
        this.ctx.emit("chatluna/model-removed", this, platform, client);
      } else if (client instanceof PlatformEmbeddingsClient) {
        this.ctx.emit(
          "chatluna/embeddings-removed",
          this,
          platform,
          client
        );
      } else if (client instanceof PlatformModelAndEmbeddingsClient) {
        this.ctx.emit(
          "chatluna/embeddings-removed",
          this,
          platform,
          client
        );
        this.ctx.emit("chatluna/model-removed", this, platform, client);
      }
    }
    delete this._configPools[platform];
    delete this._createClientFunctions[platform];
  }
  unregisterVectorStore(name) {
    delete this._vectorStore[name];
    this.ctx.emit("chatluna/vector-store-removed", this, name);
  }
  registerVectorStore(name, vectorStoreRetrieverCreator) {
    this._vectorStore[name] = vectorStoreRetrieverCreator;
    this.ctx.emit("chatluna/vector-store-added", this, name);
    return () => this.unregisterVectorStore(name);
  }
  registerChatChain(name, description, createChatChainFunction) {
    this._chatChains[name] = {
      name,
      description,
      createFunction: createChatChainFunction
    };
    this.ctx.emit("chatluna/chat-chain-added", this, this._chatChains[name]);
    return () => this.unregisterChatChain(name);
  }
  unregisterChatChain(name) {
    const chain = this._chatChains[name];
    delete this._chatChains[name];
    this.ctx.emit("chatluna/chat-chain-removed", this, chain);
  }
  getModels(platform, type) {
    const models = this._models[platform] ?? [];
    if (models.length === 0) {
      return [];
    }
    return models.filter((m) => type === ModelType.all || m.type === type).sort((a, b) => {
      if (!a?.name || !b?.name) return 0;
      return a.name.localeCompare(b.name, void 0, {
        numeric: true,
        sensitivity: "base"
      });
    });
  }
  getTools() {
    return Object.keys(this._tools);
  }
  getConfigs(platform) {
    return this._configPools[platform]?.getConfigs() ?? [];
  }
  resolveModel(platform, name) {
    return this._models[platform]?.find((m) => m.name === name);
  }
  getAllModels(type) {
    const allModel = [];
    for (const platform in this._models) {
      const models = this._models[platform];
      for (const model of models) {
        if (type === ModelType.all || model.type === type) {
          allModel.push(platform + "/" + model.name);
        }
      }
    }
    return allModel.sort();
  }
  getVectorStores() {
    return Object.keys(this._vectorStore);
  }
  /**
   * @deprecated Use {@link getVectorStores} instead. Will be removed in the next version.
   */
  getVectorStoreRetrievers() {
    return Object.values(this._vectorStore);
  }
  getChatChains() {
    return Object.values(this._chatChains);
  }
  makeConfigStatus(config, isAvailable) {
    const platform = config.platform;
    const pool = this._configPools[platform];
    if (!pool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    return pool.markConfigStatus(config, isAvailable);
  }
  async createVectorStore(name, params) {
    const vectorStoreRetriever = this._vectorStore[name];
    if (!vectorStoreRetriever) {
      throw new Error(`Vector store retriever ${name} not found`);
    }
    const key = params.key;
    if (key == null) {
      return await vectorStoreRetriever(params);
    }
    const cacheVectorStore = this._tmpVectorStores.get(key);
    if (cacheVectorStore) {
      return cacheVectorStore;
    }
    const vectorStore = await vectorStoreRetriever(params);
    this._tmpVectorStores.set(key, vectorStore);
    return vectorStore;
  }
  async randomConfig(platform, lockConfig = false) {
    return this._configPools[platform]?.getConfig(lockConfig);
  }
  async randomClient(platform, lockConfig = false) {
    const config = await this.randomConfig(platform, lockConfig);
    if (!config) {
      return void 0;
    }
    const client = await this.getClient(config.value);
    return client;
  }
  getClientForCache(config) {
    return this._platformClients[this._getClientConfigAsKey(config)];
  }
  async getClient(config) {
    return this.getClientForCache(config) ?? await this.createClient(config.platform, config);
  }
  async refreshClient(client, platform, config) {
    let isAvailable = false;
    try {
      isAvailable = await client.isAvailable();
    } catch (e) {
      logger.error(e);
    }
    const pool = this._configPools[platform];
    await pool.markConfigStatus(config, isAvailable);
    if (!isAvailable) {
      return void 0;
    }
    let models = null;
    try {
      models = await client.getModels();
    } catch (e) {
      logger.error(e);
    }
    if (models == null) {
      await pool.markConfigStatus(config, false);
      return void 0;
    }
    const availableModels = this._models[platform] ?? [];
    await sleep(1);
    this._models[platform] = availableModels.concat(
      models.filter(
        (m) => !availableModels.some((am) => am.name === m.name)
      )
    );
    if (client instanceof PlatformModelClient) {
      this.ctx.emit("chatluna/model-added", this, platform, client);
    } else if (client instanceof PlatformEmbeddingsClient) {
      this.ctx.emit("chatluna/embeddings-added", this, platform, client);
    } else if (client instanceof PlatformModelAndEmbeddingsClient) {
      this.ctx.emit("chatluna/embeddings-added", this, platform, client);
      this.ctx.emit("chatluna/model-added", this, platform, client);
    }
  }
  async createClient(platform, config) {
    const createClientFunction = this._createClientFunctions[platform];
    if (!createClientFunction) {
      throw new Error(`Create client function ${platform} not found`);
    }
    const client = createClientFunction(this.ctx, config);
    await this.refreshClient(client, platform, config);
    return client;
  }
  async createClients(platform) {
    const configPool = this._configPools[platform];
    if (!configPool) {
      throw new Error(`Config pool ${platform} not found`);
    }
    const configs = configPool.getConfigs();
    const clients = [];
    for (const config of configs) {
      const client = await this.createClient(platform, config.value);
      if (client == null) {
        continue;
      }
      clients.push(client);
      this._platformClients[this._getClientConfigAsKey(config.value)] = client;
    }
    return clients;
  }
  getTool(name) {
    return this._tools[name];
  }
  createChatChain(name, params) {
    const chatChain = this._chatChains[name];
    if (!chatChain) {
      throw new Error(`Chat chain ${name} not found`);
    }
    return chatChain.createFunction(params);
  }
  _getClientConfigAsKey(config) {
    return `${config.platform}/${config.apiKey}/${config.apiEndpoint}/${config.maxRetries}/${config.concurrentMaxSize}/${config.timeout}`;
  }
  dispose() {
    this._tmpVectorStores.clear();
  }
};
export {
  PlatformService
};
