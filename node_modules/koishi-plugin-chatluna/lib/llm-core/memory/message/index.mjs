var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/llm-core/memory/message/database_history.ts
import {
  AIMessage,
  HumanMessage,
  SystemMessage
} from "@langchain/core/messages";
import { v4 as uuidv4 } from "uuid";
import { BaseChatMessageHistory } from "@langchain/core/chat_history";
import {
  bufferToArrayBuffer,
  gzipDecode,
  gzipEncode
} from "koishi-plugin-chatluna/utils/string";
var KoishiChatMessageHistory = class extends BaseChatMessageHistory {
  constructor(ctx, conversationId, _maxMessagesCount) {
    super();
    this._maxMessagesCount = _maxMessagesCount;
    this.conversationId = conversationId;
    this._ctx = ctx;
    this._chatHistory = [];
    this._additional_kwargs = {};
    this._updatedAt = /* @__PURE__ */ new Date(0);
  }
  static {
    __name(this, "KoishiChatMessageHistory");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  lc_namespace = ["llm-core", "memory", "message"];
  conversationId;
  _ctx;
  _latestId;
  _serializedChatHistory;
  _chatHistory;
  // eslint-disable-next-line @typescript-eslint/naming-convention
  _additional_kwargs;
  _updatedAt;
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get additionalArgs() {
    return this._additional_kwargs;
  }
  async getMessages() {
    const latestUpdateTime = await this.getLatestUpdateTime();
    if (latestUpdateTime > this._updatedAt || this._chatHistory.length === 0) {
      this._chatHistory = await this._loadMessages();
    }
    return this._chatHistory;
  }
  async addUserMessage(message) {
    const humanMessage = new HumanMessage(message);
    await this._saveMessage(humanMessage);
  }
  async addAIChatMessage(message) {
    const aiMessage = new AIMessage(message);
    await this._saveMessage(aiMessage);
  }
  async addMessage(message) {
    await this._saveMessage(message);
  }
  async clear() {
    await this._ctx.database.remove("chathub_message", {
      conversation: this.conversationId
    });
    await this._ctx.database.upsert("chathub_conversation", [
      {
        id: this.conversationId,
        latestId: null
      }
    ]);
    this._serializedChatHistory = [];
    this._chatHistory = [];
    this._latestId = null;
  }
  async delete() {
    await this._ctx.database.remove("chathub_conversation", {
      id: this.conversationId
    });
  }
  async updateAdditionalArg(key, value) {
    await this.loadConversation();
    this._additional_kwargs[key] = value;
    await this._saveConversation();
  }
  async getAdditionalArg(key) {
    await this.loadConversation();
    return this._additional_kwargs[key];
  }
  async getAdditionalArgs() {
    await this.loadConversation();
    return this._additional_kwargs;
  }
  async deleteAdditionalArg(key) {
    await this.loadConversation();
    delete this._additional_kwargs[key];
    await this._saveConversation();
  }
  async overrideAdditionalArgs(kwargs) {
    await this.loadConversation();
    this._additional_kwargs = Object.assign(this._additional_kwargs, kwargs);
    await this._saveConversation();
  }
  async getLatestUpdateTime() {
    const conversation = (await this._ctx.database.get(
      "chathub_conversation",
      {
        id: this.conversationId
      },
      ["updatedAt"]
    ))?.[0];
    return conversation?.updatedAt ?? /* @__PURE__ */ new Date(0);
  }
  async _loadMessages() {
    const queried = await this._ctx.database.get("chathub_message", {
      conversation: this.conversationId
    });
    const sorted = [];
    let currentMessageId = this._latestId;
    let isBad = false;
    if (currentMessageId == null && queried.length > 0) {
      isBad = true;
    }
    while (currentMessageId != null && !isBad) {
      const currentMessage = queried.find(
        (item) => item.id === currentMessageId
      );
      if (!currentMessage) {
        isBad = true;
        break;
      }
      sorted.unshift(currentMessage);
      currentMessageId = currentMessage.parent;
    }
    if (isBad) {
      this._ctx.logger.warn(
        `Bad conversation detected for %s`,
        this.conversationId
      );
      sorted.length = 0;
      await this.clear();
    }
    this._serializedChatHistory = sorted;
    const promises = sorted.map(async (item) => {
      const args = JSON.parse(
        item.additional_kwargs_binary ? await gzipDecode(item.additional_kwargs_binary) : item.additional_kwargs ?? "{}"
      );
      const content = JSON.parse(item.text);
      const fields = {
        content,
        id: item.rawId ?? void 0,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        additional_kwargs: args
      };
      if (item.role === "system") {
        return new SystemMessage(fields);
      } else if (item.role === "human") {
        return new HumanMessage(fields);
      } else if (item.role === "ai") {
        return new AIMessage(fields);
      } else {
        throw new Error("Unknown role");
      }
    });
    return await Promise.all(promises);
  }
  async _loadConversation() {
    const conversation = (await this._ctx.database.get("chathub_conversation", {
      id: this.conversationId
    }))?.[0];
    if (conversation) {
      this._latestId = conversation.latestId;
      this._additional_kwargs = conversation.additional_kwargs != null ? JSON.parse(conversation.additional_kwargs) : {};
    } else {
      await this._ctx.database.create("chathub_conversation", {
        id: this.conversationId
      });
    }
    if (!this._serializedChatHistory) {
      await this._loadMessages();
      this._updatedAt = conversation?.updatedAt ?? /* @__PURE__ */ new Date(0);
    }
  }
  async loadConversation() {
    if (!this._serializedChatHistory) {
      await this._loadConversation();
    }
  }
  async _saveMessage(message) {
    const lastedMessage = this._serializedChatHistory.find(
      (item) => item.id === this._latestId
    );
    let additionalArgs = Object.assign({}, message.additional_kwargs);
    delete additionalArgs["preset"];
    delete additionalArgs["raw_content"];
    delete additionalArgs["type"];
    if (Object.keys(additionalArgs).length === 0) {
      additionalArgs = null;
    }
    const serializedMessage = {
      id: uuidv4(),
      text: JSON.stringify(message.content),
      parent: lastedMessage?.id ?? null,
      role: message.getType(),
      additional_kwargs_binary: additionalArgs ? await gzipEncode(JSON.stringify(additionalArgs)).then(
        (buf) => bufferToArrayBuffer(buf)
      ) : null,
      rawId: message.id ?? null,
      conversation: this.conversationId
    };
    await this._ctx.database.upsert("chathub_message", [serializedMessage]);
    this._serializedChatHistory.push(serializedMessage);
    this._chatHistory.push(message);
    this._latestId = serializedMessage.id;
    const updatedAt = /* @__PURE__ */ new Date();
    if (this._serializedChatHistory.length > this._maxMessagesCount) {
      const toDeleted = this._serializedChatHistory.splice(
        0,
        this._serializedChatHistory.length - this._maxMessagesCount
      );
      if (toDeleted[toDeleted.length - 1].role === "human" && this._serializedChatHistory[0]?.role === "ai" || this._serializedChatHistory[0]?.role === "function") {
        toDeleted.push(this._serializedChatHistory.shift());
      }
      await this._ctx.database.remove("chathub_message", {
        id: toDeleted.map((item) => item.id)
      });
      const firstMessage = this._serializedChatHistory[0];
      firstMessage.parent = null;
      await this._ctx.database.upsert("chathub_message", [firstMessage]);
      this._chatHistory = await this._loadMessages();
    }
    this._updatedAt = updatedAt;
    await this._saveConversation(updatedAt);
  }
  async _saveConversation(time = /* @__PURE__ */ new Date()) {
    await this._ctx.database.upsert("chathub_conversation", [
      {
        id: this.conversationId,
        latestId: this._latestId,
        additional_kwargs: JSON.stringify(this._additional_kwargs),
        updatedAt: time
      }
    ]);
  }
};
export {
  KoishiChatMessageHistory
};
