var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/llm-core/chain/base.ts
var base_exports = {};
__export(base_exports, {
  BaseChain: () => BaseChain,
  ChatLunaLLMChain: () => ChatLunaLLMChain,
  ChatLunaLLMChainWrapper: () => ChatLunaLLMChainWrapper,
  callChatLunaChain: () => callChatLunaChain
});
module.exports = __toCommonJS(base_exports);
var import_manager = require("@langchain/core/callbacks/manager");
var import_runnables = require("@langchain/core/runnables");
var import_error = require("koishi-plugin-chatluna/utils/error");
var import_base = require("@langchain/core/language_models/base");
var import_outputs = require("@langchain/core/outputs");
var ChatLunaLLMChainWrapper = class {
  static {
    __name(this, "ChatLunaLLMChainWrapper");
  }
};
var BaseChain = class extends import_base.BaseLangChain {
  static {
    __name(this, "BaseChain");
  }
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
  constructor(fields, verbose, callbacks) {
    if (arguments.length === 1 && typeof fields === "object" && !("saveContext" in fields)) {
      const { memory, callbackManager, ...rest } = fields;
      super({ ...rest, callbacks: callbackManager ?? rest.callbacks });
      this.memory = memory;
    } else {
      super({ verbose, callbacks });
      this.memory = fields;
    }
  }
  /** @ignore */
  _selectMemoryInputs(values) {
    const valuesForMemory = { ...values };
    if ("signal" in valuesForMemory) {
      delete valuesForMemory.signal;
    }
    if ("timeout" in valuesForMemory) {
      delete valuesForMemory.timeout;
    }
    return valuesForMemory;
  }
  /**
   * Invoke the chain with the provided input and returns the output.
   * @param input Input values for the chain run.
   * @param config Optional configuration for the Runnable.
   * @returns Promise that resolves with the output of the chain run.
   */
  async invoke(input, options) {
    const config = (0, import_runnables.ensureConfig)(options);
    const fullValues = await this._formatValues(input);
    const callbackManager_ = import_manager.CallbackManager.configure(
      config?.callbacks,
      this.callbacks,
      config?.tags,
      this.tags,
      config?.metadata,
      this.metadata,
      { verbose: this.verbose }
    );
    const runManager = await callbackManager_?.handleChainStart(
      this.toJSON(),
      fullValues,
      void 0,
      void 0,
      void 0,
      void 0,
      config?.runName
    );
    let outputValues;
    try {
      outputValues = await (fullValues.signal ? Promise.race([
        this._call(fullValues, runManager, config),
        // eslint-disable-next-line promise/param-names
        new Promise((_, reject) => {
          fullValues.signal?.addEventListener("abort", () => {
            reject(
              new import_error.ChatLunaError(import_error.ChatLunaErrorCode.ABORTED)
            );
          });
        })
      ]) : this._call(fullValues, runManager, config));
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    if (!(this.memory == null)) {
      await this.memory.saveContext(
        this._selectMemoryInputs(input),
        outputValues
      );
    }
    await runManager?.handleChainEnd(outputValues);
    Object.defineProperty(outputValues, import_outputs.RUN_KEY, {
      value: runManager ? { runId: runManager?.runId } : void 0,
      configurable: true
    });
    return outputValues;
  }
  _validateOutputs(outputs) {
    const missingKeys = this.outputKeys.filter((k) => !(k in outputs));
    if (missingKeys.length) {
      throw new Error(
        `Missing output keys: ${missingKeys.join(
          ", "
        )} from chain ${this._chainType()}`
      );
    }
  }
  async prepOutputs(inputs, outputs, returnOnlyOutputs = false) {
    this._validateOutputs(outputs);
    if (this.memory) {
      await this.memory.saveContext(inputs, outputs);
    }
    if (returnOnlyOutputs) {
      return outputs;
    }
    return { ...inputs, ...outputs };
  }
  /**
   * Return a json-like object representing this chain.
   */
  serialize() {
    throw new Error("Method not implemented.");
  }
  async _formatValues(values) {
    const fullValues = { ...values };
    if (fullValues.timeout && !fullValues.signal) {
      fullValues.signal = AbortSignal.timeout(fullValues.timeout);
      delete fullValues.timeout;
    }
    if (!(this.memory == null)) {
      const newValues = await this.memory.loadMemoryVariables(
        this._selectMemoryInputs(values)
      );
      for (const [key, value] of Object.entries(newValues)) {
        fullValues[key] = value;
      }
    }
    return fullValues;
  }
  /**
   * Load a chain from a json-like object describing it.
   */
  static async deserialize(data, values = {}) {
    throw new Error("Method not implemented.");
  }
};
var ChatLunaLLMChain = class extends BaseChain {
  static {
    __name(this, "ChatLunaLLMChain");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  lc_serializable = false;
  prompt;
  llm;
  outputKey = "text";
  llmKwargs;
  get inputKeys() {
    return this.prompt.inputVariables;
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(fields) {
    super(fields);
    this.prompt = fields.prompt;
    this.llm = fields.llm;
    this.memory = fields.memory;
    this.outputKey = fields.outputKey ?? this.outputKey;
    this.llmKwargs = fields.llmKwargs;
  }
  /** @ignore */
  async _call(values, runManager) {
    const valuesForPrompt = { ...values };
    const valuesForLLM = {
      ...this.llmKwargs
    };
    for (const key of this.llm.callKeys) {
      if (key in values) {
        valuesForLLM[key] = values[key];
        delete valuesForPrompt[key];
      }
    }
    const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);
    const { generations } = await this.llm.generatePrompt(
      [promptValue],
      valuesForLLM,
      runManager?.getChild()
    );
    const generation = generations[0][0];
    return {
      [this.outputKey]: generation.text,
      rawGeneration: generation,
      message: generation.message,
      extra: generation?.generationInfo
    };
  }
  /** @ignore */
  _selectMemoryInputs(values) {
    const valuesForMemory = this._selectMemoryInputs(values);
    for (const key of this.llm.callKeys) {
      if (key in values) {
        delete valuesForMemory[key];
      }
    }
    return valuesForMemory;
  }
  _chainType() {
    return "chatluna_chain";
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
};
async function callChatLunaChain(chain, values, events) {
  let usedToken = 0;
  const response = await chain.invoke(values, {
    callbacks: [
      {
        handleLLMNewToken(token) {
          events?.["llm-new-token"]?.(token);
        },
        handleLLMEnd(output, runId, parentRunId, tags) {
          usedToken += output.llmOutput?.tokenUsage?.totalTokens ?? 0;
        }
      }
    ]
  });
  await events?.["llm-used-token-count"](usedToken);
  return response;
}
__name(callChatLunaChain, "callChatLunaChain");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseChain,
  ChatLunaLLMChain,
  ChatLunaLLMChainWrapper,
  callChatLunaChain
});
