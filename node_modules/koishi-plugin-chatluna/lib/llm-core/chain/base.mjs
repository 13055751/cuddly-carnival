var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/llm-core/chain/base.ts
import {
  CallbackManager
} from "@langchain/core/callbacks/manager";
import { ensureConfig } from "@langchain/core/runnables";
import {
  ChatLunaError,
  ChatLunaErrorCode
} from "koishi-plugin-chatluna/utils/error";
import {
  BaseLangChain
} from "@langchain/core/language_models/base";
import { RUN_KEY } from "@langchain/core/outputs";
var ChatLunaLLMChainWrapper = class {
  static {
    __name(this, "ChatLunaLLMChainWrapper");
  }
};
var BaseChain = class extends BaseLangChain {
  static {
    __name(this, "BaseChain");
  }
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
  constructor(fields, verbose, callbacks) {
    if (arguments.length === 1 && typeof fields === "object" && !("saveContext" in fields)) {
      const { memory, callbackManager, ...rest } = fields;
      super({ ...rest, callbacks: callbackManager ?? rest.callbacks });
      this.memory = memory;
    } else {
      super({ verbose, callbacks });
      this.memory = fields;
    }
  }
  /** @ignore */
  _selectMemoryInputs(values) {
    const valuesForMemory = { ...values };
    if ("signal" in valuesForMemory) {
      delete valuesForMemory.signal;
    }
    if ("timeout" in valuesForMemory) {
      delete valuesForMemory.timeout;
    }
    return valuesForMemory;
  }
  /**
   * Invoke the chain with the provided input and returns the output.
   * @param input Input values for the chain run.
   * @param config Optional configuration for the Runnable.
   * @returns Promise that resolves with the output of the chain run.
   */
  async invoke(input, options) {
    const config = ensureConfig(options);
    const fullValues = await this._formatValues(input);
    const callbackManager_ = CallbackManager.configure(
      config?.callbacks,
      this.callbacks,
      config?.tags,
      this.tags,
      config?.metadata,
      this.metadata,
      { verbose: this.verbose }
    );
    const runManager = await callbackManager_?.handleChainStart(
      this.toJSON(),
      fullValues,
      void 0,
      void 0,
      void 0,
      void 0,
      config?.runName
    );
    let outputValues;
    try {
      outputValues = await (fullValues.signal ? Promise.race([
        this._call(fullValues, runManager, config),
        // eslint-disable-next-line promise/param-names
        new Promise((_, reject) => {
          fullValues.signal?.addEventListener("abort", () => {
            reject(
              new ChatLunaError(ChatLunaErrorCode.ABORTED)
            );
          });
        })
      ]) : this._call(fullValues, runManager, config));
    } catch (e) {
      await runManager?.handleChainError(e);
      throw e;
    }
    if (!(this.memory == null)) {
      await this.memory.saveContext(
        this._selectMemoryInputs(input),
        outputValues
      );
    }
    await runManager?.handleChainEnd(outputValues);
    Object.defineProperty(outputValues, RUN_KEY, {
      value: runManager ? { runId: runManager?.runId } : void 0,
      configurable: true
    });
    return outputValues;
  }
  _validateOutputs(outputs) {
    const missingKeys = this.outputKeys.filter((k) => !(k in outputs));
    if (missingKeys.length) {
      throw new Error(
        `Missing output keys: ${missingKeys.join(
          ", "
        )} from chain ${this._chainType()}`
      );
    }
  }
  async prepOutputs(inputs, outputs, returnOnlyOutputs = false) {
    this._validateOutputs(outputs);
    if (this.memory) {
      await this.memory.saveContext(inputs, outputs);
    }
    if (returnOnlyOutputs) {
      return outputs;
    }
    return { ...inputs, ...outputs };
  }
  /**
   * Return a json-like object representing this chain.
   */
  serialize() {
    throw new Error("Method not implemented.");
  }
  async _formatValues(values) {
    const fullValues = { ...values };
    if (fullValues.timeout && !fullValues.signal) {
      fullValues.signal = AbortSignal.timeout(fullValues.timeout);
      delete fullValues.timeout;
    }
    if (!(this.memory == null)) {
      const newValues = await this.memory.loadMemoryVariables(
        this._selectMemoryInputs(values)
      );
      for (const [key, value] of Object.entries(newValues)) {
        fullValues[key] = value;
      }
    }
    return fullValues;
  }
  /**
   * Load a chain from a json-like object describing it.
   */
  static async deserialize(data, values = {}) {
    throw new Error("Method not implemented.");
  }
};
var ChatLunaLLMChain = class extends BaseChain {
  static {
    __name(this, "ChatLunaLLMChain");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  lc_serializable = false;
  prompt;
  llm;
  outputKey = "text";
  llmKwargs;
  get inputKeys() {
    return this.prompt.inputVariables;
  }
  get outputKeys() {
    return [this.outputKey];
  }
  constructor(fields) {
    super(fields);
    this.prompt = fields.prompt;
    this.llm = fields.llm;
    this.memory = fields.memory;
    this.outputKey = fields.outputKey ?? this.outputKey;
    this.llmKwargs = fields.llmKwargs;
  }
  /** @ignore */
  async _call(values, runManager) {
    const valuesForPrompt = { ...values };
    const valuesForLLM = {
      ...this.llmKwargs
    };
    for (const key of this.llm.callKeys) {
      if (key in values) {
        valuesForLLM[key] = values[key];
        delete valuesForPrompt[key];
      }
    }
    const promptValue = await this.prompt.formatPromptValue(valuesForPrompt);
    const { generations } = await this.llm.generatePrompt(
      [promptValue],
      valuesForLLM,
      runManager?.getChild()
    );
    const generation = generations[0][0];
    return {
      [this.outputKey]: generation.text,
      rawGeneration: generation,
      message: generation.message,
      extra: generation?.generationInfo
    };
  }
  /** @ignore */
  _selectMemoryInputs(values) {
    const valuesForMemory = this._selectMemoryInputs(values);
    for (const key of this.llm.callKeys) {
      if (key in values) {
        delete valuesForMemory[key];
      }
    }
    return valuesForMemory;
  }
  _chainType() {
    return "chatluna_chain";
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  get lc_namespace() {
    return ["langchain", "chains", this._chainType()];
  }
};
async function callChatLunaChain(chain, values, events) {
  let usedToken = 0;
  const response = await chain.invoke(values, {
    callbacks: [
      {
        handleLLMNewToken(token) {
          events?.["llm-new-token"]?.(token);
        },
        handleLLMEnd(output, runId, parentRunId, tags) {
          usedToken += output.llmOutput?.tokenUsage?.totalTokens ?? 0;
        }
      }
    ]
  });
  await events?.["llm-used-token-count"](usedToken);
  return response;
}
__name(callChatLunaChain, "callChatLunaChain");
export {
  BaseChain,
  ChatLunaLLMChain,
  ChatLunaLLMChainWrapper,
  callChatLunaChain
};
