var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/llm-core/chain/prompt.ts
var prompt_exports = {};
__export(prompt_exports, {
  ChatLunaChatPrompt: () => ChatLunaChatPrompt
});
module.exports = __toCommonJS(prompt_exports);
var import_messages = require("@langchain/core/messages");
var import_prompts = require("@langchain/core/prompts");
var import_count_tokens = require("koishi-plugin-chatluna/llm-core/utils/count_tokens");
var import_koishi_plugin_chatluna = require("koishi-plugin-chatluna");
var import_koishi = require("koishi");
var import_string = require("koishi-plugin-chatluna/utils/string");
var ChatLunaChatPrompt = class _ChatLunaChatPrompt extends import_prompts.BaseChatPromptTemplate {
  static {
    __name(this, "ChatLunaChatPrompt");
  }
  getPreset;
  tokenCounter;
  conversationSummaryPrompt;
  _tempPreset;
  sendTokenLimit;
  variableService;
  partialVariables = {};
  _systemPrompts;
  fields;
  constructor(fields) {
    super({
      inputVariables: [
        "chat_history",
        "variables",
        "input",
        "agent_scratchpad",
        "instructions"
      ]
    });
    this.partialVariables = fields.partialVariables;
    this.tokenCounter = fields.tokenCounter;
    this.sendTokenLimit = fields.sendTokenLimit ?? 4096;
    this.getPreset = fields.preset;
    this.variableService = fields.variableService;
    this.fields = fields;
  }
  _getPromptType() {
    return "chatluna_chat";
  }
  async _countMessageTokens(message) {
    let content = (0, import_string.getMessageContent)(message.content);
    if (content.includes("![image]") && content.includes("base64") && message.additional_kwargs?.["images"]) {
      content = content.replaceAll(/!\[.*?\]\(.*?\)/g, "");
      message.content = content;
    }
    let result = await this.tokenCounter((0, import_string.getMessageContent)(message.content)) + await this.tokenCounter(
      (0, import_count_tokens.messageTypeToOpenAIRole)(message.getType())
    );
    if (message.name) {
      result += await this.tokenCounter(message.name);
    }
    return result;
  }
  async _formatSystemPrompts(variables) {
    const preset = await this.getPreset();
    if (!this._tempPreset || this._tempPreset[0] !== preset) {
      this.conversationSummaryPrompt = import_prompts.SystemMessagePromptTemplate.fromTemplate(
        preset.config.longMemoryPrompt ?? // eslint-disable-next-line max-len
        `Relevant context: {long_history}

Guidelines for response:
1. Use the system prompt as your primary guide.
2. Incorporate the provided context if relevant, but don't force its inclusion.
3. Generate thoughtful, creative, and diverse responses.
4. Avoid repetition and expand your perspective.

Your goal is to craft an insightful, engaging response that seamlessly integrates all relevant information while maintaining coherence and originality.`
      );
    }
    const result = await this.variableService.formatPresetTemplate(
      preset,
      variables,
      true
    );
    this._tempPreset = [preset, result];
    return result;
  }
  async formatMessages({
    chat_history: chatHistory,
    input,
    variables,
    agent_scratchpad: agentScratchpad,
    instructions
  }) {
    const result = [];
    let usedTokens = 0;
    instructions = instructions ?? (typeof this.partialVariables?.instructions === "function" ? await this.partialVariables.instructions() : this.partialVariables?.instructions);
    const [systemPrompts] = await this._formatSystemPrompts(variables);
    this._systemPrompts = systemPrompts;
    for (const message of systemPrompts || []) {
      const messageTokens = await this._countMessageTokens(message);
      result.push(message);
      usedTokens += messageTokens;
    }
    if (instructions) {
      for (const message of [new import_messages.SystemMessage(instructions)]) {
        const messageTokens = await this._countMessageTokens(message);
        result.push(message);
        usedTokens += messageTokens;
      }
    }
    const inputTokens = await this.tokenCounter(
      (0, import_string.getMessageContent)(input.content)
    );
    const longHistory = variables?.["long_memory"] ?? [];
    const knowledge = variables?.["knowledge"] ?? [];
    const otherDocuments = variables?.["documents"] ?? [];
    const loreBooks = variables?.["lore_books"] ?? [];
    const authorsNote = variables?.["authors_note"];
    const [formatAuthorsNote, usedTokensAuthorsNote] = authorsNote && (authorsNote.content?.length ?? 0) > 0 ? await this._counterAuthorsNote(authorsNote, variables) : [null, 0];
    usedTokens += inputTokens;
    if (usedTokensAuthorsNote > 0) {
      usedTokens += usedTokensAuthorsNote;
    }
    if (agentScratchpad) {
      if (Array.isArray(agentScratchpad)) {
        usedTokens += await agentScratchpad.reduce(
          async (accPromise, message) => {
            const acc = await accPromise;
            const messageTokens = await this._countMessageTokens(message);
            return acc + messageTokens;
          },
          Promise.resolve(0)
        );
      } else {
        if (typeof agentScratchpad === "string") {
          agentScratchpad = new import_messages.HumanMessage(agentScratchpad);
        }
        usedTokens += await this._countMessageTokens(agentScratchpad);
      }
    }
    const formatResult = await this._formatWithMessagesPlaceholder(
      chatHistory,
      [longHistory, knowledge].concat(
        Array.isArray(otherDocuments[0]) ? otherDocuments : [otherDocuments]
      ),
      usedTokens
    );
    result.push(...formatResult.messages);
    usedTokens = formatResult.usedTokens;
    if (loreBooks.length > 0) {
      usedTokens += await this._formatLoreBooks(
        loreBooks,
        usedTokens,
        result,
        variables
      );
    }
    result.push(input);
    if (formatAuthorsNote) {
      usedTokens = this._formatAuthorsNote(authorsNote, result, [
        formatAuthorsNote,
        usedTokensAuthorsNote
      ]);
    }
    if (agentScratchpad) {
      if (Array.isArray(agentScratchpad)) {
        result.push(...agentScratchpad);
      } else {
        result.push(agentScratchpad);
      }
    }
    if (import_koishi_plugin_chatluna.logger?.level === import_koishi.Logger.DEBUG) {
      import_koishi_plugin_chatluna.logger?.debug(
        `Used tokens: ${usedTokens} exceed limit: ${this.sendTokenLimit}`
      );
      const mapMessages = result.map((msg) => {
        const original = msg?.toDict?.();
        if (original == null) {
          return msg;
        }
        const dict = structuredClone(original);
        if (dict.data == null) {
          return dict;
        }
        delete dict.data.additional_kwargs["images"];
        delete dict.data.additional_kwargs["preset"];
        return dict;
      });
      import_koishi_plugin_chatluna.logger?.debug(`messages: ${JSON.stringify(mapMessages)})`);
    }
    return result;
  }
  async _formatLoreBooks(loreBooks, usedTokens, result, variables) {
    const preset = this.tempPreset;
    const tokenLimit = this.sendTokenLimit - usedTokens - (preset.loreBooks?.tokenLimit ?? 300);
    let usedToken = await this.tokenCounter(
      preset.config.loreBooksPrompt ?? "{input}"
    );
    const loreBooksPrompt = import_prompts.HumanMessagePromptTemplate.fromTemplate(
      preset.config.loreBooksPrompt ?? "{input}"
    );
    const canUseLoreBooks = {};
    const hasLongMemory = result[result.length - 1].content === "Ok. I will remember.";
    for (const loreBook of loreBooks) {
      if ((loreBook.content?.length ?? 0) === 0) {
        continue;
      }
      const loreBookTokens = await this.tokenCounter(loreBook.content);
      if (usedTokens + loreBookTokens > tokenLimit) {
        import_koishi_plugin_chatluna.logger?.warn(
          `Used tokens: ${usedTokens + loreBookTokens} exceed limit: ${tokenLimit}. Is too long lore books. Skipping.`
        );
        break;
      }
      const position = loreBook.insertPosition ?? "default";
      const array = canUseLoreBooks[position] ?? [];
      array.push(loreBook.content);
      canUseLoreBooks[position] = array;
      usedToken += loreBookTokens;
    }
    for (const [position, array] of Object.entries(canUseLoreBooks)) {
      const message = await this.variableService.formatMessages(
        [await loreBooksPrompt.format({ input: array.join("\n") })],
        variables
      ).then((value) => value[0]);
      if (position === "default") {
        if (hasLongMemory) {
          const index = result.findIndex(
            (msg) => msg instanceof import_messages.AIMessage && msg.content === "Ok. I will remember."
          );
          index !== -1 ? result.splice(index - 1, 0, message) : result.push(message);
        } else {
          result.push(message);
        }
        continue;
      }
      const insertPosition = this._findIndex(
        result,
        position
      );
      result.splice(insertPosition, 0, message);
    }
    return usedToken;
  }
  async _formatWithMessagesPlaceholder(chatHistory, documents, usedTokens) {
    const result = [];
    for (const message of chatHistory.reverse()) {
      const messageTokens = await this._countMessageTokens(message);
      if (usedTokens + messageTokens > this.sendTokenLimit - (documents.length > 0 ? 480 : 80)) {
        break;
      }
      usedTokens += messageTokens;
      result.unshift(message);
    }
    for (const document of documents) {
      usedTokens = await this._formatLongHistory(
        document,
        result,
        usedTokens,
        result
      );
    }
    return { messages: result, usedTokens };
  }
  async _counterAuthorsNote(authorsNote, variables) {
    const formatAuthorsNote = await this.variableService.formatPresetTemplateString(
      authorsNote.content,
      variables
    );
    return [formatAuthorsNote, await this.tokenCounter(formatAuthorsNote)];
  }
  _formatAuthorsNote(authorsNote, result, [formatAuthorsNote, usedTokens]) {
    const rawPosition = authorsNote.insertPosition ?? "in_chat";
    const insertPosition = this._findIndex(result, rawPosition);
    if (rawPosition === "in_chat") {
      result.splice(
        insertPosition - (authorsNote.insertDepth ?? 0),
        0,
        new import_messages.SystemMessage(formatAuthorsNote)
      );
    } else {
      result.splice(
        insertPosition,
        0,
        new import_messages.SystemMessage(formatAuthorsNote)
      );
    }
    return usedTokens;
  }
  _findIndex(chatHistory, insertPosition) {
    if (insertPosition === "in_chat") {
      return chatHistory.length - 1;
    }
    const findIndexByType = /* @__PURE__ */ __name((type) => chatHistory.findIndex(
      (message) => message?.additional_kwargs?.type === type
    ), "findIndexByType");
    const descriptionIndex = findIndexByType("description");
    const personalityIndex = findIndexByType("description");
    const scenarioIndex = findIndexByType("scenario");
    const exampleMessageStartIndex = findIndexByType(
      "example_message_first"
    );
    const exampleMessageEndIndex = findIndexByType("example_message_last");
    const firstMessageIndex = findIndexByType("first_message");
    const charDefIndex = Math.max(descriptionIndex, personalityIndex);
    switch (insertPosition) {
      case "before_char_defs":
      case "before_char":
        return charDefIndex !== -1 ? charDefIndex : 1;
      case "after_char_defs":
      case "after_char":
        if (scenarioIndex !== -1) return scenarioIndex + 1;
        return charDefIndex !== -1 ? charDefIndex + 1 : this._systemPrompts.length + 1;
      case "before_example_messages":
        if (exampleMessageStartIndex !== -1)
          return exampleMessageStartIndex;
        if (firstMessageIndex !== -1) return firstMessageIndex;
        return charDefIndex !== -1 ? charDefIndex + 1 : 1;
      case "after_example_messages":
        if (exampleMessageEndIndex !== -1)
          return exampleMessageEndIndex + 1;
        return charDefIndex !== -1 ? charDefIndex + 1 : this._systemPrompts.length - 1;
      default:
        return 1;
    }
  }
  async _formatLongHistory(longHistory, chatHistory, usedTokens, result) {
    const formatDocuments = [];
    for (const document of longHistory) {
      if (document.pageContent.length === 0) continue;
      const documentTokens = await this.tokenCounter(document.pageContent);
      if (usedTokens + documentTokens > this.sendTokenLimit - 80) {
        break;
      }
      usedTokens += documentTokens;
      formatDocuments.push(document);
    }
    if (formatDocuments.length < 1) {
      return usedTokens;
    }
    const formatConversationSummary = formatDocuments.length > 0 ? await this.conversationSummaryPrompt.format({
      long_history: formatDocuments.map(
        (document) => document.pageContent + ` metadata: ${JSON.stringify(document.metadata)}`
      ).join("\n"),
      chat_history: chatHistory
    }) : null;
    if (formatConversationSummary) {
      result.push(formatConversationSummary);
    }
    return usedTokens;
  }
  get tempPreset() {
    return this._tempPreset[0];
  }
  async partial(values) {
    const newInputVariables = this.inputVariables.filter(
      (iv) => !(iv in values)
    );
    const newPartialVariables = {
      ...this.partialVariables ?? {},
      ...values
    };
    const promptDict = {
      ...this.fields,
      inputVariables: newInputVariables,
      partialVariables: newPartialVariables
    };
    return new _ChatLunaChatPrompt(promptDict);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  ChatLunaChatPrompt
});
