var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/string.ts
var string_exports = {};
__export(string_exports, {
  PresetPostHandler: () => PresetPostHandler,
  bufferToArrayBuffer: () => bufferToArrayBuffer,
  fetchUrl: () => fetchUrl,
  fuzzyQuery: () => fuzzyQuery,
  getCurrentWeekday: () => getCurrentWeekday,
  getMessageContent: () => getMessageContent,
  getNotEmptyString: () => getNotEmptyString,
  getTimeDiff: () => getTimeDiff,
  getTimeDiffFormat: () => getTimeDiffFormat,
  getTimeInUTC: () => getTimeInUTC,
  gzipDecode: () => gzipDecode,
  gzipEncode: () => gzipEncode,
  hashString: () => hashString,
  rollDice: () => rollDice,
  selectFromList: () => selectFromList
});
module.exports = __toCommonJS(string_exports);
var import_koishi = require("koishi");
var import_zlib = require("zlib");
var import_util = require("util");
var import_request = require("koishi-plugin-chatluna/utils/request");
var gzipAsync = (0, import_util.promisify)(import_zlib.gzip);
var gunzipAsync = (0, import_util.promisify)(import_zlib.gunzip);
function fuzzyQuery(source, keywords) {
  for (const keyword of keywords) {
    const match = source.includes(keyword);
    if (match) {
      return true;
    }
  }
  return false;
}
__name(fuzzyQuery, "fuzzyQuery");
function getMessageContent(message) {
  if (typeof message === "string") {
    return message;
  }
  if (message == null) {
    return "";
  }
  const buffer = [];
  for (const part of message) {
    if (part.type === "text") {
      buffer.push(part.text);
    }
  }
  return buffer.join("");
}
__name(getMessageContent, "getMessageContent");
function getNotEmptyString(...texts) {
  for (const text of texts) {
    if (text && text?.length > 0) {
      return text;
    }
  }
}
__name(getNotEmptyString, "getNotEmptyString");
function getCurrentWeekday() {
  const daysOfWeek = [
    "Sunday",
    "Monday",
    "Tuesday",
    "Wednesday",
    "Thursday",
    "Friday",
    "Saturday"
  ];
  const currentDate = /* @__PURE__ */ new Date();
  return daysOfWeek[currentDate.getDay()];
}
__name(getCurrentWeekday, "getCurrentWeekday");
var getTimeInUTC = /* @__PURE__ */ __name((offset) => {
  const date = /* @__PURE__ */ new Date();
  date.setMinutes(date.getMinutes() + offset * 60);
  return date.toISOString().substring(11, 8);
}, "getTimeInUTC");
var getTimeDiffFormat = /* @__PURE__ */ __name((time1, time2) => {
  const diff = Math.abs(time1 - time2);
  const days = Math.floor(diff / (1e3 * 60 * 60 * 24));
  const hours = Math.floor(diff % (1e3 * 60 * 60 * 24) / (1e3 * 60 * 60));
  const minutes = Math.floor(diff % (1e3 * 60 * 60) / (1e3 * 60));
  const parts = [];
  if (days > 0) parts.push(`${days} day${days > 1 ? "s" : ""}`);
  if (hours > 0) parts.push(`${hours} hour${hours > 1 ? "s" : ""}`);
  if (minutes > 0) parts.push(`${minutes} minute${minutes > 1 ? "s" : ""}`);
  return parts.join(", ") || "now";
}, "getTimeDiffFormat");
var getTimeDiff = /* @__PURE__ */ __name((time1, time2) => {
  return getTimeDiffFormat(
    new Date(time1).getTime(),
    new Date(time2).getTime()
  );
}, "getTimeDiff");
var selectFromList = /* @__PURE__ */ __name((args, isPick) => {
  const items = args.split(",").map((item) => item.trim());
  if (isPick) {
    return items[Math.floor(Math.random() * items.length)];
  }
  return items[Math.floor(Math.random() * items.length)];
}, "selectFromList");
var rollDice = /* @__PURE__ */ __name((formula) => {
  const parts = formula.split("d");
  let count = 1;
  if (parts.length > 1 && !isNaN(Number(parts[0]))) {
    count = parseInt(parts[0], 10);
  }
  const lastPart = parts[parts.length - 1].split("+");
  let add = 0;
  if (lastPart.length > 1 && !isNaN(Number(lastPart[1]))) {
    add = parseInt(lastPart[1], 10);
  }
  const range = !isNaN(Number(lastPart[0])) ? parseInt(lastPart[0], 10) : 1;
  return Math.floor(Math.random() * (count * range - count + 1)) + count + add;
}, "rollDice");
var fetchUrl = /* @__PURE__ */ __name(async (url, method = "GET", body = null, textLength = 1e3) => {
  const response = await (0, import_request.chatLunaFetch)(url, {
    method,
    body
  });
  const text = await response.text();
  if (text.length > textLength) {
    return text.substring(0, textLength);
  }
  return text;
}, "fetchUrl");
var PresetPostHandler = class {
  constructor(ctx, config, object) {
    this.ctx = ctx;
    this.config = config;
    this.prefix = object.prefix;
    this.postfix = object.postfix;
    this.variables = object.variables ?? {};
    this.censor = object.censor;
    this._compileVariables();
  }
  static {
    __name(this, "PresetPostHandler");
  }
  prefix;
  postfix;
  variables;
  censor;
  compiledVariables;
  async handler(session, data) {
    let content = data;
    const variables = {};
    if (this.compiledVariables) {
      for (const [key, value] of Object.entries(this.compiledVariables)) {
        const match = content.match(value);
        if (!match) {
          continue;
        }
        variables[key] = match[1];
      }
    }
    const censor = this.ctx.censor;
    if (censor && (this.config.censor || this.censor)) {
      content = await censor.transform([import_koishi.h.text(content)], session).then((element) => element.join(""));
    }
    let displayContent = content;
    if (this.prefix) {
      const startIndex = content.indexOf(this.prefix);
      if (startIndex !== -1) {
        displayContent = content.substring(
          startIndex + this.prefix.length
        );
      }
    }
    if (this.postfix) {
      const endIndex = displayContent.lastIndexOf(this.postfix);
      if (endIndex !== -1) {
        displayContent = displayContent.substring(0, endIndex);
      }
    }
    return { content, variables, displayContent };
  }
  _compileVariables() {
    if (!this.variables) {
      return;
    }
    this.compiledVariables = {};
    for (const [key, value] of Object.entries(this.variables)) {
      this.compiledVariables[key] = new RegExp(value);
    }
  }
};
async function gzipEncode(text, encoding = "buffer") {
  const buffer = await gzipAsync(text);
  return encoding === "buffer" ? buffer : buffer.toString(encoding);
}
__name(gzipEncode, "gzipEncode");
async function gzipDecode(data, inputEncoding = "base64") {
  const buffer = typeof data === "string" ? Buffer.from(data, inputEncoding) : data;
  return (await gunzipAsync(buffer)).toString("utf8");
}
__name(gzipDecode, "gzipDecode");
function bufferToArrayBuffer(buffer) {
  const arrayBuffer = new ArrayBuffer(buffer.length);
  const view = new Uint8Array(arrayBuffer);
  for (let i = 0; i < buffer.length; i++) {
    view[i] = buffer[i];
  }
  return arrayBuffer;
}
__name(bufferToArrayBuffer, "bufferToArrayBuffer");
async function hashString(text, length = 8) {
  const hash = await crypto.subtle.digest(
    "SHA-256",
    new TextEncoder().encode(text)
  );
  const hashArray = Array.from(new Uint8Array(hash));
  const hashString2 = hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
  return hashString2.substring(0, length);
}
__name(hashString, "hashString");
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PresetPostHandler,
  bufferToArrayBuffer,
  fetchUrl,
  fuzzyQuery,
  getCurrentWeekday,
  getMessageContent,
  getNotEmptyString,
  getTimeDiff,
  getTimeDiffFormat,
  getTimeInUTC,
  gzipDecode,
  gzipEncode,
  hashString,
  rollDice,
  selectFromList
});
