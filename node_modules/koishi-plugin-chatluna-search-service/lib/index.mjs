var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/locales/zh-CN.schema.yml
var require_zh_CN_schema = __commonJS({
  "src/locales/zh-CN.schema.yml"(exports, module) {
    module.exports = { $inner: [{}, { $desc: "搜索服务配置", searchEngine: { $desc: "搜索引擎。" }, topK: "参考结果数量（2-50）。", enhancedSummary: "是否使用增强摘要。", fastEnhancedSummary: "是否使用快速增强摘要。开启后将不调用模型，直接返回搜索结果。（需要上下文较大的模型）", puppeteerTimeout: "Puppeteer 操作超时时间（毫秒）。", puppeteerIdleTimeout: "Puppeteer 空闲超时时间（毫秒）。", summaryModel: "处理摘要和关键词的模型。选择较小并且速度较快的模型可以获得更快的响应速度。", searchConfidenceThreshold: "搜索决策的置信阈值。较高的值意味着更可能进行搜索。", contextualCompression: "是否对搜索结果进行上下文压缩。将会基于选择的摘要模型对搜索结果进行压缩。", summaryType: { $desc: "摘要模式。不同的摘要模式可以提高信息的质量。", $inner: ["性能模式。注重快速的信息获取。", "平衡模式。在信息获取和信息质量之间取得平衡。", "质量模式。注重高信息质量的获取。"] }, searchThreshold: "搜索内容的相似度阈值。", mulitSourceMode: { $desc: "多源模式。", $inner: ["平均模式。将多个来源的搜索结果各取平均个。", "总和模式。将多个来源的搜索结果进行总和后取前 topK 个。"] } }, { $desc: "Serper 设置", serperApiKey: "Serper API 密钥。", serperCountry: "Serper 搜索国家。", serperLocation: "Serper 搜索地区。", serperSearchResults: "Serper 搜索返回结果数量。" }, { $desc: "Bing API 设置", bingSearchApiKey: "Bing API 密钥。", bingSearchLocation: "Bing API 搜索地区。", azureLocation: "Azure API 搜索地区。" }, { $desc: "Tavily 设置", tavilyApiKey: "Tavily API 密钥。" }, { $desc: "免费搜索设置", freeSearchBaseURL: "免费搜索 API 基础 URL。" }, { $desc: "Wikipedia 设置", wikipediaBaseURL: "Wikipedia API 基础 URL。", maxWikipediaDocContentLength: "Wikipedia 文档内容最大长度。" }, { $desc: "SearxNG 设置", searxngBaseURL: "SearxNG API 基础 URL。" }, { $desc: "进阶设置", searchPrompt: "搜索提示词。用于对搜索结果总结的 Prompt。", newQuestionPrompt: "新问题提示词。用于生成新问题的 Prompt。", summaryPrompt: "文档总结提示词。用于总结文档的 Prompt。", searchFailedPrompt: "搜索失败时返回给模型的提示词。为空则不返回。", contextualCompressionPrompt: "上下文压缩提示词。用于压缩搜索结果上下文的 Prompt。" }] };
  }
});

// src/locales/en-US.schema.yml
var require_en_US_schema = __commonJS({
  "src/locales/en-US.schema.yml"(exports, module) {
    module.exports = { $inner: [{}, { $desc: "Search Service Configuration", searchEngine: { $desc: "Search engine" }, topK: "Number of reference results (2-50)", enhancedSummary: "Enable enhanced summary", fastEnhancedSummary: "Enable fast enhanced summary. This will not call the model and directly return the search results. (Requires a larger context model)", puppeteerTimeout: "Puppeteer operation timeout (ms)", puppeteerIdleTimeout: "Puppeteer idle timeout (ms)", contextualCompression: "Enable contextual compression. Will compress the search results based on the selected summary model.", summaryModel: "Model used for generating summaries. Opting for a smaller and faster model can yield quicker responses.", summaryType: { $desc: "Summary mode. Different summary modes can improve the quality of information.", $inner: ["Performance mode. Focuses on quick information retrieval.", "Balanced mode. Strikes a balance between information retrieval and information quality.", "Quality mode. Focuses on obtaining high-quality information."] }, searchThreshold: "Similarity threshold for search content. Higher values mean more likely to search." }, { $desc: "Serper Settings", serperApiKey: "Serper API key", serperCountry: "Serper search country", serperLocation: "Serper search location", serperSearchResults: "Number of Serper search results" }, { $desc: "Bing API Settings", bingSearchApiKey: "Bing API key", bingSearchLocation: "Bing API search location", azureLocation: "Azure API search location" }, { $desc: "Tavily Settings", tavilyApiKey: "Tavily API key" }, { $desc: "Free Search Settings", freeSearchBaseURL: "Free search API base URL" }, { $desc: "Wikipedia Settings", wikipediaBaseURL: "Wikipedia API base URL", maxWikipediaDocContentLength: "Wikipedia document content maximum length" }, { $desc: "SearxNG Settings", searxngBaseURL: "SearxNG API base URL" }, { $desc: "Advanced Settings", searchPrompt: "Search prompt. Used for summarizing search results.", newQuestionPrompt: "New question prompt. Used for generating new questions.", summaryPrompt: "Summary prompt. Used for summarizing documents.", searchFailedPrompt: "Prompt returned to the model when search fails. If empty, nothing is returned.", contextualCompressionPrompt: "Contextual compression prompt. Used for compressing search results based on the selected summary model." }] };
  }
});

// src/index.ts
import { Schema as Schema12, Time } from "koishi";
import { ChatLunaPlugin } from "koishi-plugin-chatluna/services/chat";
import { createLogger } from "koishi-plugin-chatluna/utils/logger";

// src/chain/browsing_chain.ts
import {
  AIMessage,
  SystemMessage
} from "@langchain/core/messages";
import { PromptTemplate } from "@langchain/core/prompts";
import {
  callChatLunaChain,
  ChatLunaLLMChain,
  ChatLunaLLMChainWrapper
} from "koishi-plugin-chatluna/llm-core/chain/base";
import { ChatLunaChatPrompt } from "koishi-plugin-chatluna/llm-core/chain/prompt";

// src/utils/parse.ts
function preprocessContent(content) {
  content = content.replace(
    /```(?:json|javascript|js)?\s*([\s\S]*?)```/g,
    "$1"
  );
  content = content.trim();
  return content;
}
__name(preprocessContent, "preprocessContent");
function attemptToFixJSON(content) {
  let fixedContent = content;
  fixedContent = fixedContent.replace(
    /(\{|\,)\s*([a-zA-Z0-9_]+)\s*\:/g,
    '$1"$2":'
  );
  fixedContent = fixedContent.replace(/(\{|\,)\s*'([^']+)'\s*\:/g, '$1"$2":');
  fixedContent = fixedContent.replace(/\:\s*'([^']+)'/g, ':"$1"');
  fixedContent = fixedContent.replace(/"\s*\}\s*"/g, '","');
  fixedContent = fixedContent.replace(/"\s*\{\s*"/g, '",{"');
  fixedContent = fixedContent.replace(/,\s*\}/g, "}");
  fixedContent = fixedContent.replace(/,\s*\]/g, "]");
  if (fixedContent.includes("[") && !fixedContent.includes("]")) {
    fixedContent += "]";
  }
  if (fixedContent.includes("{") && !fixedContent.includes("}")) {
    fixedContent += "}";
  }
  if (!fixedContent.trim().startsWith("[") && fixedContent.includes("[")) {
    const arrayMatch = fixedContent.match(/\[([\s\S]*)\]/);
    if (arrayMatch && arrayMatch[0]) {
      fixedContent = arrayMatch[0];
    }
  }
  return fixedContent;
}
__name(attemptToFixJSON, "attemptToFixJSON");
function removeProperty(value, properties) {
  const propertySet = new Set(properties);
  const result = {};
  for (const [key, val] of Object.entries(value)) {
    if (!propertySet.has(key)) {
      result[key] = val;
    }
  }
  return result;
}
__name(removeProperty, "removeProperty");

// src/chain/browsing_chain.ts
import {
  ChatLunaError,
  ChatLunaErrorCode
} from "koishi-plugin-chatluna/utils/error";
import { getMessageContent } from "koishi-plugin-chatluna/utils/string";
var ChatLunaBrowsingChain = class _ChatLunaBrowsingChain extends ChatLunaLLMChainWrapper {
  static {
    __name(this, "ChatLunaBrowsingChain");
  }
  botName;
  embeddings;
  chain;
  historyMemory;
  preset;
  formatQuestionChain;
  contextualCompressionChain;
  tools;
  newQuestionPrompt;
  responsePrompt;
  summaryType;
  summaryModel;
  contextualCompressionPrompt;
  variableService;
  thoughtMessage;
  searchPrompt;
  searchFailedPrompt;
  constructor({
    botName,
    embeddings,
    historyMemory,
    chain,
    searchFailedPrompt,
    tools,
    formatQuestionChain,
    summaryType,
    thoughtMessage,
    searchPrompt,
    summaryModel,
    contextualCompressionChain
  }) {
    super();
    this.botName = botName;
    this.embeddings = embeddings;
    this.summaryType = summaryType;
    this.formatQuestionChain = formatQuestionChain;
    this.historyMemory = historyMemory;
    this.thoughtMessage = thoughtMessage;
    this.searchFailedPrompt = searchFailedPrompt;
    this.responsePrompt = PromptTemplate.fromTemplate(searchPrompt);
    this.chain = chain;
    this.tools = tools;
    this.contextualCompressionChain = contextualCompressionChain;
    this.summaryModel = summaryModel;
  }
  static fromLLMAndTools(llm, tools, {
    botName,
    embeddings,
    summaryModel,
    historyMemory,
    preset,
    thoughtMessage,
    searchPrompt,
    newQuestionPrompt,
    summaryType,
    searchFailedPrompt,
    variableService,
    contextualCompressionPrompt
  }) {
    const prompt = new ChatLunaChatPrompt({
      preset,
      tokenCounter: /* @__PURE__ */ __name((text) => llm.getNumTokens(text), "tokenCounter"),
      sendTokenLimit: llm.invocationParams().maxTokenLimit ?? llm.getModelMaxContextSize(),
      variableService
    });
    const chain = new ChatLunaLLMChain({ llm, prompt });
    const formatQuestionChain = new ChatLunaLLMChain({
      llm: summaryModel,
      prompt: PromptTemplate.fromTemplate(newQuestionPrompt)
    });
    const contextualCompressionChain = contextualCompressionPrompt ? new ChatLunaLLMChain({
      llm: summaryModel,
      prompt: PromptTemplate.fromTemplate(
        contextualCompressionPrompt
      )
    }) : void 0;
    return new _ChatLunaBrowsingChain({
      variableService,
      botName,
      formatQuestionChain,
      embeddings,
      summaryModel,
      historyMemory,
      preset,
      thoughtMessage,
      searchFailedPrompt,
      searchPrompt,
      newQuestionPrompt,
      chain,
      tools,
      summaryType,
      contextualCompressionChain
    });
  }
  async _selectTool(name2) {
    const chatLunaTool = this.tools.find((tool) => tool.name === name2);
    return chatLunaTool.tool.createTool({
      embeddings: this.embeddings,
      model: this.summaryModel ?? this.chain.llm
    });
  }
  async call({
    message,
    stream,
    events,
    conversationId,
    session,
    variables,
    maxToken,
    signal
  }) {
    const requests = {
      input: message
    };
    let chatHistory = (await this.historyMemory.loadMemoryVariables(requests))[this.historyMemory.memoryKey];
    chatHistory = chatHistory.slice();
    requests["chat_history"] = chatHistory;
    requests["id"] = conversationId;
    requests["variables"] = variables ?? {};
    const newQuestion = (await callChatLunaChain(
      this.formatQuestionChain,
      {
        chat_history: formatChatHistoryAsString(
          chatHistory.slice(-6)
        ),
        time: (/* @__PURE__ */ new Date()).toLocaleString(),
        question: message.content,
        temperature: 0,
        signal
      },
      {
        "llm-used-token-count": events["llm-used-token-count"]
      }
    ))["text"];
    const searchAction = this.parseSearchAction(newQuestion);
    logger?.debug(`action: ${JSON.stringify(searchAction)}`);
    if (searchAction != null && searchAction.action !== "skip") {
      await this._search(
        searchAction,
        message,
        chatHistory,
        session,
        events,
        signal
      );
    }
    const finalResponse = await callChatLunaChain(
      this.chain,
      {
        ...requests,
        stream,
        signal,
        maxTokens: maxToken
      },
      events
    );
    logger?.debug(`final response %c`, finalResponse.text);
    const aiMessage = finalResponse?.message ?? new AIMessage(finalResponse.text);
    return {
      message: aiMessage
    };
  }
  parseSearchAction(action) {
    action = preprocessContent(action);
    try {
      return JSON.parse(action);
    } catch (e) {
      action = attemptToFixJSON(action);
      try {
        return JSON.parse(action);
      } catch (e2) {
        logger?.error(`parse search action failed: ${e2}`);
      }
    }
    if (action.includes("[skip]")) {
      return {
        action: "skip",
        thought: "skip the search"
      };
    }
    return {
      action: "search",
      thought: action,
      content: [action]
    };
  }
  async _search(action, message, chatHistory, session, events, signal) {
    const searchTool = await this._selectTool("web-search");
    const webBrowserTool = await this._selectTool(
      "web-browser"
    );
    const searchResults = [];
    if (!Array.isArray(action.content)) {
      logger?.error(
        `search action content is not an array: ${JSON.stringify(action)}`
      );
      return;
    }
    if (this.thoughtMessage) {
      await session.send(
        `Search Action: ${action.action}
Thought: ${action.thought}
Content: ${action.content.join("\n")}`
      );
    }
    const searchByQuestion = /* @__PURE__ */ __name(async (question, signal2) => {
      const rawSearchResults = await Promise.race([
        searchTool.invoke(question).then((text) => text),
        new Promise((resolve, reject) => {
          signal2?.addEventListener("abort", (event) => {
            reject(new ChatLunaError(ChatLunaErrorCode.ABORTED));
          });
        })
      ]);
      const parsedSearchResults = JSON.parse(rawSearchResults) ?? [];
      if (this.thoughtMessage) {
        await session.send(
          `Find ${parsedSearchResults.length} search results about ${question}.`
        );
      }
      searchResults.push(...parsedSearchResults);
    }, "searchByQuestion");
    const searchByUrl = /* @__PURE__ */ __name(async (url, signal2) => {
      const text = await Promise.race([
        webBrowserTool.invoke({
          action: "text",
          url
        }).then((text2) => text2),
        new Promise((resolve, reject) => {
          signal2?.addEventListener("abort", (event) => {
            reject(new ChatLunaError(ChatLunaErrorCode.ABORTED));
          });
        })
      ]);
      if (this.thoughtMessage) {
        await session.send(`Open ${url} and read the content.`);
      }
      searchResults.push({
        title: url,
        description: text,
        url
      });
    }, "searchByUrl");
    if (action.action === "url") {
      await Promise.race([
        Promise.all(
          action.content.map((url) => searchByUrl(url, signal))
        ),
        new Promise((resolve, reject) => {
          signal?.addEventListener("abort", (event) => {
            reject(new ChatLunaError(ChatLunaErrorCode.ABORTED));
          });
        })
      ]);
    } else if (action.action === "search") {
      await Promise.race([
        Promise.all(
          action.content.map(
            (question) => searchByQuestion(question, signal)
          )
        ),
        new Promise((resolve, reject) => {
          signal?.addEventListener("abort", (event) => {
            reject(new ChatLunaError(ChatLunaErrorCode.ABORTED));
          });
        })
      ]);
    }
    const formattedSearchResults = searchResults.map((result) => {
      let resultString = "";
      for (const key in result) {
        resultString += `${key}: ${result[key]}, `;
      }
      resultString = resultString.slice(0, -2);
      return resultString;
    });
    let responsePrompt = "";
    if (formattedSearchResults?.length > 0) {
      let formattedSearchResult = formattedSearchResults.join("\n\n");
      if (this.contextualCompressionChain) {
        try {
          formattedSearchResult = (await callChatLunaChain(
            this.contextualCompressionChain,
            {
              action: JSON.stringify(action),
              context: formattedSearchResult,
              temperature: 0,
              signal
            },
            {
              "llm-used-token-count": events["llm-used-token-count"]
            }
          ))["text"];
          console.log(formattedSearchResult);
        } catch (e) {
          logger?.error(`contextual compression failed: ${e}`);
        }
      }
      responsePrompt = await this.responsePrompt.format({
        question: message.content,
        context: formattedSearchResult
      });
      chatHistory.push(new SystemMessage(responsePrompt));
      chatHistory.push(
        new AIMessage(
          "OK. I understand. I will respond to the your's question using the same language as your input. What's the your's question?"
        )
      );
    } else if (this.searchFailedPrompt?.length > 0) {
      chatHistory.push(
        new SystemMessage(
          this.searchFailedPrompt.replaceAll(
            "{question}",
            getMessageContent(message.content)
          )
        )
      );
    }
    await webBrowserTool.closeBrowser();
    return responsePrompt;
  }
  get model() {
    return this.chain.llm;
  }
};
var formatChatHistoryAsString = /* @__PURE__ */ __name((history) => {
  return history.map((message) => `${message.getType()}: ${message.content}`).join("\n");
}, "formatChatHistoryAsString");

// src/tools/puppeteerBrowserTool.ts
import { StructuredTool } from "@langchain/core/tools";
import { z } from "zod";
import { LRUCache } from "lru-cache";
import { getMessageContent as getMessageContent2 } from "koishi-plugin-chatluna/utils/string";
var PuppeteerBrowserTool = class extends StructuredTool {
  static {
    __name(this, "PuppeteerBrowserTool");
  }
  name = "web_browser";
  description = `A powerful tool designed for seamless web browsing.
    Available actions:
    - open [url]: Open a web page (required first action)
    - summarize [search_text?]: Simple summarize the current page, optionally with a search text.
    - text [search_text?]: Get the content of the current page, optionally with a search text
    - select [selector]: Select content from a specific div
    - previous: Go to the previous page
    - get-html: Get the HTML content of the current page
    - get-structured-urls: Get structured URLs from the current page
    Every action must be input with the URL of the page. Like this: {{
        action: 'summarize',
        params: 'xxx',
        url: 'https://example.com'
    }}
    After using this tool, you must process the result before considering using it again in the next turn.`;
  pages;
  lastActionTime = Date.now();
  timeout = 3e4;
  // 30 seconds timeout
  idleTimeout = 18e4;
  // 5 minutes idle timeout
  model;
  ctx;
  waitUntil;
  disposables = [];
  schema = z.object({
    action: z.string().describe("The action to perform"),
    params: z.string().optional().describe("The parameters for the action"),
    url: z.string().optional().describe("The URL to action on")
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  });
  actions = {
    open: this.openPage.bind(this),
    summarize: this.summarizePage.bind(this),
    text: this.getPageText.bind(this),
    select: this.selectDiv.bind(this),
    previous: this.goToPreviousPage.bind(this),
    "get-html": this.getHtml.bind(this),
    "get-structured-urls": this.getStructuredUrls.bind(this)
  };
  constructor(ctx, model, embeddings, options = {}) {
    super();
    this.ctx = ctx;
    this.model = model;
    this.timeout = options.timeout || this.timeout;
    this.idleTimeout = options.idleTimeout || this.idleTimeout;
    this.pages = new LRUCache({
      max: 20,
      dispose: /* @__PURE__ */ __name((value, key, reason) => {
        value.close().catch((err) => {
          this.ctx.logger.error(
            `Error closing page ${key}: ${err.message}`
          );
        });
      }, "dispose")
    });
    this.waitUntil = options.waitUntil || this.waitUntil;
  }
  async _call(input) {
    this.startIdleTimer();
    try {
      const { action, params, url } = input;
      this.lastActionTime = Date.now();
      if (this.actions[action]) {
        return await this.actions[action](url, params);
      } else {
        return `Unknown action: ${action}. Available actions: ${Object.keys(this.actions).join(", ")}`;
      }
    } catch (error) {
      if (error instanceof Error) {
        return `Error: ${error.message}`;
      }
      return "An unknown error occurred";
    }
  }
  async getPage(url) {
    if (!this.pages.has(url)) {
      const puppeteer = this.ctx.puppeteer;
      if (!puppeteer) {
        throw new Error("Puppeteer service is not available");
      }
      const page = await puppeteer.page();
      await page.goto(url, {
        waitUntil: this.waitUntil,
        timeout: this.timeout
      });
      this.pages.set(url, page);
    } else {
      this.pages.get(url);
    }
    return this.pages.get(url);
  }
  async openPage(url, params) {
    try {
      await this.getPage(url ?? params);
      return "Page opened successfully";
    } catch (error) {
      console.error(error);
      return `Error opening page: ${error.message}`;
    }
  }
  async summarizePage(url, searchText) {
    try {
      const text = await this.getPageText(url);
      if (text.includes("Error getting page text")) {
        return text;
      }
      return this.summarizeText(text, searchText);
    } catch (error) {
      console.error(error);
      return `Error summarizing page: ${error.message}`;
    }
  }
  async getPageText(url, searchText) {
    try {
      const page = await this.getPage(url);
      if (!page) return "No page is open, please use open action first";
      const text = await page.evaluate(() => {
        window["__name"] = (func) => func;
        const findMainContent = /* @__PURE__ */ __name(() => {
          const candidates = [];
          const getTextDensity = /* @__PURE__ */ __name((element) => {
            const text2 = element.textContent || "";
            const html = element.innerHTML;
            return text2.length / (html.length || 1);
          }, "getTextDensity");
          const isBoilerplate = /* @__PURE__ */ __name((element) => {
            const className = element.className.toLowerCase();
            const id = element.id.toLowerCase();
            return /nav|header|footer|sidebar|comment|menu|copyright|related|recommend|advertisement|ad-|social|share/i.test(
              `${className} ${id}`
            );
          }, "isBoilerplate");
          const getParagraphScore = /* @__PURE__ */ __name((node) => {
            let value = 0;
            for (const child of Array.from(node.children)) {
              if (child.tagName.toLowerCase() === "p") {
                const text2 = child.textContent || "";
                value += text2.trim().length;
              } else {
                value += getParagraphScore(child) * 0.5;
              }
            }
            return value;
          }, "getParagraphScore");
          const getTableScore = /* @__PURE__ */ __name((node) => {
            let score = 0;
            const rows = node.querySelectorAll("tr").length;
            const cells = node.querySelectorAll("td, th").length;
            if (rows > 0 && cells > 0) {
              score += cells / rows * rows * 2;
              const headers = node.querySelectorAll("th").length;
              if (headers > 0) score += headers * 5;
              const caption = node.querySelector("caption");
              if (caption) score += 10;
              const textLength = node.textContent?.length || 0;
              if (textLength > 0) {
                score += Math.min(textLength / 100, 50);
              }
            }
            return score;
          }, "getTableScore");
          const contentPatterns = [
            /article|post|content|main|body|text/i,
            /^(article|main|content)$/i
          ];
          const specificPatterns = {
            content: /content|article-content|post-content|entry-content|main-content/i,
            table: /table-content|data-table|grid|list/i,
            article: /article|post|entry|blog/i,
            main: /main|primary|central/i
          };
          document.querySelectorAll("div, article, main, section, table").forEach((element) => {
            if (isBoilerplate(element)) return;
            let score = 0;
            const identifiers = `${element.className} ${element.id}`.toLowerCase();
            const tagName = element.tagName.toLowerCase();
            if (tagName === "article") score += 30;
            if (tagName === "main") score += 25;
            if (tagName === "table") score += 15;
            Object.entries(specificPatterns).forEach(
              ([key, pattern]) => {
                if (pattern.test(identifiers)) {
                  switch (key) {
                    case "content":
                      score += 40;
                      break;
                    case "table":
                      score += 25;
                      break;
                    case "article":
                      score += 30;
                      break;
                    case "main":
                      score += 20;
                      break;
                  }
                }
              }
            );
            contentPatterns.forEach((pattern) => {
              if (pattern.test(identifiers)) score += 20;
            });
            const density = getTextDensity(element);
            score += density * 50;
            const paragraphs = element.getElementsByTagName("p").length;
            score += paragraphs * 3;
            const headings = element.querySelectorAll(
              "h1,h2,h3,h4,h5,h6"
            ).length;
            score += headings * 5;
            if (tagName === "table" || element.querySelector("table")) {
              score += getTableScore(element);
            }
            const paragraphScore = getParagraphScore(element);
            score += paragraphScore * 2;
            const text2 = element.textContent || "";
            if (text2.length < 250) score *= 0.7;
            const rect = element.getBoundingClientRect();
            const verticalCenter = Math.abs(
              0.5 - rect.top / document.documentElement.scrollHeight
            );
            score *= 1 - verticalCenter * 0.3;
            if (tagName === "table" || element.querySelector("table")) {
              if (text2.length < 250 && element.querySelectorAll("td").length > 20) {
                score *= 1.5;
              }
            }
            candidates.push({ element, score });
          });
          candidates.sort((a, b) => b.score - a.score);
          return candidates[0]?.element || document.body;
        }, "findMainContent");
        const mainContent = findMainContent();
        let structuredText = "";
        const processNode = /* @__PURE__ */ __name((node, depth = 0) => {
          if (node.nodeType === Node.TEXT_NODE) {
            const trimmedText = node.textContent?.trim();
            if (trimmedText) {
              structuredText += " " + trimmedText;
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const element = node;
            const tagName = element.tagName.toLowerCase();
            switch (tagName) {
              case "p":
              case "h1":
              case "h2":
              case "h3":
              case "h4":
              case "h5":
              case "h6":
                structuredText += "\n".repeat(depth > 0 ? 1 : 2);
                structuredText += `${"#".repeat(["h1", "h2", "h3", "h4", "h5", "h6"].indexOf(tagName) + 1)} `;
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "ul":
              case "ol":
                structuredText += "\n";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "li":
                if (element.textContent?.trim()) {
                  structuredText += "\n" + "  ".repeat(depth) + "- ";
                  for (const child of element.childNodes) {
                    processNode(child, depth + 1);
                  }
                }
                break;
              case "br":
                structuredText += "\n";
                break;
              case "strong":
              case "b":
                structuredText += ` **${element.textContent?.trim()}** `;
                break;
              case "em":
              case "i":
                structuredText += ` *${element.textContent?.trim()}* `;
                break;
              case "code":
                structuredText += ` \`${element.textContent?.trim()}\` `;
                break;
              case "pre":
                structuredText += "\n```\n" + element.textContent?.trim() + "\n```\n";
                break;
              case "blockquote":
                structuredText += "\n> " + element.textContent?.trim().replace(/\n/g, "\n> ") + "\n";
                break;
              case "table":
                structuredText += "\n";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "tr":
                structuredText += "|";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "th":
              case "td":
                structuredText += ` ${element.textContent?.trim()} |`;
                break;
              case "mark":
              case "u":
                structuredText += ` __${element.textContent?.trim()}__ `;
                break;
              case "del":
              case "s":
                structuredText += ` ~~${element.textContent?.trim()}~~ `;
                break;
              case "sup":
                structuredText += `^${element.textContent?.trim()}`;
                break;
              case "sub":
                structuredText += `~${element.textContent?.trim()}`;
                break;
              case "kbd":
                structuredText += ` <kbd>${element.textContent?.trim()}</kbd> `;
                break;
              case "cite":
              case "dfn":
                structuredText += ` *${element.textContent?.trim()}* `;
                break;
              case "span": {
                const className = element.className;
                if (className.includes("highlight")) {
                  structuredText += ` **${element.textContent?.trim()}** `;
                } else if (className.includes("italic")) {
                  structuredText += ` *${element.textContent?.trim()}* `;
                } else {
                  structuredText += ` ${element.textContent?.trim()} `;
                }
                break;
              }
              case "abbr": {
                const title = element.getAttribute("title");
                structuredText += title ? ` ${element.textContent?.trim()} (${title})` : ` ${element.textContent?.trim()}`;
                break;
              }
              case "q":
                structuredText += ` "${element.textContent?.trim()}" `;
                break;
              case "time": {
                const datetime = element.getAttribute("datetime");
                structuredText += datetime ? ` ${element.textContent?.trim()} [${datetime}]` : ` ${element.textContent?.trim()}`;
                break;
              }
              case "details":
                structuredText += "\n<details>\n";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n</details>\n";
                break;
              case "summary":
                structuredText += "<summary>";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "</summary>\n";
                break;
              case "figure":
                structuredText += "\n";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "figcaption":
                structuredText += `
_${element.textContent?.trim()}_
`;
                break;
              case "hr":
                structuredText += "\n---\n";
                break;
              case "dl":
                structuredText += "\n";
                for (const child of element.childNodes) {
                  processNode(child, depth + 1);
                }
                structuredText += "\n";
                break;
              case "dt":
                structuredText += `
**${element.textContent?.trim()}**`;
                break;
              case "dd":
                structuredText += `: ${element.textContent?.trim()}
`;
                break;
              case "var":
                structuredText += ` _${element.textContent?.trim()}_ `;
                break;
              case "samp":
                structuredText += ` \`${element.textContent?.trim()}\` `;
                break;
              default:
                if (tagName !== "script" && tagName !== "style" && tagName !== "meta") {
                  for (const child of element.childNodes) {
                    processNode(child, depth);
                  }
                }
            }
          }
        }, "processNode");
        const getRelatedLinks = /* @__PURE__ */ __name((content) => {
          const currentUrl = window.location.href;
          const currentHost = window.location.hostname;
          const currentPath = window.location.pathname;
          const links = {
            samePath: [],
            sameHost: [],
            external: []
          };
          const getLinkContext = /* @__PURE__ */ __name((link) => {
            const parent = link.parentElement;
            if (!parent) return "";
            const text2 = parent.textContent || "";
            const linkText = link.textContent || "";
            const linkPos = text2.indexOf(linkText);
            if (linkPos === -1) return "";
            const start = Math.max(0, linkPos - 50);
            const end = Math.min(
              text2.length,
              linkPos + linkText.length + 50
            );
            return text2.slice(start, end).trim();
          }, "getLinkContext");
          content.querySelectorAll("a[href]").forEach((link) => {
            const href = link.getAttribute("href");
            if (!href) return;
            try {
              const url2 = new URL(href, currentUrl);
              const linkText = link.textContent?.trim();
              const context = getLinkContext(link);
              if (!linkText || url2.href === currentUrl || href.startsWith("#") || /login|signup|register|cart|search|account/i.test(
                url2.pathname
              )) {
                return;
              }
              const linkMd = `- [${linkText}](${url2.href})${context ? `
  > ${context}` : ""}`;
              if (url2.hostname === currentHost) {
                if (url2.pathname.startsWith(currentPath) || currentPath.startsWith(url2.pathname)) {
                  if (!links.samePath.includes(linkMd)) {
                    links.samePath.push(linkMd);
                  }
                } else {
                  if (!links.sameHost.includes(linkMd)) {
                    links.sameHost.push(linkMd);
                  }
                }
              } else {
                if (!links.external.includes(linkMd)) {
                  links.external.push(linkMd);
                }
              }
            } catch (e) {
            }
          });
          let relatedLinksText = "";
          if (links.samePath.length > 0 || links.sameHost.length > 0 || links.external.length > 0) {
            relatedLinksText = "\n\n## Related Links\n\n";
            if (links.samePath.length > 0) {
              relatedLinksText += "### Same Section\n" + links.samePath.slice(0, 2).join("\n") + "\n\n";
            }
            if (links.sameHost.length > 0) {
              relatedLinksText += "### Same Site\n" + links.sameHost.slice(0, 2).join("\n") + "\n\n";
            }
            if (links.external.length > 0) {
              relatedLinksText += "### External References\n" + links.external.slice(0, 2).join("\n") + "\n\n";
            }
          }
          return relatedLinksText;
        }, "getRelatedLinks");
        processNode(mainContent);
        const findBestLinkContainer = /* @__PURE__ */ __name((mainContent2) => {
          const MAX_PARENT_DEPTH = 6;
          let current = mainContent2;
          for (let depth = 0; depth < MAX_PARENT_DEPTH; depth++) {
            if (!current) break;
            current = current.parentElement;
          }
          return mainContent2;
        }, "findBestLinkContainer");
        structuredText += getRelatedLinks(
          findBestLinkContainer(mainContent)
        );
        return structuredText.trim().replace(/\n{3,}/g, "\n\n");
      });
      return text.trim().replace(/\n{3,}/g, "\n\n").trim().replace(/\s+/g, " ");
    } catch (error) {
      console.error(error);
      return `Error getting page text: ${error.message}`;
    }
  }
  async summarizeText(text, searchText) {
    try {
      const input = `Text: ${text}

${searchText ? `Search Focus: "${searchText}"

First, evaluate if the text content is relevant to the search focus:
1. Identify key concepts in both the search focus and text
2. Check for direct mentions or related terminology
3. Assess contextual relevance
4. Consider semantic relationships

If the content is NOT relevant to the search focus, output exactly: [none]

Only if the content IS relevant, provide a comprehensive summary following these guidelines:` : "Please provide a comprehensive summary following these guidelines:"}

1. Main Points (1-2 paragraphs):
   - Key topics and themes
   - Central arguments or findings
   - Essential context

2. Supporting Details (2-3 paragraphs):
   - Evidence and examples
   - Data or statistics
   - Expert opinions or quotes
   ${searchText ? "- Specific information related to search focus" : ""}

3. Additional Context (1 paragraph):
   - Limitations or caveats
   - Alternative viewpoints
   - Related considerations

Guidelines:
- Use clear, concise language
- Maintain objectivity
- Include relevant quotes or statistics
- Reference up to 5 important links
- Stay faithful to source material
- CRITICAL: Use the exact same language as the input text

IMPORTANT: Your summary MUST be in the same language as the original text. Do not translate or change the language under any circumstances.

Your summary or [none]:`;
      const summary = await this.model.invoke(input, {
        temperature: 0
      });
      return getMessageContent2(summary.content);
    } catch (error) {
      console.error(error);
      return `Error summarizing text: ${error.message}`;
    }
  }
  async selectDiv(url, selector) {
    try {
      const page = await this.getPage(url);
      if (!page) return "No page is open";
      const content = await page.evaluate((sel) => {
        const element = document.querySelector(sel);
        return element ? element.textContent : "Element not found";
      }, selector);
      return content || "No content found";
    } catch (error) {
      console.error(`Error selecting div: ${error}`);
      return `Error selecting div: ${error.message}`;
    }
  }
  async goToPreviousPage(url) {
    try {
      const page = await this.getPage(url);
      if (!page) return "No page is open";
      await page.goBack({
        waitUntil: "networkidle2",
        timeout: this.timeout
      });
      return "Navigated to previous page";
    } catch (error) {
      console.error(`Error navigating to previous page: ${error.message}`);
      return `Error navigating to previous page: ${error}`;
    }
  }
  async getHtml(url) {
    try {
      const page = await this.getPage(url);
      if (!page) return "No page is open";
      return await page.content();
    } catch (error) {
      console.error(error);
      return `Error getting HTML: ${error.message}`;
    }
  }
  async getStructuredUrls(url) {
    try {
      const page = await this.getPage(url);
      if (!page) return "No page is open";
      return await page.evaluate(() => {
        const urlStructure = {
          search: [],
          navigation: [],
          external: [],
          other: []
        };
        const currentHost = window.location.hostname;
        document.querySelectorAll("a").forEach((a) => {
          const href = a.href;
          if (!href) return;
          const url2 = new URL(href);
          const linkText = a.textContent?.trim() || "";
          if (url2.hostname === currentHost) {
            if (url2.pathname.includes("search") || url2.search.includes("q=")) {
              urlStructure.search.push(`${linkText}: ${href}`);
            } else if (a.closest("nav") || a.matches("header a, footer a")) {
              urlStructure.navigation.push(`${linkText}: ${href}`);
            } else {
              urlStructure.other.push(`${linkText}: ${href}`);
            }
          } else {
            urlStructure.external.push(`${linkText}: ${href}`);
          }
        });
        return JSON.stringify(urlStructure, null, 2);
      });
    } catch (error) {
      console.error(error);
      return `Error getting structured URLs: ${error.message}`;
    }
  }
  startIdleTimer() {
    if (this.disposables.length > 0) {
      return;
    }
    this.disposables.push(
      this.ctx.setInterval(() => {
        if (Date.now() - this.lastActionTime > this.idleTimeout) {
          this.closeBrowser();
        }
      }, 6e4)
    );
    this.ctx.on("dispose", async () => {
      this.closeBrowser();
    });
  }
  async closeBrowser() {
    try {
      if (this.pages) {
        this.pages.forEach((page) => {
          page.close().catch((err) => {
            this.ctx.logger.error(
              `Error closing page: ${err.message}`
            );
          });
        });
        this.pages.clear();
      }
      for (const disposable of this.disposables) {
        disposable();
      }
      this.disposables = [];
    } catch (error) {
      this.ctx.logger.error(error);
    }
  }
};

// src/config.ts
import { Schema } from "koishi";
import { ModelType } from "koishi-plugin-chatluna/llm-core/platform/types";
async function apply(ctx, _config) {
  ctx.on("chatluna/model-added", (service) => {
    ctx.schema.set("model", Schema.union(getModelNames(service)));
  });
  ctx.on("chatluna/model-removed", (service) => {
    ctx.schema.set("model", Schema.union(getModelNames(service)));
  });
  ctx.schema.set("model", Schema.union(getModelNames(ctx.chatluna.platform)));
}
__name(apply, "apply");
function getModelNames(service) {
  return service.getAllModels(ModelType.llm).concat("empty").map((m) => Schema.const(m));
}
__name(getModelNames, "getModelNames");

// src/index.ts
import { parseRawModelName as parseRawModelName2 } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";

// src/provide.ts
import { Schema as Schema2 } from "koishi";
import { MemoryVectorStore } from "koishi-plugin-chatluna/llm-core/vectorstores";
import { parseRawModelName } from "koishi-plugin-chatluna/llm-core/utils/count_tokens";
var SearchProvider = class {
  constructor(ctx, config, _plugin) {
    this.ctx = ctx;
    this.config = config;
    this._plugin = _plugin;
  }
  static {
    __name(this, "SearchProvider");
  }
};
var SearchManager = class {
  constructor(ctx, config) {
    this.ctx = ctx;
    this.config = config;
  }
  static {
    __name(this, "SearchManager");
  }
  providers = /* @__PURE__ */ new Map();
  schemas = [];
  _embeddings;
  addProvider(provider) {
    this.providers.set(provider.name, provider);
    return () => this._deleteProvider(provider.name);
  }
  getProvider(name2) {
    return this.providers.get(name2);
  }
  _deleteProvider(name2) {
    this.providers.delete(name2);
  }
  updateSchema(schema) {
    this.schemas.push(schema);
    this.ctx.schema.set(
      "search-engine",
      Schema2.array(Schema2.union(this.schemas))
    );
  }
  async search(query, limit = this.config.topK, providerNames = this.config.searchEngine) {
    const providers = providerNames ? Array.from(this.providers.values()).filter(
      (p) => providerNames.includes(p.name)
    ) : Array.from(this.providers.values());
    if (providers.length === 1) {
      try {
        return await providers[0].search(query, limit);
      } catch (error) {
        logger.error(
          `Error searching with provider ${providers[0].name}:`,
          error
        );
        return [];
      }
    }
    const searchResults = [];
    const signalLimit = this.config.mulitSourceMode === "average" ? Math.round(limit / providers.length) : limit;
    const searchPromises = providers.map(async (provider) => {
      try {
        const results = await provider.search(query, signalLimit);
        searchResults.push(...results);
      } catch (error) {
        logger.error(
          `Error searching with provider ${provider.name}:`,
          error
        );
      }
    });
    await Promise.all(searchPromises);
    if (searchPromises.length > limit) {
      return this._reRankResults(query, searchResults, limit);
    }
    return searchResults;
  }
  async _getEmbeddings() {
    if (this._embeddings) return this._embeddings;
    try {
      const [platform, model] = parseRawModelName(
        this.ctx.chatluna.config.defaultEmbeddings
      );
      this._embeddings = await this.ctx.chatluna.createEmbeddings(
        platform,
        model
      );
    } catch (e) {
      logger.warn(
        `Get embeddings failed: ${e}. Try check your defaultEmbeddings`
      );
      return null;
    }
    return this._embeddings;
  }
  async _reRankResults(query, results, limit) {
    const embeddings = await this._getEmbeddings();
    if (!embeddings) {
      logger.warn("Embeddings is null. Return original results.");
      return results;
    }
    const vectorStore = new MemoryVectorStore(embeddings);
    const docs = results.map(
      (r) => ({
        pageContent: r.title,
        metadata: r
      })
    );
    await vectorStore.addDocuments(docs);
    const searchResults = await vectorStore.similaritySearch(query, limit);
    return searchResults.map((r) => r.metadata);
  }
};

// src/providers/bing_api.ts
import { Schema as Schema3 } from "koishi";
var BingAPISearchProvider = class extends SearchProvider {
  static {
    __name(this, "BingAPISearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const searchUrl = new URL("https://api.bing.microsoft.com/v7.0/search");
    const headers = {
      "Ocp-Apim-Subscription-Key": this.config.bingSearchApiKey,
      "Ocp-Apim-Subscription-Region": this.config.azureLocation ?? "global"
    };
    const params = {
      q: query,
      responseFilter: "Webpages",
      count: limit.toString()
    };
    Object.entries(params).forEach(([key, value]) => {
      searchUrl.searchParams.append(key, value);
    });
    const response = await this._plugin.fetch(searchUrl, { headers });
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    const res = await response.json();
    const results = res.webPages.value;
    if (results.length === 0) {
      return [
        {
          title: "No results found",
          description: "No results found",
          url: ""
        }
      ];
    }
    const snippets = results.map(
      (item) => ({
        title: item.name,
        description: item.snippet,
        url: item.url
      })
    );
    return snippets;
  }
  static schema = Schema3.const("bing-api").i18n({
    "": "Bing (Azure API)"
  });
  name = "bing-api";
};
function apply2(ctx, config, plugin, manager) {
  const searchEngines = config.searchEngine;
  if (searchEngines.includes("bing-api")) {
    manager.addProvider(new BingAPISearchProvider(ctx, config, plugin));
  }
}
__name(apply2, "apply");

// src/providers/bing_web.ts
import { Schema as Schema4 } from "koishi";
var BingWebSearchProvider = class extends SearchProvider {
  static {
    __name(this, "BingWebSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const page = await this.ctx.puppeteer.page();
    await page.goto(
      `https://cn.bing.com/search?form=QBRE&q=${encodeURIComponent(
        query
      )}`,
      {
        waitUntil: "networkidle2"
      }
    );
    const summaries = await page.evaluate(() => {
      const liElements = Array.from(
        document.querySelectorAll("#b_results > .b_algo")
      );
      return liElements.map((li) => {
        const abstractElement = li.querySelector(".b_caption > p");
        const linkElement = li.querySelector("a");
        const href = linkElement.getAttribute("href");
        const title = linkElement.textContent;
        const imageElement = li.querySelector("img");
        const image = imageElement ? imageElement.getAttribute("src") : "";
        const description = abstractElement ? abstractElement.textContent : "";
        return { url: href, title, description, image };
      });
    });
    await page.close();
    return summaries.slice(0, limit);
  }
  static schema = Schema4.const("bing-web").i18n({
    "": "Bing (Web)"
  });
  name = "bing-web";
};
function apply3(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("bing-web")) {
    manager.addProvider(new BingWebSearchProvider(ctx, config, plugin));
  }
}
__name(apply3, "apply");

// src/providers/duckduckgo_lite.ts
import { Schema as Schema5, sleep } from "koishi";
var DuckDuckGoSearchProvider = class extends SearchProvider {
  static {
    __name(this, "DuckDuckGoSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const result = [];
    for await (const searchResult of this.searchText(query)) {
      result.push({
        title: searchResult.title,
        url: searchResult.href,
        description: searchResult.body
      });
    }
    return result.slice(0, limit);
  }
  async *searchText(keywords, region = "zh-cn", safesearch = "moderate") {
    if (!keywords) {
      throw new Error("Keywords are mandatory");
    }
    const vqd = await this._getVQD(keywords);
    if (!vqd) {
      throw new Error("Error in getting vqd");
    }
    const payload = {
      q: keywords,
      kl: region,
      l: region,
      s: 0,
      vqd,
      o: "json",
      sp: "0"
    };
    safesearch = safesearch.toLowerCase();
    if (safesearch === "moderate") {
      payload.ex = "-1";
    } else if (safesearch === "off") {
      payload.ex = "-2";
    } else if (safesearch === "on") {
      payload.p = "1";
    }
    const cache = /* @__PURE__ */ new Set();
    const searchPositions = ["0", "20", "70", "120"];
    for (const s of searchPositions) {
      payload.s = s;
      const respRaw = await (await this._getUrl(
        "GET",
        "https://links.duckduckgo.com/d.js",
        payload
      )).text();
      if (respRaw.includes("DDG.deep.is506")) {
        throw new Error("A server error occurred!");
      }
      if (respRaw.includes("DDG.deep.anomalyDetectionBlock")) {
        throw new Error(
          "DDG detected an anomaly in the request, you are likely making requests too quickly."
        );
      }
      const resp = JSON.parse(respRaw);
      if (!resp) {
        break;
      }
      try {
        const pageData = resp.results;
        if (!pageData) {
          break;
        }
        let resultExists = false;
        for (const row of pageData) {
          const href = row.u;
          if (href && !cache.has(href) && href !== `http://www.google.com/search?q=${keywords}`) {
            cache.add(href);
            const body = _normalize(row.a);
            if (body) {
              resultExists = true;
              yield {
                title: _normalize(row.t),
                href: _normalizeUrl(href),
                body
              };
            }
          }
        }
        if (!resultExists) {
          break;
        }
      } catch (error) {
        logger.error(error);
        break;
      }
    }
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async _getUrl(method, url, params) {
    for (let i = 0; i < 3; i++) {
      try {
        const searchParams = new URLSearchParams(params);
        const resp = await this._plugin.fetch(
          method === "GET" ? url + "?" + searchParams.toString() : url,
          {
            method,
            body: method !== "GET" ? searchParams.toString() : void 0
          }
        );
        if (!resp.ok) {
          throw new Error(
            `Failed to fetch data from DuckDuckGo. Status: ${resp.status} - ${resp.statusText}`
          );
        }
        if (_is500InUrl(resp.url) || resp.status === 202) {
          throw new Error(
            `Failed to fetch data from DuckDuckGo. Status: ${resp.status} - ${resp.statusText}`
          );
        }
        if (resp.status === 200) {
          return resp;
        }
      } catch (ex) {
        logger.warn(`_getUrl() ${url} ${ex.name} ${ex.message}`);
        if (i >= 2 || ex.message.includes("418")) {
          throw ex;
        }
      }
      await sleep(3e3);
    }
    return void 0;
  }
  /**
   * Get the VQD of a search query.
   * @param query The query to search
   * @param ia The type(?) of search
   * @returns The VQD
   */
  async _getVQD(query, ia = "web") {
    try {
      const queryParams = new URLSearchParams({ q: query, ia });
      const response = await this._plugin.fetch(
        `https://duckduckgo.com/?${queryParams.toString()}`
      );
      if (!response.ok) {
        throw new Error(
          `Failed to get the VQD for query "${query}". Status: ${response.status} - ${response.statusText}`
        );
      }
      const responseText = await response.text();
      const vqd = VQD_REGEX.exec(responseText)?.[1];
      if (!vqd) {
        throw new Error(
          `Failed to extract the VQD from the response for query "${query}".`
        );
      }
      return vqd;
    } catch (e) {
      const err = `Failed to get the VQD for query "${query}".
      Error: ${e.cause.message}
    `;
      throw new Error(err);
    }
  }
  static schema = Schema5.const("duckduckgo-lite").i18n({
    "": "DuckDuckGo (Lite)"
  });
  name = "duckduckgo-lite";
};
var VQD_REGEX = /vqd=['"](\d+-\d+(?:-\d+)?)['"]/;
function unescape(text) {
  return text.replace(/&quot;/g, '"');
}
__name(unescape, "unescape");
function sub(pattern, replacement, text) {
  return text.replace(pattern, replacement);
}
__name(sub, "sub");
function unquote(url) {
  return url;
}
__name(unquote, "unquote");
var REGEX_STRIP_TAGS = /<[^>]*>/g;
function _is500InUrl(url) {
  return url.includes("500");
}
__name(_is500InUrl, "_is500InUrl");
function _normalize(rawHtml) {
  if (rawHtml) {
    return unescape(sub(REGEX_STRIP_TAGS, "", rawHtml));
  }
  return "";
}
__name(_normalize, "_normalize");
function _normalizeUrl(url) {
  if (url) {
    return unquote(url).replace(" ", "+");
  }
  return "";
}
__name(_normalizeUrl, "_normalizeUrl");
function apply4(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("duckduckgo-lite")) {
    manager.addProvider(new DuckDuckGoSearchProvider(ctx, config, plugin));
  }
}
__name(apply4, "apply");

// src/providers/free_google_api.ts
import { Schema as Schema6 } from "koishi";
var FreeGoogleSearchProvider = class extends SearchProvider {
  static {
    __name(this, "FreeGoogleSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const baseURL = this.config.freeSearchBaseURL;
    const response = await this._plugin.fetch(
      `${baseURL}/search?keyword=${encodeURIComponent(query)}&count=${limit}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"
        }
      }
    );
    const res = await response.json();
    if (!res || res.length === 0) {
      return [
        {
          title: "No results found",
          description: "No good search result found",
          url: ""
        }
      ];
    }
    return res.slice(0, limit);
  }
  static schema = Schema6.const("free-google-api").i18n({
    "": "Free Google (API & Web)"
  });
  name = "free-google-api";
};
function apply5(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("free-google-api")) {
    manager.addProvider(new FreeGoogleSearchProvider(ctx, config, plugin));
  }
}
__name(apply5, "apply");

// src/providers/google_web.ts
import { Schema as Schema7 } from "koishi";
var GoogleWebSearchProvider = class extends SearchProvider {
  static {
    __name(this, "GoogleWebSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const page = await this.ctx.puppeteer.page();
    await page.goto(
      `https://www.google.com.hk/search?q=${encodeURIComponent(
        query
      )}&oq=${encodeURIComponent(
        query
      )}&uule=w+CAIQICIaQXVzdGluLFRleGFzLFVuaXRlZCBTdGF0ZXM&hl=en&gl=us&sourceid=chrome&ie=UTF-8%22#ip=1`,
      {
        waitUntil: "networkidle2"
      }
    );
    const summaries = await page.evaluate(() => {
      const liElements = Array.from(
        document.querySelector("#search > div > div").childNodes
      );
      return liElements.map((li) => {
        const linkElement = li.querySelector("a");
        const href = linkElement.getAttribute("href");
        const title = linkElement.querySelector("a > h3").textContent;
        const abstract = Array.from(
          li.querySelectorAll(
            "div > div > div > div > div > div > span"
          )
        ).map((e) => e.textContent).join("");
        return { url: href, title, description: abstract };
      });
    });
    await page.close();
    return summaries.slice(0, limit);
  }
  static schema = Schema7.const("google-web").i18n({
    "": "Google (Web)"
  });
  name = "google-web";
};
function apply6(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("google-web")) {
    manager.addProvider(new GoogleWebSearchProvider(ctx, config, plugin));
  }
}
__name(apply6, "apply");

// src/providers/searxng.ts
import { Schema as Schema8 } from "koishi";
var SearxNGSearchProvider = class extends SearchProvider {
  static {
    __name(this, "SearxNGSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const searchUrl = new URL(this.config.searxngBaseURL);
    const params = {
      q: query,
      format: "json"
    };
    Object.entries(params).forEach(([key, value]) => {
      searchUrl.searchParams.append(key, value);
    });
    const response = await this._plugin.fetch(searchUrl.toString());
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    const res = await response.json();
    const results = res.results;
    if (results.length === 0) {
      return [
        {
          title: "No results found",
          description: "No results found",
          url: ""
        }
      ];
    }
    const snippets = results.map(
      (item) => ({
        url: item.url,
        title: item.title,
        description: item.content,
        image: item.thumbnail
      })
    );
    return snippets.slice(0, limit);
  }
  static schema = Schema8.const("searxng").i18n({
    "": "SearxNG"
  });
  name = "searxng";
};
function apply7(ctx, config, plugin, manager) {
  const searchEngines = config.searchEngine;
  if (searchEngines.includes("searxng")) {
    manager.addProvider(new SearxNGSearchProvider(ctx, config, plugin));
  }
}
__name(apply7, "apply");

// src/providers/serper.ts
import { Schema as Schema9 } from "koishi";
var SerperSearchProvider = class extends SearchProvider {
  static {
    __name(this, "SerperSearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const response = await this._plugin.fetch(
      "https://google.serper.dev/search",
      {
        method: "POST",
        headers: {
          "X-API-KEY": this.config.serperApiKey,
          "Content-Type": "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"
        },
        body: JSON.stringify({
          q: query,
          gl: this.config.serperCountry ?? "cn",
          hl: this.config.serperLocation ?? "zh-cn"
        })
      }
    );
    const res = await response.json();
    if (!res || !res.organic || res.organic.length === 0) {
      return [
        {
          title: "No results found",
          description: "No good search result found",
          url: ""
        }
      ];
    }
    return res.organic.slice(0, limit).map(
      (item) => ({
        title: item.title,
        description: item.snippet,
        url: item.link
      })
    );
  }
  static schema = Schema9.const("serper").i18n({
    "": "Serper (Google API)"
  });
  name = "serper";
};
function apply8(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("serper")) {
    manager.addProvider(new SerperSearchProvider(ctx, config, plugin));
  }
}
__name(apply8, "apply");

// src/providers/tavily.ts
import { Schema as Schema10 } from "koishi";
var TavilySearchProvider = class extends SearchProvider {
  static {
    __name(this, "TavilySearchProvider");
  }
  async search(query, limit = this.config.topK) {
    const body = {
      query,
      api_key: this.config.tavilyApiKey,
      search_depth: "basic",
      include_images: true,
      include_image_descriptions: true,
      max_results: limit
    };
    const response = await this._plugin.fetch(
      "https://api.tavily.com/search",
      {
        method: "POST",
        body: JSON.stringify(body),
        headers: {
          "Content-Type": "application/json",
          "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"
        }
      }
    );
    if (!response.ok) {
      throw new Error(`HTTP error ${response.status}`);
    }
    const res = await response.json();
    if (res.results.length === 0 && (!res.images || res.images.length === 0)) {
      return [
        {
          title: "No results found",
          description: "No good search result found",
          url: ""
        }
      ];
    }
    const formattedResults = res.results.map(
      (r) => ({
        title: r.title,
        description: r.content,
        url: r.url
      })
    );
    const formattedImages = (res.images ?? []).map(
      (img) => ({
        title: "Image",
        description: img.description,
        url: img.url
      })
    );
    return [...formattedResults, ...formattedImages].slice(0, limit);
  }
  static schema = Schema10.const("tavily").i18n({
    "": "Tavily (API)"
  });
  name = "tavily";
};
function apply9(ctx, config, plugin, manager) {
  if (config.searchEngine.includes("tavily")) {
    manager.addProvider(new TavilySearchProvider(ctx, config, plugin));
  }
}
__name(apply9, "apply");

// src/providers/wikipedia.ts
import { Schema as Schema11 } from "koishi";
var WikipediaSearchProvider = class extends SearchProvider {
  constructor(ctx, config, plugin, params, model) {
    super(ctx, config, plugin);
    this.model = model;
    this.topKResults = params.topKResults ?? this.topKResults;
    this.maxDocContentLength = params.maxDocContentLength ?? this.maxDocContentLength;
    this.baseUrl = params.baseUrl ?? this.baseUrl;
    if (!model) {
      logger?.warn(
        "No keywordExtract model provided, skip enhanced keyword extract"
      );
    }
  }
  static {
    __name(this, "WikipediaSearchProvider");
  }
  topKResults = 3;
  maxDocContentLength = 5e3;
  baseUrl = "https://en.wikipedia.org/w/api.php";
  searchedKeyword = [];
  async search(query, limit = this.config.topK) {
    if (this.model) {
      query = await this._extractKeyword(query);
      logger?.debug(`Extracted keyword For Wikipedia: ${query}`);
    }
    const searchResults = await this._fetchSearchResults(query);
    const summaries = [];
    if (!searchResults.error) {
      logger.error(
        `Error fetching search results for query "${query}" in ${this.baseUrl}: ${JSON.stringify(searchResults.error)}`
      );
      return [];
    }
    const topK = Math.min(limit, searchResults.query.search.length);
    const documentContentLength = this.maxDocContentLength / topK * 2;
    for (let i = 0; i < topK; i += 1) {
      const page = searchResults.query.search[i].title;
      try {
        const pageDetails = await this._fetchPage(page, true);
        if (!pageDetails) {
          continue;
        }
        const pageUrl = await this._getPageUrl(page);
        summaries.push({
          title: page,
          description: pageDetails.extract.slice(
            0,
            documentContentLength
          ),
          url: pageUrl
        });
      } catch (error) {
        logger?.error(`Failed to fetch page "${page}": ${error}`);
      }
    }
    if (summaries.length === 0) {
      return [
        {
          title: "No results found",
          description: "No good Wikipedia Search Result was found",
          url: ""
        }
      ];
    }
    return summaries;
  }
  async _extractKeyword(query) {
    const result = await this.model.invoke(
      PROMPT.replace(/{query}/g, query)
    );
    return result.content.trim();
  }
  /**
   * Fetches the content of a specific Wikipedia page. It returns the
   * extracted content as a string.
   * @param page The specific Wikipedia page to fetch its content.
   * @param redirect A boolean value to indicate whether to redirect or not.
   * @returns The extracted content of the specific Wikipedia page as a string.
   */
  async content(page, redirect = true) {
    try {
      const result = await this._fetchPage(page, redirect);
      return result.extract;
    } catch (error) {
      logger?.error(error);
      throw new Error(
        `Failed to fetch content for page "${page}": ${error}`
      );
    }
  }
  /**
   * Builds a URL for the Wikipedia API using the provided parameters.
   * @param parameters The parameters to be used in building the URL.
   * @returns A string representing the built URL.
   */
  buildUrl(parameters) {
    const nonUndefinedParams = Object.entries(
      parameters
    ).filter(([_, value]) => value !== void 0).map(([key, value]) => [key, `${value}`]);
    const searchParams = new URLSearchParams(nonUndefinedParams);
    return `${this.baseUrl}?${searchParams}`;
  }
  async _getPageUrl(title) {
    const params = new URLSearchParams({
      action: "query",
      prop: "info",
      inprop: "url",
      titles: title,
      format: "json"
    });
    const response = await this._plugin.fetch(
      `${this.baseUrl}?${params.toString()}`
    );
    if (!response.ok) throw new Error("Network response was not ok");
    const data = await response.json();
    const pages = data.query.pages;
    const pageId = Object.keys(pages)[0];
    return pages[pageId].fullurl;
  }
  async _fetchSearchResults(query) {
    const searchParams = new URLSearchParams({
      action: "query",
      list: "search",
      srsearch: query,
      format: "json"
    });
    const response = await this._plugin.fetch(
      `${this.baseUrl}?${searchParams.toString()}`
    );
    if (!response.ok) throw new Error("Network response was not ok");
    const data = await response.json();
    return data;
  }
  async _fetchPage(page, redirect) {
    const params = new URLSearchParams({
      action: "query",
      prop: "extracts",
      explaintext: "true",
      redirects: redirect ? "1" : "0",
      format: "json",
      titles: page
    });
    const response = await this._plugin.fetch(
      `${this.baseUrl}?${params.toString()}`
    );
    if (!response.ok) throw new Error("Network response was not ok");
    const data = await response.json();
    const { pages } = data.query;
    const pageId = Object.keys(pages)[0];
    return pages[pageId];
  }
  static schema = Schema11.const("wikipedia").i18n({
    "": "Wikipedia"
  });
  name = "wikipedia";
};
var PROMPT = `Extract the most important single-word keyword for a Wikipedia search from the query. The keyword should match the query's language and represent the main subject likely to have a Wikipedia article.

Examples:
Query: "What are the health benefits of drinking green tea?"
Keyword: "tea"

Query: "长城是什么时候建造的？"
Keyword: "长城"

Query: "江戸時代の武士の生活について教えてください。"
Keyword: "武士"

Query: "{query}"
Keyword:`;
async function apply10(ctx, config, plugin, manager) {
  if (!config.searchEngine.includes("wikipedia")) {
    return;
  }
  let summaryModel;
  try {
    summaryModel = await createModel(ctx, config.summaryModel);
  } catch (error) {
    logger?.error(error);
  }
  const wikipediaBaseURLs = config.wikipediaBaseURL;
  for (const baseURL of wikipediaBaseURLs) {
    manager.addProvider(
      new WikipediaSearchProvider(
        ctx,
        config,
        plugin,
        {
          baseUrl: baseURL,
          maxDocContentLength: config.summaryType !== "balanced" /* Balanced */ ? config.maxWikipediaDocContentLength : 1e5
        },
        summaryModel
      )
    );
  }
}
__name(apply10, "apply");

// src/plugin.ts
async function providerPlugin(ctx, config, plugin, manager) {
  const middlewares = (
    // middleware start
    [
      apply2,
      apply3,
      apply4,
      apply5,
      apply6,
      apply7,
      apply8,
      apply9,
      apply10
    ]
  );
  for (const middleware of middlewares) {
    await middleware(ctx, config, plugin, manager);
  }
}
__name(providerPlugin, "providerPlugin");

// src/tools/search.ts
import { Tool } from "@langchain/core/tools";
import { RecursiveCharacterTextSplitter } from "@langchain/textsplitters";
import { MemoryVectorStore as MemoryVectorStore2 } from "koishi-plugin-chatluna/llm-core/vectorstores";
import { PromptTemplate as PromptTemplate2 } from "@langchain/core/prompts";
import { getMessageContent as getMessageContent3 } from "koishi-plugin-chatluna/utils/string";
import { emptyEmbeddings } from "koishi-plugin-chatluna/llm-core/model/in_memory";
var SearchTool = class extends Tool {
  constructor(searchManager, browserTool, embeddings, llm, summaryType) {
    super({});
    this.searchManager = searchManager;
    this.browserTool = browserTool;
    this.embeddings = embeddings;
    this.llm = llm;
    this.summaryType = summaryType;
  }
  static {
    __name(this, "SearchTool");
  }
  name = "web_search";
  // eslint-disable-next-line max-len
  description = `An search engine. Useful for when you need to answer questions about current events. Input should be a raw string of keyword. About Search Keywords, you should cut what you are searching for into several keywords and separate them with spaces. For example, "What is the weather in Beijing today?" would be "Beijing weather today"`;
  _textSplitter = new RecursiveCharacterTextSplitter({
    chunkSize: 600,
    chunkOverlap: 100
  });
  async _call(arg) {
    const documents = await this.fetchSearchResult(arg);
    if (this.summaryType !== "balanced" /* Balanced */) {
      return JSON.stringify(
        documents.map(
          (document2) => Object.assign({}, document2.metadata)
        )
      );
    }
    const fakeSearchResult = await generateFakeSearchResult(arg, this.llm);
    return JSON.stringify(
      await this._reRankDocuments(
        getMessageContent3(fakeSearchResult.content),
        documents
      )
    );
  }
  async fetchSearchResult(query) {
    const results = await this.searchManager.search(query);
    if (this.summaryType === "quality" /* Quality */) {
      return await Promise.all(
        results.map(async (result, k) => {
          let pageContent = result.description;
          if (pageContent == null || pageContent.length < 500) {
            const browserContent = await this.browserTool.invoke({
              url: result.url,
              action: "summarize",
              params: query
            });
            if (!browserContent.includes(
              "Error getting page text:"
            ) && !browserContent.includes(
              "Error summarizing page:"
            ) && browserContent !== "[none]") {
              pageContent = browserContent;
            }
          }
          if (pageContent == null) {
            return;
          }
          const chunks = await this._textSplitter.splitText(pageContent).then((chunks2) => {
            return chunks2.map(
              (chunk) => ({
                pageContent: chunk,
                metadata: Object.assign(
                  { description: chunks2 },
                  removeProperty(result, [
                    "description"
                  ])
                )
              })
            );
          });
          return chunks;
        })
      ).then((documents) => documents.flat());
    } else if (this.summaryType === "balanced" /* Balanced */) {
      return await Promise.all(
        results.map(async (result, k) => {
          let pageContent = result.description;
          if (pageContent == null || pageContent.length < 500) {
            const browserContent = await this.browserTool.invoke({
              url: result.url,
              action: "text"
            });
            if (!browserContent.includes(
              "Error getting page text:"
            ) && !browserContent.includes(
              "Error summarizing page:"
            ) && browserContent !== "[none]") {
              pageContent = browserContent;
            }
          }
          if (pageContent == null) {
            return;
          }
          const chunks = await this._textSplitter.splitText(pageContent).then((chunks2) => {
            return chunks2.map(
              (chunk) => ({
                pageContent: chunk,
                metadata: result
              })
            );
          });
          return chunks;
        })
      ).then((documents) => documents.flat());
    }
    return results.map(
      (result) => ({
        pageContent: result.description,
        metadata: result
      })
    );
  }
  async _reRankDocuments(query, documents) {
    if (this.embeddings === emptyEmbeddings) {
      logger.warn("Embeddings is empty, try check your config");
      return documents.map((document2) => document2.metadata).slice(0, this.searchManager.config.topK * 2);
    }
    const vectorStore = new MemoryVectorStore2(this.embeddings);
    await vectorStore.addDocuments(documents);
    const searchResult = await vectorStore.similaritySearchWithScore(
      query,
      this.searchManager.config.topK * 2
    );
    return searchResult.filter(
      (result) => result[1] > this.searchManager.config.searchThreshold
    ).map((result) => result[0].metadata).slice(0, this.searchManager.config.topK);
  }
};
async function generateFakeSearchResult(query, llm) {
  return llm.invoke(
    await GENERATE_FAKE_SEARCH_RESULT_PROMPT.format({ query }),
    {
      temperature: 0
    }
  );
}
__name(generateFakeSearchResult, "generateFakeSearchResult");
var GENERATE_FAKE_SEARCH_RESULT_PROMPT = new PromptTemplate2({
  template: `Based on the question: "{query}"

Generate a brief, factual answer that:
- Directly addresses the core question
- Uses clear and concise language
- Stays between 50-100 characters
- Contains key factual information
- Avoids speculation or uncertainty

Answer the question as if you are a search result snippet.`,
  inputVariables: ["query"]
});

// src/index.ts
var logger;
function apply11(ctx, config) {
  logger = createLogger(ctx, "chatluna-search-service");
  const plugin = new ChatLunaPlugin(
    ctx,
    config,
    "search-service",
    false
  );
  ctx.on("ready", async () => {
    plugin.registerToService();
    const searchManager = new SearchManager(ctx, config);
    providerPlugin(ctx, config, plugin, searchManager);
    plugin.registerTool("web-search", {
      async createTool(params, session) {
        const summaryType = params["summaryType"] ?? config.summaryType;
        const summaryModel = config.summaryType === "quality" /* Quality */ ? await createModel(ctx, config.summaryModel) : void 0;
        const model = summaryModel ?? params.model;
        const browserTool = new PuppeteerBrowserTool(
          ctx,
          model,
          params.embeddings,
          {
            waitUntil: summaryType !== "quality" /* Quality */ ? "domcontentloaded" : "networkidle2",
            timeout: summaryType !== "quality" /* Quality */ ? 6 * Time.second : 30 * Time.second,
            idleTimeout: 3 * Time.minute
          }
        );
        return new SearchTool(
          searchManager,
          browserTool,
          params.embeddings,
          model,
          summaryType
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
        );
      },
      selector() {
        return true;
      }
    });
    plugin.registerTool("web-browser", {
      async createTool(params, _session) {
        const summaryModel = config.summaryType === "quality" /* Quality */ ? await createModel(ctx, config.summaryModel) : void 0;
        return new PuppeteerBrowserTool(
          ctx,
          summaryModel ?? params.model,
          params.embeddings
        );
      },
      selector() {
        return true;
      }
    });
    plugin.registerChatChainProvider(
      "browsing",
      {
        "zh-CN": "浏览模式，可以从外部获取信息",
        "en-US": "Browsing mode, can get information from web"
      },
      async (params) => {
        const tools = getTools(
          ctx.chatluna.platform,
          (name2) => name2 === "web-search" || name2 === "web-browser" || name2 === "puppeteer_browser"
        );
        const keywordExtractModel = config.summaryModel.length > 0 ? await createModel(ctx, config.summaryModel) : void 0;
        const model = params.model;
        const options = {
          preset: params.preset,
          botName: params.botName,
          embeddings: params.embeddings,
          historyMemory: params.historyMemory,
          summaryType: config.summaryType,
          summaryModel: keywordExtractModel ?? params.model,
          thoughtMessage: ctx.chatluna.config.showThoughtMessage,
          searchPrompt: config.searchPrompt,
          newQuestionPrompt: config.newQuestionPrompt,
          contextualCompressionPrompt: config.contextualCompression ? config.contextualCompressionPrompt : void 0,
          searchFailedPrompt: config.searchFailedPrompt,
          variableService: ctx.chatluna.variable
        };
        return ChatLunaBrowsingChain.fromLLMAndTools(
          model,
          tools,
          options
        );
      }
    );
  });
  apply(ctx, config);
}
__name(apply11, "apply");
function getTools(service, filter) {
  const tools = service.getTools().filter(filter);
  return tools.map((name2) => ({
    name: name2,
    tool: service.getTool(name2)
  }));
}
__name(getTools, "getTools");
async function createModel(ctx, model) {
  logger.debug("create summary model: %s", model);
  if (model == null || model === "empty") {
    return null;
  }
  const [platform, modelName] = parseRawModelName2(model);
  await ctx.chatluna.awaitLoadPlatform(platform);
  return ctx.chatluna.createChatModel(
    platform,
    modelName
  );
}
__name(createModel, "createModel");
var Config4 = Schema12.intersect([
  ChatLunaPlugin.Config,
  Schema12.object({
    searchEngine: Schema12.array(
      Schema12.union([
        Schema12.const("free-google-api").description(
          "Free Google (API & Web)"
        ),
        Schema12.const("bing-web").description("Bing (Web)"),
        Schema12.const("bing-api").description("Bing (API)"),
        Schema12.const("duckduckgo-lite").description(
          "DuckDuckGo (Lite)"
        ),
        Schema12.const("serper").description("Serper (Google)"),
        Schema12.const("tavily").description("Tavily (API)"),
        Schema12.const("google-web").description("Google (Web)"),
        Schema12.const("wikipedia").description("Wikipedia"),
        Schema12.const("searxng").description("SearxNG")
      ])
    ).default(["free-google-api"]).role("select"),
    topK: Schema12.number().min(2).max(50).step(1).default(5),
    puppeteerTimeout: Schema12.number().default(6e4),
    puppeteerIdleTimeout: Schema12.number().default(3e5),
    summaryType: Schema12.union([
      Schema12.const("speed"),
      Schema12.const("balanced"),
      Schema12.const("quality")
    ]).default("speed"),
    mulitSourceMode: Schema12.union([
      Schema12.const("average"),
      Schema12.const("total")
    ]).default("average"),
    summaryModel: Schema12.dynamic("model").default("empty"),
    searchThreshold: Schema12.percent().step(0.01).default(0.25),
    contextualCompression: Schema12.boolean().default(false)
  }),
  Schema12.object({
    serperApiKey: Schema12.string().role("secret"),
    serperCountry: Schema12.string().default("cn"),
    serperLocation: Schema12.string().default("zh-cn"),
    serperSearchResults: Schema12.number().min(2).max(20).default(10)
  }),
  Schema12.object({
    bingSearchApiKey: Schema12.string().role("secret"),
    bingSearchLocation: Schema12.string().default("zh-CN"),
    azureLocation: Schema12.string().default("global")
  }),
  Schema12.object({
    tavilyApiKey: Schema12.string().role("secret")
  }),
  Schema12.object({
    freeSearchBaseURL: Schema12.string().default(
      "https://search.dingyi222666.top"
    )
  }),
  Schema12.object({
    wikipediaBaseURL: Schema12.array(Schema12.string()).default([
      "https://en.wikipedia.org/w/api.php",
      "https://mzh.moegirl.org.cn/api.php"
    ]),
    maxWikipediaDocContentLength: Schema12.number().default(5e3)
  }),
  Schema12.object({
    searxngBaseURL: Schema12.string().default("https://paulgo.io")
  }),
  Schema12.object({
    searchPrompt: Schema12.string().role("textarea").default(
      `Based on the search results, generate a detailed response with proper citations:

1. Main Content:
   - Present information in well-organized sections
   - Include specific details, data, and technical terms
   - Keep original language and terminology
   - Mark each key fact with a citation [^1]
   - For multiple sources, use sequential citations [^1][^2]

2. Media Content:
   - Include images when available: ![description](image_url)[^3]
   - Format tables and structured data properly

3. Organization:
   - Use clear section headings
   - Present information in logical order
   - Include bullet points for clarity
   - Highlight important quotes with proper attribution

Context:
<context>
    {context}
</context>

Output with citation References:
[^1]: [title](url)
[^2]: [title](url)
...

Output Language need same as user input language.`
    ),
    newQuestionPrompt: Schema12.string().role("textarea").default(
      `Analyze the follow-up question and return a JSON response based on the given conversation context.

Rules:
- CRITICAL: Use the exact same language as the input. Do not translate or change the language under any circumstances.
- Make the question self-contained and clear
- Optimize for search engine queries with time-sensitivity in mind
- Consider the current time: {time} when need formulating search queries
- ALWAYS generate 2-3 different search keywords/phrases for multi-source verification
- Do not add any explanations or additional content
- Base your response on a comprehensive analysis of the chat history
- Return your response in the following JSON format ONLY:
  {{
    "thought": "your reasoning about what to do with user input. Use the text language as the input",
    "action": "skip" | "search" | "url",
    "content": ["string1", "string2", ...] (optional array of strings)
  }}

Action types explanation:
1. "skip" - Use when the question doesn't require an internet search (e.g., personal opinions, simple calculations, or information already provided in the chat history)
   Example: {{ "thought": "This is asking for a personal opinion which doesn't require search", "action": "skip" }}

2. "search" - Use when you need to generate search-engine-friendly questions
   Example: For "What's the weather like in Tokyo and New York?"
   {{ "thought": "This requires checking current weather in two different cities as of {time}", "action": "search", "content": ["Current latest weather in Tokyo {time}", "Current latest weather in New York {time}", "Tokyo weather forecast today", "New York weather forecast today"] }}

3. "url" - Use when the message contains one or more URLs that should be browsed
   Example: For "Can you summarize the information from https://example.com/article and https://example.org/data?"
   {{ "thought": "This requires browsing two specific URLs to gather information", "action": "url", "content": ["https://example.com/article", "https://example.org/data"] }}

IMPORTANT:
- Your JSON response MUST be in the same language as the follow up input. This is crucial for maintaining context and accuracy.
- For time-sensitive queries (news, weather, events, etc.), ALWAYS include the current time {time} in your search queries.
- ALWAYS generate multiple (2-3) search queries for better coverage and verification from different sources.

Chat History:
{chat_history}
Current Time: {time}
Follow-up Input: {question}
JSON Response:`
    ),
    searchFailedPrompt: Schema12.string().role("textarea").default(
      `For query "{question}" with no search results:

1. Inform user about no results found
2. Offer base knowledge assistance with clear limitations:
   - Based on training data, not current info
   - May be outdated for time-sensitive topics
   - No recent developments included

Use same language as query. Suggest alternative search terms if possible.`
    ),
    contextualCompressionPrompt: Schema12.string().role("textarea").default(`Summarize the context based on the search action. Format in Markdown with citations. Return 'empty' if nothing relevant found.

Context:
<context>
    {context}
</context>

Action:
{action}

Output:
---
{{First paragraph as overview with citations[^1]}}

{{2-5 detail paragraphs with supporting information and citations[^2][^3]}}

## References
[^1]: [title1](url1)
[^2]: [title2](url2)
[^3]: [title3](url3)
---`)
  })
]).i18n({
  "zh-CN": require_zh_CN_schema(),
  "en-US": require_en_US_schema()
});
var inject = ["chatluna", "puppeteer"];
var name = "chatluna-search-service";
export {
  Config4 as Config,
  apply11 as apply,
  createModel,
  inject,
  logger,
  name
};
