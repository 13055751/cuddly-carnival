var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/locales/zh-CN.schema.yml
var require_zh_CN_schema = __commonJS({
  "src/locales/zh-CN.schema.yml"(exports2, module2) {
    module2.exports = { $inner: [{ $desc: "基础配置", qrCode: "是否生成右下角的二维码。", background: "背景图片地址，将会随机抽取其一。", blurAmount: "模糊程度，0 表示不模糊。", backgroundMaskOpacity: "背景蒙版透明度，范围 0-1。" }] };
  }
});

// src/locales/en-US.schema.yml
var require_en_US_schema = __commonJS({
  "src/locales/en-US.schema.yml"(exports2, module2) {
    module2.exports = { $inner: [{ $desc: "Basic Configuration", qrCode: "Whether to generate a QR code in the lower right corner.", background: "Background image address, which will be randomly selected.", blurAmount: "Blurring degree, 0 means no blurring.", backgroundMaskOpacity: "Background mask opacity, range 0-1." }] };
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  Config: () => Config,
  apply: () => apply,
  inject: () => inject,
  logger: () => logger3,
  name: () => name,
  usage: () => usage
});
module.exports = __toCommonJS(index_exports);
var import_koishi3 = require("koishi");
var import_chat = require("koishi-plugin-chatluna/services/chat");
var import_logger3 = require("koishi-plugin-chatluna/utils/logger");

// src/renders/image.ts
var import_marked = require("marked");
var import_logger = require("koishi-plugin-chatluna/utils/logger");
var import_fs = require("fs");
var import_koishi = require("koishi");
var import_marked_katex_extension = __toESM(require("marked-katex-extension"), 1);
var import_qrcode = __toESM(require("qrcode"), 1);
var import_highlight = __toESM(require("highlight.js"), 1);
var import_marked_highlight = require("marked-highlight");
var import_request = require("koishi-plugin-chatluna/utils/request");
var import_promise = require("koishi-plugin-chatluna/utils/promise");
var import_koishi_plugin_chatluna = require("koishi-plugin-chatluna");
var import_path = __toESM(require("path"), 1);
var import_promises = __toESM(require("fs/promises"), 1);
var logger;
var ImageRenderer = class extends import_koishi_plugin_chatluna.Renderer {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    logger = (0, import_logger.createLogger)(ctx);
    this._marked = new import_marked.Marked(
      (0, import_marked_katex_extension.default)({
        throwOnError: false,
        displayMode: false,
        nonStandard: true,
        macros: {
          "\\ge": "\\geqslant",
          "\\le": "\\leqslant",
          "\\geq": "\\geqslant",
          "\\leq": "\\leqslant"
        },
        output: "html"
      }),
      (0, import_marked_highlight.markedHighlight)({
        langPrefix: "hljs language-",
        //  langPrefix: 'hljs language-',
        highlight(code, lang) {
          if (code.match(/^sequenceDiagram/) || code.match(/^graph/) || lang === "mermaid") {
            return '<pre class="mermaid">' + code + "</pre>";
          }
          return `<pre><code class="hljs">${import_highlight.default.highlightAuto(code, [lang]).value}</code></pre>`;
        }
      })
    );
    ctx.on("dispose", async () => {
      await this.__page?.close();
    });
  }
  static {
    __name(this, "ImageRenderer");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __page;
  _marked;
  async _page() {
    if (!this.__page) {
      this.__page = await this.ctx.puppeteer.page();
    }
    return this.__page;
  }
  async render(message, options) {
    const markdownText = message.content;
    const page = await this._page();
    const templateDir = import_path.default.resolve(
      this.ctx.baseDir,
      "data/chathub/render_template"
    );
    const templateHtmlPath = import_path.default.resolve(templateDir, "template.html");
    const randomId = Math.random().toString(36).substring(2, 15);
    const outTemplateHtmlPath = import_path.default.resolve(
      templateDir,
      `${randomId}.html`
    );
    const templateHtml = (0, import_fs.readFileSync)(templateHtmlPath).toString();
    let qrCode = "";
    if (this.config.qrCode) {
      qrCode = await (0, import_promise.runAsyncTimeout)(
        this._textToQRCode(markdownText),
        7500,
        ""
      );
    }
    const content = await this._renderMarkdownToHtml(markdownText);
    const outTemplateHtml = renderTemplate(templateHtml, {
      content,
      qr_data: qrCode,
      background: randomArrayItem(this.config.background),
      blurAmount: this.config.blurAmount.toString(),
      backgroundMaskOpacity: this.config.backgroundMaskOpacity.toString()
    });
    (0, import_fs.writeFileSync)(outTemplateHtmlPath, outTemplateHtml);
    await page.reload();
    await page.goto("file://" + outTemplateHtmlPath, {
      waitUntil: "networkidle0",
      timeout: 40 * 1e3
    });
    const app = await page.$("body");
    const clip = await app.boundingBox();
    const screenshot = await page.screenshot({ clip });
    this.ctx.setTimeout(async () => {
      await import_promises.default.unlink(outTemplateHtmlPath);
    }, 1e3);
    return {
      element: import_koishi.h.image(screenshot, "image/png")
    };
  }
  async _renderMarkdownToHtml(text) {
    return await this._marked.parse(escapeBrackets(text), {
      gfm: true
    });
  }
  async _textToQRCode(markdownText) {
    const response = await (0, import_request.chatLunaFetch)(
      "https://prod.pastebin.prod.webservices.mozgcp.net/api/",
      {
        method: "POST",
        body: new URLSearchParams({
          expires: "604800",
          format: "url",
          lexer: "_markdown",
          content: markdownText
        })
      }
    );
    const url = await response.text();
    logger.debug("pastebin url: " + url);
    const qrcodeDataURL = await new Promise((resolve, reject) => {
      import_qrcode.default.toDataURL(url, { errorCorrectionLevel: "H" }, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
    return qrcodeDataURL;
  }
  schema = import_koishi.Schema.const("image").i18n({
    "zh-CN": "将回复渲染为图片",
    "en-US": "Render as image"
  });
};
function renderTemplate(template, data) {
  return template.replace(/\${(.*?)}/g, (_, key) => data[key] || "");
}
__name(renderTemplate, "renderTemplate");
function randomArrayItem(array) {
  return array[Math.floor(Math.random() * array.length)];
}
__name(randomArrayItem, "randomArrayItem");
function escapeBrackets(text) {
  const pattern = /\\\[([\s\S]*?[^\\])\\\]|\\\((.*?)\\\)/gm;
  const result = text.replace(
    pattern,
    (match, squareContent, roundContent) => {
      if (squareContent) {
        return `$$${squareContent}$$`;
      } else if (roundContent) {
        return `$${roundContent}$`;
      }
      return match;
    }
  );
  return result;
}
__name(escapeBrackets, "escapeBrackets");

// src/renders/mixed-image.ts
var import_marked2 = require("marked");
var import_logger2 = require("koishi-plugin-chatluna/utils/logger");
var import_fs2 = require("fs");
var import_koishi2 = require("koishi");
var import_marked_katex_extension2 = __toESM(require("marked-katex-extension"), 1);
var import_qrcode2 = __toESM(require("qrcode"), 1);
var import_highlight2 = __toESM(require("highlight.js"), 1);
var import_marked_highlight2 = require("marked-highlight");
var import_request2 = require("koishi-plugin-chatluna/utils/request");
var import_promise2 = require("koishi-plugin-chatluna/utils/promise");
var import_koishi_plugin_chatluna2 = require("koishi-plugin-chatluna");
var import_path2 = __toESM(require("path"), 1);
var import_promises2 = __toESM(require("fs/promises"), 1);
var logger2;
var MixedImageRenderer = class extends import_koishi_plugin_chatluna2.Renderer {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    logger2 = (0, import_logger2.createLogger)(ctx);
    this._marked = new import_marked2.Marked(
      (0, import_marked_katex_extension2.default)({
        throwOnError: false,
        displayMode: false,
        nonStandard: true,
        output: "html"
      }),
      (0, import_marked_highlight2.markedHighlight)({
        langPrefix: "hljs language-",
        //  langPrefix: 'hljs language-',
        highlight(code, lang) {
          if (code.match(/^sequenceDiagram/) || code.match(/^graph/) || lang === "mermaid") {
            return '<pre class="mermaid">' + code + "</pre>";
          }
          return `<pre><code class="hljs">${import_highlight2.default.highlightAuto(code, [lang]).value}</code></pre>`;
        }
      })
    );
    ctx.on("dispose", async () => {
      await this.__page?.close();
    });
  }
  static {
    __name(this, "MixedImageRenderer");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __page;
  _marked;
  async _page() {
    if (!this.__page) {
      this.__page = await this.ctx.puppeteer.page();
    }
    return this.__page;
  }
  async render(message, options) {
    const elements = [];
    const content = message.content;
    const tokens = import_marked2.marked.lexer(content);
    const matchedTexts = this._matchText(tokens);
    const mergedMatchedTexts = [];
    for (let i = 0; i < matchedTexts.length; i++) {
      const lastMatchedText = mergedMatchedTexts[mergedMatchedTexts.length - 1];
      const currentMatchedText = matchedTexts[i];
      if (lastMatchedText?.type === currentMatchedText.type) {
        mergedMatchedTexts.pop();
        mergedMatchedTexts.push({
          type: currentMatchedText.type,
          text: lastMatchedText.text + currentMatchedText.text
        });
      } else {
        mergedMatchedTexts.push(currentMatchedText);
      }
    }
    logger2.debug(
      `mergedMatchedTexts: ${JSON.stringify(mergedMatchedTexts)}`
    );
    for (const matchedText of mergedMatchedTexts) {
      if (matchedText.type === "markdown") {
        const image = await this._renderMarkdownToImage(
          matchedText.text
        );
        const element = import_koishi2.h.image(image, "image/png");
        if (options.split) {
          elements.push((0, import_koishi2.h)("message", element));
        } else {
          elements.push(element);
        }
      } else {
        if (options.split) {
          matchedText.text.split("\n\n").forEach((text) => {
            elements.push((0, import_koishi2.h)("message", import_koishi2.h.text(text)));
          });
        } else {
          elements.push(import_koishi2.h.text(matchedText.text));
        }
      }
    }
    return {
      element: elements
    };
  }
  _matchText(tokens) {
    const currentMatchedTexts = [];
    for (const token of tokens) {
      if (token.type === "text" || token.type === "del" || token.type === "br") {
        currentMatchedTexts.push({
          type: "text",
          text: token.raw
        });
      } else if (token.type === "code" || token.type === "image" || token.type === "html" || token.type === "table") {
        currentMatchedTexts.push({
          type: "markdown",
          text: token.raw
        });
      } else if (token.type === "paragraph") {
        const matchedTexts = this._matchText(token.tokens);
        currentMatchedTexts.push(...matchedTexts);
      } else if (token.type === "space") {
        const currentMatchedText = currentMatchedTexts[currentMatchedTexts.length - 1];
        currentMatchedText.text = currentMatchedText.text + token.raw;
      } else {
        currentMatchedTexts.length = 0;
        currentMatchedTexts.push({
          type: "markdown",
          text: tokens.map((token2) => token2.raw).join("")
        });
        break;
      }
    }
    return currentMatchedTexts;
  }
  async _renderMarkdownToImage(markdownText) {
    const page = await this._page();
    const templateDir = import_path2.default.resolve(
      this.ctx.baseDir,
      "data/chathub/render_template"
    );
    const templateHtmlPath = import_path2.default.resolve(templateDir, "template.html");
    const randomId = Math.random().toString(36).substring(2, 15);
    const outTemplateHtmlPath = import_path2.default.resolve(
      templateDir,
      `${randomId}.html`
    );
    const templateHtml = (0, import_fs2.readFileSync)(templateHtmlPath).toString();
    let qrCode = "";
    if (this.config.qrCode) {
      qrCode = await (0, import_promise2.runAsyncTimeout)(
        this._textToQrcode(markdownText),
        7500,
        ""
      );
    }
    const content = await this._renderMarkdownToHtml(markdownText);
    const outTemplateHtml = renderTemplate(templateHtml, {
      content,
      qr_data: qrCode,
      background: randomArrayItem(this.config.background),
      blurAmount: this.config.blurAmount.toString(),
      backgroundMaskOpacity: this.config.backgroundMaskOpacity.toString()
    });
    (0, import_fs2.writeFileSync)(outTemplateHtmlPath, outTemplateHtml);
    await page.reload();
    await page.goto("file://" + outTemplateHtmlPath, {
      waitUntil: "networkidle0",
      timeout: 30 * 1e3
    });
    const app = await page.$("body");
    const clip = await app.boundingBox();
    const result = await page.screenshot({ clip });
    this.ctx.setTimeout(async () => {
      await import_promises2.default.unlink(outTemplateHtmlPath);
    }, 1e3);
    return result;
  }
  async _renderMarkdownToHtml(text) {
    return await this._marked.parse(escapeBrackets(text), {
      gfm: true
    });
  }
  async _textToQrcode(markdownText) {
    const response = await (0, import_request2.chatLunaFetch)(
      "https://prod.pastebin.prod.webservices.mozgcp.net/api/",
      {
        method: "POST",
        body: new URLSearchParams({
          expires: "604800",
          format: "url",
          lexer: "_markdown",
          content: markdownText
        })
      }
    );
    const url = await response.text();
    logger2.debug("pastebin url: " + url);
    const qrcodeDataURL = await new Promise((resolve, reject) => {
      import_qrcode2.default.toDataURL(url, { errorCorrectionLevel: "H" }, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
    return qrcodeDataURL;
  }
  schema = import_koishi2.Schema.const("mixed-image").i18n({
    "zh-CN": "同时输出图片和文本",
    "en-US": "Output both image and text"
  });
};

// src/index.ts
var import_path3 = __toESM(require("path"), 1);
var import_url = require("url");
var import_promises3 = __toESM(require("fs/promises"), 1);
var import_meta = {};
var logger3;
function apply(ctx, config) {
  logger3 = (0, import_logger3.createLogger)(ctx, "chatluna-image-renderer");
  const plugin = new import_chat.ChatLunaPlugin(
    ctx,
    config,
    "image-renderer",
    false
  );
  const templateDir = import_path3.default.resolve(
    ctx.baseDir,
    "data/chathub/render_template"
  );
  ctx.on("ready", async () => {
    plugin.registerToService();
    const dirname2 = __dirname?.length > 0 ? __dirname : (0, import_url.fileURLToPath)(import_meta.url);
    const templateHtmlDir = dirname2 + "/../resources";
    try {
      await import_promises3.default.access(templateDir);
    } catch (error) {
      await import_promises3.default.mkdir(templateDir, { recursive: true });
      await import_promises3.default.cp(templateHtmlDir, templateDir, { recursive: true });
    }
    const tempHtmlFiles = await import_promises3.default.readdir(templateDir).then(
      (files) => files.filter(
        (file) => file.endsWith(".html") && !file.startsWith("template")
      )
    );
    for (const file of tempHtmlFiles) {
      await import_promises3.default.unlink(import_path3.default.resolve(templateDir, file));
    }
    ctx.effect(
      () => ctx.chatluna.renderer.addRenderer("image", (_) => {
        return new ImageRenderer(ctx, config);
      })
    );
    ctx.effect(
      () => ctx.chatluna.renderer.addRenderer("mixed-image", (_) => {
        return new MixedImageRenderer(ctx, config);
      })
    );
  });
}
__name(apply, "apply");
var dirname = __dirname?.length > 0 ? __dirname : (0, import_url.fileURLToPath)(import_meta.url);
var imageDir = (0, import_url.pathToFileURL)(import_path3.default.join(dirname, "../resources")).href;
var Config = import_koishi3.Schema.intersect([
  import_koishi3.Schema.object({
    background: import_koishi3.Schema.array(String).role("table").default([`${imageDir}/background/default.webp`]),
    blurAmount: import_koishi3.Schema.natural().default(12).min(0),
    backgroundMaskOpacity: import_koishi3.Schema.natural().max(1).step(0.01).default(0.5),
    qrCode: import_koishi3.Schema.boolean().default(false)
  })
]).i18n({
  "zh-CN": require_zh_CN_schema(),
  "en-US": require_en_US_schema()
});
var usage = `
模版路径在[\`data/chathub/render_template/template.html\`](../files/data/chathub/render_template/template.html)，你可以自由更改 html 文件，只需要注意 \${xx} 的格式为渲染时传入的参数，不要随意修改。`;
var inject = ["chatluna", "puppeteer"];
var name = "chatluna-image-renderer";
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Config,
  apply,
  inject,
  logger,
  name,
  usage
});
