var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/locales/zh-CN.schema.yml
var require_zh_CN_schema = __commonJS({
  "src/locales/zh-CN.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "基础配置", qrCode: "是否生成右下角的二维码。", background: "背景图片地址，将会随机抽取其一。", blurAmount: "模糊程度，0 表示不模糊。", backgroundMaskOpacity: "背景蒙版透明度，范围 0-1。" }] };
  }
});

// src/locales/en-US.schema.yml
var require_en_US_schema = __commonJS({
  "src/locales/en-US.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "Basic Configuration", qrCode: "Whether to generate a QR code in the lower right corner.", background: "Background image address, which will be randomly selected.", blurAmount: "Blurring degree, 0 means no blurring.", backgroundMaskOpacity: "Background mask opacity, range 0-1." }] };
  }
});

// src/index.ts
import { Schema as Schema3 } from "koishi";
import { ChatLunaPlugin } from "koishi-plugin-chatluna/services/chat";
import { createLogger as createLogger3 } from "koishi-plugin-chatluna/utils/logger";

// src/renders/image.ts
import { Marked } from "marked";
import { createLogger } from "koishi-plugin-chatluna/utils/logger";
import { readFileSync, writeFileSync } from "fs";
import { h, Schema } from "koishi";
import markedKatex from "marked-katex-extension";
import qrcode from "qrcode";
import hljs from "highlight.js";
import { markedHighlight } from "marked-highlight";
import { chatLunaFetch } from "koishi-plugin-chatluna/utils/request";
import { runAsyncTimeout } from "koishi-plugin-chatluna/utils/promise";
import {
  Renderer
} from "koishi-plugin-chatluna";
import path from "path";
import fs from "fs/promises";
var logger;
var ImageRenderer = class extends Renderer {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    logger = createLogger(ctx);
    this._marked = new Marked(
      markedKatex({
        throwOnError: false,
        displayMode: false,
        nonStandard: true,
        macros: {
          "\\ge": "\\geqslant",
          "\\le": "\\leqslant",
          "\\geq": "\\geqslant",
          "\\leq": "\\leqslant"
        },
        output: "html"
      }),
      markedHighlight({
        langPrefix: "hljs language-",
        //  langPrefix: 'hljs language-',
        highlight(code, lang) {
          if (code.match(/^sequenceDiagram/) || code.match(/^graph/) || lang === "mermaid") {
            return '<pre class="mermaid">' + code + "</pre>";
          }
          return `<pre><code class="hljs">${hljs.highlightAuto(code, [lang]).value}</code></pre>`;
        }
      })
    );
    ctx.on("dispose", async () => {
      await this.__page?.close();
    });
  }
  static {
    __name(this, "ImageRenderer");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __page;
  _marked;
  async _page() {
    if (!this.__page) {
      this.__page = await this.ctx.puppeteer.page();
    }
    return this.__page;
  }
  async render(message, options) {
    const markdownText = message.content;
    const page = await this._page();
    const templateDir = path.resolve(
      this.ctx.baseDir,
      "data/chathub/render_template"
    );
    const templateHtmlPath = path.resolve(templateDir, "template.html");
    const randomId = Math.random().toString(36).substring(2, 15);
    const outTemplateHtmlPath = path.resolve(
      templateDir,
      `${randomId}.html`
    );
    const templateHtml = readFileSync(templateHtmlPath).toString();
    let qrCode = "";
    if (this.config.qrCode) {
      qrCode = await runAsyncTimeout(
        this._textToQRCode(markdownText),
        7500,
        ""
      );
    }
    const content = await this._renderMarkdownToHtml(markdownText);
    const outTemplateHtml = renderTemplate(templateHtml, {
      content,
      qr_data: qrCode,
      background: randomArrayItem(this.config.background),
      blurAmount: this.config.blurAmount.toString(),
      backgroundMaskOpacity: this.config.backgroundMaskOpacity.toString()
    });
    writeFileSync(outTemplateHtmlPath, outTemplateHtml);
    await page.reload();
    await page.goto("file://" + outTemplateHtmlPath, {
      waitUntil: "networkidle0",
      timeout: 40 * 1e3
    });
    const app = await page.$("body");
    const clip = await app.boundingBox();
    const screenshot = await page.screenshot({ clip });
    this.ctx.setTimeout(async () => {
      await fs.unlink(outTemplateHtmlPath);
    }, 1e3);
    return {
      element: h.image(screenshot, "image/png")
    };
  }
  async _renderMarkdownToHtml(text) {
    return await this._marked.parse(escapeBrackets(text), {
      gfm: true
    });
  }
  async _textToQRCode(markdownText) {
    const response = await chatLunaFetch(
      "https://prod.pastebin.prod.webservices.mozgcp.net/api/",
      {
        method: "POST",
        body: new URLSearchParams({
          expires: "604800",
          format: "url",
          lexer: "_markdown",
          content: markdownText
        })
      }
    );
    const url = await response.text();
    logger.debug("pastebin url: " + url);
    const qrcodeDataURL = await new Promise((resolve, reject) => {
      qrcode.toDataURL(url, { errorCorrectionLevel: "H" }, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
    return qrcodeDataURL;
  }
  schema = Schema.const("image").i18n({
    "zh-CN": "将回复渲染为图片",
    "en-US": "Render as image"
  });
};
function renderTemplate(template, data) {
  return template.replace(/\${(.*?)}/g, (_, key) => data[key] || "");
}
__name(renderTemplate, "renderTemplate");
function randomArrayItem(array) {
  return array[Math.floor(Math.random() * array.length)];
}
__name(randomArrayItem, "randomArrayItem");
function escapeBrackets(text) {
  const pattern = /\\\[([\s\S]*?[^\\])\\\]|\\\((.*?)\\\)/gm;
  const result = text.replace(
    pattern,
    (match, squareContent, roundContent) => {
      if (squareContent) {
        return `$$${squareContent}$$`;
      } else if (roundContent) {
        return `$${roundContent}$`;
      }
      return match;
    }
  );
  return result;
}
__name(escapeBrackets, "escapeBrackets");

// src/renders/mixed-image.ts
import { Marked as Marked2, marked } from "marked";
import { createLogger as createLogger2 } from "koishi-plugin-chatluna/utils/logger";
import { readFileSync as readFileSync2, writeFileSync as writeFileSync2 } from "fs";
import { h as h2, Schema as Schema2 } from "koishi";
import markedKatex2 from "marked-katex-extension";
import qrcode2 from "qrcode";
import hljs2 from "highlight.js";
import { markedHighlight as markedHighlight2 } from "marked-highlight";
import { chatLunaFetch as chatLunaFetch2 } from "koishi-plugin-chatluna/utils/request";
import { runAsyncTimeout as runAsyncTimeout2 } from "koishi-plugin-chatluna/utils/promise";
import {
  Renderer as Renderer2
} from "koishi-plugin-chatluna";
import path2 from "path";
import fs2 from "fs/promises";
var logger2;
var MixedImageRenderer = class extends Renderer2 {
  constructor(ctx, config) {
    super(ctx);
    this.ctx = ctx;
    this.config = config;
    logger2 = createLogger2(ctx);
    this._marked = new Marked2(
      markedKatex2({
        throwOnError: false,
        displayMode: false,
        nonStandard: true,
        output: "html"
      }),
      markedHighlight2({
        langPrefix: "hljs language-",
        //  langPrefix: 'hljs language-',
        highlight(code, lang) {
          if (code.match(/^sequenceDiagram/) || code.match(/^graph/) || lang === "mermaid") {
            return '<pre class="mermaid">' + code + "</pre>";
          }
          return `<pre><code class="hljs">${hljs2.highlightAuto(code, [lang]).value}</code></pre>`;
        }
      })
    );
    ctx.on("dispose", async () => {
      await this.__page?.close();
    });
  }
  static {
    __name(this, "MixedImageRenderer");
  }
  // eslint-disable-next-line @typescript-eslint/naming-convention
  __page;
  _marked;
  async _page() {
    if (!this.__page) {
      this.__page = await this.ctx.puppeteer.page();
    }
    return this.__page;
  }
  async render(message, options) {
    const elements = [];
    const content = message.content;
    const tokens = marked.lexer(content);
    const matchedTexts = this._matchText(tokens);
    const mergedMatchedTexts = [];
    for (let i = 0; i < matchedTexts.length; i++) {
      const lastMatchedText = mergedMatchedTexts[mergedMatchedTexts.length - 1];
      const currentMatchedText = matchedTexts[i];
      if (lastMatchedText?.type === currentMatchedText.type) {
        mergedMatchedTexts.pop();
        mergedMatchedTexts.push({
          type: currentMatchedText.type,
          text: lastMatchedText.text + currentMatchedText.text
        });
      } else {
        mergedMatchedTexts.push(currentMatchedText);
      }
    }
    logger2.debug(
      `mergedMatchedTexts: ${JSON.stringify(mergedMatchedTexts)}`
    );
    for (const matchedText of mergedMatchedTexts) {
      if (matchedText.type === "markdown") {
        const image = await this._renderMarkdownToImage(
          matchedText.text
        );
        const element = h2.image(image, "image/png");
        if (options.split) {
          elements.push(h2("message", element));
        } else {
          elements.push(element);
        }
      } else {
        if (options.split) {
          matchedText.text.split("\n\n").forEach((text) => {
            elements.push(h2("message", h2.text(text)));
          });
        } else {
          elements.push(h2.text(matchedText.text));
        }
      }
    }
    return {
      element: elements
    };
  }
  _matchText(tokens) {
    const currentMatchedTexts = [];
    for (const token of tokens) {
      if (token.type === "text" || token.type === "del" || token.type === "br") {
        currentMatchedTexts.push({
          type: "text",
          text: token.raw
        });
      } else if (token.type === "code" || token.type === "image" || token.type === "html" || token.type === "table") {
        currentMatchedTexts.push({
          type: "markdown",
          text: token.raw
        });
      } else if (token.type === "paragraph") {
        const matchedTexts = this._matchText(token.tokens);
        currentMatchedTexts.push(...matchedTexts);
      } else if (token.type === "space") {
        const currentMatchedText = currentMatchedTexts[currentMatchedTexts.length - 1];
        currentMatchedText.text = currentMatchedText.text + token.raw;
      } else {
        currentMatchedTexts.length = 0;
        currentMatchedTexts.push({
          type: "markdown",
          text: tokens.map((token2) => token2.raw).join("")
        });
        break;
      }
    }
    return currentMatchedTexts;
  }
  async _renderMarkdownToImage(markdownText) {
    const page = await this._page();
    const templateDir = path2.resolve(
      this.ctx.baseDir,
      "data/chathub/render_template"
    );
    const templateHtmlPath = path2.resolve(templateDir, "template.html");
    const randomId = Math.random().toString(36).substring(2, 15);
    const outTemplateHtmlPath = path2.resolve(
      templateDir,
      `${randomId}.html`
    );
    const templateHtml = readFileSync2(templateHtmlPath).toString();
    let qrCode = "";
    if (this.config.qrCode) {
      qrCode = await runAsyncTimeout2(
        this._textToQrcode(markdownText),
        7500,
        ""
      );
    }
    const content = await this._renderMarkdownToHtml(markdownText);
    const outTemplateHtml = renderTemplate(templateHtml, {
      content,
      qr_data: qrCode,
      background: randomArrayItem(this.config.background),
      blurAmount: this.config.blurAmount.toString(),
      backgroundMaskOpacity: this.config.backgroundMaskOpacity.toString()
    });
    writeFileSync2(outTemplateHtmlPath, outTemplateHtml);
    await page.reload();
    await page.goto("file://" + outTemplateHtmlPath, {
      waitUntil: "networkidle0",
      timeout: 30 * 1e3
    });
    const app = await page.$("body");
    const clip = await app.boundingBox();
    const result = await page.screenshot({ clip });
    this.ctx.setTimeout(async () => {
      await fs2.unlink(outTemplateHtmlPath);
    }, 1e3);
    return result;
  }
  async _renderMarkdownToHtml(text) {
    return await this._marked.parse(escapeBrackets(text), {
      gfm: true
    });
  }
  async _textToQrcode(markdownText) {
    const response = await chatLunaFetch2(
      "https://prod.pastebin.prod.webservices.mozgcp.net/api/",
      {
        method: "POST",
        body: new URLSearchParams({
          expires: "604800",
          format: "url",
          lexer: "_markdown",
          content: markdownText
        })
      }
    );
    const url = await response.text();
    logger2.debug("pastebin url: " + url);
    const qrcodeDataURL = await new Promise((resolve, reject) => {
      qrcode2.toDataURL(url, { errorCorrectionLevel: "H" }, (err, url2) => {
        if (err) {
          reject(err);
        } else {
          resolve(url2);
        }
      });
    });
    return qrcodeDataURL;
  }
  schema = Schema2.const("mixed-image").i18n({
    "zh-CN": "同时输出图片和文本",
    "en-US": "Output both image and text"
  });
};

// src/index.ts
import path3 from "path";
import { fileURLToPath, pathToFileURL } from "url";
import fs3 from "fs/promises";
var logger3;
function apply(ctx, config) {
  logger3 = createLogger3(ctx, "chatluna-image-renderer");
  const plugin = new ChatLunaPlugin(
    ctx,
    config,
    "image-renderer",
    false
  );
  const templateDir = path3.resolve(
    ctx.baseDir,
    "data/chathub/render_template"
  );
  ctx.on("ready", async () => {
    plugin.registerToService();
    const dirname2 = __dirname?.length > 0 ? __dirname : fileURLToPath(import.meta.url);
    const templateHtmlDir = dirname2 + "/../resources";
    try {
      await fs3.access(templateDir);
    } catch (error) {
      await fs3.mkdir(templateDir, { recursive: true });
      await fs3.cp(templateHtmlDir, templateDir, { recursive: true });
    }
    const tempHtmlFiles = await fs3.readdir(templateDir).then(
      (files) => files.filter(
        (file) => file.endsWith(".html") && !file.startsWith("template")
      )
    );
    for (const file of tempHtmlFiles) {
      await fs3.unlink(path3.resolve(templateDir, file));
    }
    ctx.effect(
      () => ctx.chatluna.renderer.addRenderer("image", (_) => {
        return new ImageRenderer(ctx, config);
      })
    );
    ctx.effect(
      () => ctx.chatluna.renderer.addRenderer("mixed-image", (_) => {
        return new MixedImageRenderer(ctx, config);
      })
    );
  });
}
__name(apply, "apply");
var dirname = __dirname?.length > 0 ? __dirname : fileURLToPath(import.meta.url);
var imageDir = pathToFileURL(path3.join(dirname, "../resources")).href;
var Config = Schema3.intersect([
  Schema3.object({
    background: Schema3.array(String).role("table").default([`${imageDir}/background/default.webp`]),
    blurAmount: Schema3.natural().default(12).min(0),
    backgroundMaskOpacity: Schema3.natural().max(1).step(0.01).default(0.5),
    qrCode: Schema3.boolean().default(false)
  })
]).i18n({
  "zh-CN": require_zh_CN_schema(),
  "en-US": require_en_US_schema()
});
var usage = `
模版路径在[\`data/chathub/render_template/template.html\`](../files/data/chathub/render_template/template.html)，你可以自由更改 html 文件，只需要注意 \${xx} 的格式为渲染时传入的参数，不要随意修改。`;
var inject = ["chatluna", "puppeteer"];
var name = "chatluna-image-renderer";
export {
  Config,
  apply,
  inject,
  logger3 as logger,
  name,
  usage
};
