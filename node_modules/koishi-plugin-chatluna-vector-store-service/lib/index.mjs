var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// src/locales/zh-CN.schema.yml
var require_zh_CN_schema = __commonJS({
  "src/locales/zh-CN.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "向量数据库设置", vectorStore: "向量数据库类型" }, { $desc: "Redis 数据库设置", redisUrl: "Redis url 地址" }, { $desc: "Milvus 数据库设置", milvusUrl: "Milvus url 地址", milvusUsername: "Milvus 用户名", milvusPassword: "Milvus 密码" }, { $desc: "Neo4j 数据库设置", neo4jUrl: "Neo4j url 地址", neo4jUsername: "Neo4j 用户名", neo4jPassword: "Neo4j 密码" }] };
  }
});

// src/locales/en-US.schema.yml
var require_en_US_schema = __commonJS({
  "src/locales/en-US.schema.yml"(exports, module) {
    module.exports = { $inner: [{ $desc: "Vector database settings", vectorStore: "Vector database type" }, { $desc: "Redis database settings", redisUrl: "Redis url address" }, { $desc: "Milvus database settings", milvusUrl: "Milvus url address", milvusUsername: "Milvus username", milvusPassword: "Milvus password" }, { $desc: "Neo4j database settings", neo4jUrl: "Neo4j url address", neo4jUsername: "Neo4j username", neo4jPassword: "Neo4j password" }] };
  }
});

// src/index.ts
import { ChatLunaPlugin } from "koishi-plugin-chatluna/services/chat";
import { Schema } from "koishi";

// src/vectorstore/faiss.ts
import { ChatLunaSaveableVectorStore } from "koishi-plugin-chatluna/llm-core/model/base";
import { FaissStore } from "@langchain/community/vectorstores/faiss";
import path from "path";
import fs from "fs/promises";
import { createLogger } from "koishi-plugin-chatluna/utils/logger";
import crypto2 from "crypto";
var logger;
async function apply(ctx, config, plugin) {
  logger = createLogger(ctx, "chatluna-vector-store-service");
  if (!config.vectorStore.includes("faiss")) {
    return;
  }
  await FaissStore.importFaiss();
  plugin.registerVectorStore("faiss", async (params) => {
    const embeddings = params.embeddings;
    let faissStore;
    const directory = path.join(
      "data/chathub/vector_store/faiss",
      params.key ?? "chatluna"
    );
    try {
      await fs.access(directory);
    } catch {
      await fs.mkdir(directory, { recursive: true });
    }
    const jsonFile = path.join(directory, "docstore.json");
    logger.debug(`Loading faiss store from %c`, directory);
    try {
      await fs.access(jsonFile);
      faissStore = await FaissStore.load(directory, embeddings);
      const testVector = await embeddings.embedQuery("test");
      if (testVector.length === 0) {
        throw new Error(
          "Embedding dismension is 0, Try to change the embeddings model."
        );
      }
      if (testVector.length !== faissStore.index.getDimension()) {
        logger.error(
          `embeddings dimension mismatch: ${testVector.length} !== ${faissStore.index.getDimension()}. The faiss store will be cleared.`
        );
        throw new Error("embeddings dimension mismatch");
      }
    } catch (e) {
      if (e instanceof Error && e.message.includes("embeddings dismension is 0")) {
        throw e;
      }
      faissStore = await FaissStore.fromTexts(
        ["sample"],
        [" "],
        embeddings
      );
      try {
        await faissStore.save(directory);
      } catch (e2) {
        logger.error(e2);
      }
    }
    if (faissStore == null) {
      throw new Error("failed to load faiss store");
    }
    const wrapperStore = new ChatLunaSaveableVectorStore(
      faissStore,
      {
        async saveableFunction(store) {
          await store.save(directory);
        },
        async deletableFunction(store, options) {
          if (options.deleteAll) {
            await fs.rm(directory, { recursive: true });
            return;
          }
          const ids = [];
          if (options.ids) {
            ids.push(...options.ids);
          }
          if (options.documents) {
            const ids2 = options.documents?.map((document) => {
              return document.metadata?.raw_id;
            }).filter((id) => id != null);
            ids2.push(...ids2);
          }
          if (ids.length > 0) {
            await store.delete({ ids });
          }
        },
        async addDocumentsFunction(store, documents, options) {
          let ids = options?.ids ?? [];
          ids = documents.map((document, i) => {
            const id = ids[i] ?? crypto2.randomUUID();
            document.metadata = {
              ...document.metadata,
              raw_id: id
            };
            return id;
          });
          await store.addDocuments(documents, {
            ids
          });
        },
        async freeFunction() {
          faissStore = void 0;
        }
      }
    );
    return wrapperStore;
  });
}
__name(apply, "apply");

// src/vectorstore/lunavdb.ts
import { LunaVDB as LunaDB } from "@chatluna/luna-vdb";
import { SaveableVectorStore } from "@langchain/core/vectorstores";
import { Document } from "@langchain/core/documents";
import { SynchronousInMemoryDocstore } from "@langchain/community/stores/doc/in_memory";
import crypto3 from "crypto";
import { ChatLunaSaveableVectorStore as ChatLunaSaveableVectorStore2 } from "koishi-plugin-chatluna/llm-core/model/base";
import path2 from "path";
import fs2 from "fs/promises";
import { createLogger as createLogger2 } from "koishi-plugin-chatluna/utils/logger";
var logger2;
async function apply2(ctx, config, plugin) {
  logger2 = createLogger2(ctx, "chatluna-vector-store-service");
  if (!config.vectorStore.includes("luna-vdb")) {
    return;
  }
  plugin.registerVectorStore("luna-vdb", async (params) => {
    const embeddings = params.embeddings;
    let lunaDBStore;
    const directory = path2.join(
      "data/chathub/vector_store/luna_vdb",
      params.key ?? "chatluna"
    );
    try {
      await fs2.access(directory);
    } catch {
      await fs2.mkdir(directory, { recursive: true });
    }
    const jsonFile = path2.join(directory, "docstore.json");
    logger2.debug(`Loading luna vdb store from %c`, directory);
    try {
      await fs2.access(jsonFile);
      lunaDBStore = await LunaDBVectorStore.load(directory, embeddings);
      const testVector = await embeddings.embedQuery("test");
      if (testVector.length === 0) {
        throw new Error(
          "Embedding dismension is 0, Try to change the embeddings model."
        );
      }
      await lunaDBStore.similaritySearchVectorWithScore(testVector, 1);
    } catch (e) {
      if (e instanceof Error && e.message.includes("embeddings dismension is 0")) {
        throw e;
      }
      lunaDBStore = new LunaDBVectorStore(new LunaDB(), embeddings);
      logger2.debug(`Creating new luna vdb store`);
      try {
        await lunaDBStore.save(directory);
      } catch (e2) {
        logger2.error(e2);
      }
    }
    if (lunaDBStore == null) {
      throw new Error("failed to load luna vdb store");
    }
    const wrapperStore = new ChatLunaSaveableVectorStore2(
      lunaDBStore,
      {
        async saveableFunction(store) {
          await store.save(directory);
        },
        async deletableFunction(store, options) {
          if (options.deleteAll) {
            await fs2.rm(directory, { recursive: true });
            await lunaDBStore.delete({ deleteAll: true });
            return;
          }
          const ids = [];
          if (options.ids) {
            ids.push(...options.ids);
          }
          if (options.documents) {
            const ids2 = options.documents?.map((document) => {
              return document.metadata?.raw_id;
            }).filter((id) => id != null);
            ids2.push(...ids2);
          }
          if (ids.length > 0) {
            await store.delete({ ids });
          }
        },
        async addDocumentsFunction(store, documents, options) {
          let ids = options?.ids ?? [];
          ids = documents.map((document, i) => {
            const id = ids[i] ?? crypto3.randomUUID();
            document.metadata = { ...document.metadata, raw_id: id };
            return id;
          });
          await store.addDocuments(documents, { ids });
        },
        async freeFunction() {
          lunaDBStore.client.free();
          lunaDBStore = void 0;
        }
      }
    );
    return wrapperStore;
  });
}
__name(apply2, "apply");
var LunaDBVectorStore = class _LunaDBVectorStore extends SaveableVectorStore {
  static {
    __name(this, "LunaDBVectorStore");
  }
  client;
  docstore;
  getDocstore() {
    return this.docstore;
  }
  _vectorstoreType() {
    return "luna-db";
  }
  constructor(client, embeddings, args) {
    super(embeddings, {});
    this.client = client;
    this.embeddings = embeddings;
    this.docstore = args?.docstore ?? new SynchronousInMemoryDocstore();
  }
  /**
   * Adds documents to the Voy database. The documents are embedded using embeddings provided while instantiating the class.
   * @param documents An array of `Document` instances associated with the vectors.
   */
  async addDocuments(documents, options) {
    const texts = documents.map(({ pageContent }) => pageContent);
    if (documents.length === 0) {
      return;
    }
    const restResults = await this.embeddings.embedDocuments(texts);
    await this.addVectors(restResults, documents, options);
  }
  /**
   * Adds vectors to the Voy database. The vectors are associated with
   * the provided documents.
   * @param vectors An array of vectors to be added to the database.
   * @param documents An array of `Document` instances associated with the vectors.
   */
  async addVectors(vectors, documents, options) {
    if (vectors.length === 0) {
      return;
    }
    if (vectors.length !== documents.length) {
      throw new Error(`Vectors and metadata must have the same length`);
    }
    const documentIds = options?.ids ?? documents.map(() => crypto3.randomUUID());
    const embeddings = documentIds.map((documentId, idx) => {
      const resource = { id: documentId, embeddings: vectors[idx] };
      this.docstore.add({ [documentId]: documents[idx] });
      return resource;
    });
    this.client.add({ embeddings });
    return documentIds;
  }
  /**
   * Searches for vectors in the Voy database that are similar to the
   * provided query vector.
   * @param query The query vector.
   * @param k The number of similar vectors to return.
   * @returns A promise that resolves with an array of tuples, each containing a `Document` instance and a similarity score.
   */
  async similaritySearchVectorWithScore(query, k) {
    const docStoreSize = this.docstore._docs.size;
    const itemsToQuery = Math.min(docStoreSize, k);
    if (itemsToQuery > docStoreSize) {
      console.warn(
        `k (${k}) is greater than the number of elements in the index (${docStoreSize}), setting k to ${itemsToQuery}`
      );
    }
    const results = this.client.search(
      new Float32Array(query),
      itemsToQuery
    );
    return results.neighbors.map(({ id, distance }) => {
      return [this.docstore.search(id), distance];
    });
  }
  /**
   * Method to delete data from the Voy index. It can delete data based
   * on specific IDs or a filter.
   * @param params Object that includes either an array of IDs or a filter for the data to be deleted.
   * @returns Promise that resolves when the deletion is complete.
   */
  async delete(params) {
    if (params.deleteAll === true) {
      this.client.clear();
      this.docstore._docs.clear();
      return;
    }
    const documentIds = params.ids;
    if (documentIds == null || documentIds.length < 1) {
      throw new Error("No documentIds provided to delete.");
    }
    const mappingIds = Array.from(this.docstore._docs.keys());
    const missingIds = documentIds.filter((id) => !mappingIds.includes(id));
    if (missingIds.length > 0) {
      throw new Error(
        `Some specified documentIds do not exist in the current store. DocumentIds not found: ${Array.from(
          missingIds
        ).join(", ")}`
      );
    }
    const embeddings = documentIds.map((id) => {
      this.docstore._docs.delete(id);
      return id;
    });
    this.client.remove(embeddings);
  }
  /**
   * Loads a VoyStore from a specified directory.
   * @param directory The directory to load the VoyStore from.
   * @param embeddings An Embeddings object.
   * @returns A Promise that resolves with a new VoyStore instance.
   */
  static async load(directory, embeddings) {
    const fs3 = await import("node:fs/promises");
    const path3 = await import("node:path");
    const readStore = /* @__PURE__ */ __name((directory2) => fs3.readFile(path3.join(directory2, "docstore.json"), "utf-8").then(JSON.parse), "readStore");
    const readIndex = /* @__PURE__ */ __name(async (directory2) => {
      const data = await fs3.readFile(
        path3.join(directory2, "luna_db.index")
      );
      return LunaDB.deserialize(data);
    }, "readIndex");
    const [docstoreFiles, index] = await Promise.all([
      readStore(directory),
      readIndex(directory)
    ]);
    const docstore = new SynchronousInMemoryDocstore(new Map(docstoreFiles));
    return new this(index, embeddings, { docstore });
  }
  /**
   * Saves the current state of the VoyStore to a specified directory.
   * @param directory The directory to save the state to.
   * @returns A Promise that resolves when the state has been saved.
   */
  async save(directory) {
    const fs3 = await import("node:fs/promises");
    const path3 = await import("node:path");
    await fs3.mkdir(directory, { recursive: true });
    await Promise.all([
      await fs3.writeFile(
        path3.join(directory, "luna_db.index"),
        this.client.serialize()
      ),
      await fs3.writeFile(
        path3.join(directory, "docstore.json"),
        JSON.stringify(Array.from(this.docstore._docs.entries()))
      )
    ]);
  }
  /**
   * Creates a new `VoyVectorStore` instance from an array of text strings. The text
   * strings are converted to `Document` instances and added to the Voy
   * database.
   * @param texts An array of text strings.
   * @param metadatas An array of metadata objects or a single metadata object. If an array is provided, it must have the same length as the `texts` array.
   * @param embeddings An `Embeddings` instance used to generate embeddings for the documents.
   * @param client An instance of Voy client to use in the underlying operations.
   * @returns A promise that resolves with a new `VoyVectorStore` instance.
   */
  static async fromTexts(texts, metadatas, embeddings, client, options) {
    const docs = [];
    for (let i = 0; i < texts.length; i += 1) {
      const metadata = Array.isArray(metadatas) ? metadatas[i] : metadatas;
      const newDoc = new Document({ pageContent: texts[i], metadata });
      docs.push(newDoc);
    }
    return _LunaDBVectorStore.fromDocuments(
      docs,
      embeddings,
      client,
      options
    );
  }
  /**
   * Creates a new `VoyVectorStore` instance from an array of `Document` instances.
   * The documents are added to the Voy database.
   * @param docs An array of `Document` instances.
   * @param embeddings An `Embeddings` instance used to generate embeddings for the documents.
   * @param client An instance of Voy client to use in the underlying operations.
   * @returns A promise that resolves with a new `VoyVectorStore` instance.
   */
  static async fromDocuments(docs, embeddings, client, options) {
    const instance = new _LunaDBVectorStore(client, embeddings, options);
    await instance.addDocuments(docs);
    return instance;
  }
};

// src/vectorstore/milvus.ts
import { createLogger as createLogger3 } from "koishi-plugin-chatluna/utils/logger";
import { ChatLunaSaveableVectorStore as ChatLunaSaveableVectorStore3 } from "koishi-plugin-chatluna/llm-core/model/base";
import { Document as Document2 } from "@langchain/core/documents";
var logger3;
async function apply3(ctx, config, plugin) {
  logger3 = createLogger3(ctx, "chatluna-vector-store-service");
  if (!config.vectorStore.includes("milvus")) {
    return;
  }
  const MilvusClass = await importMilvus();
  plugin.registerVectorStore("milvus", async (params) => {
    const embeddings = params.embeddings;
    const key = params.key ?? "chatluna";
    let vectorStore2 = new MilvusClass(embeddings, {
      collectionName: "chatluna_collection",
      partitionName: key,
      url: config.milvusUrl,
      autoId: false,
      username: config.milvusUsername,
      password: config.milvusPassword,
      textFieldMaxLength: 3e3
    });
    logger3.debug(`Loading milvus store from %c`, key);
    const testVector = await embeddings.embedDocuments(["test"]);
    if (testVector.length === 0) {
      throw new Error(
        "Embedding dismension is 0, Try to change the embeddings model."
      );
    }
    const createCollection = /* @__PURE__ */ __name(async () => {
      await vectorStore2.client.releasePartitions({
        collection_name: "chatluna_collection",
        partition_names: [key]
      });
      await vectorStore2.client.releaseCollection({
        collection_name: "chatluna_collection"
      });
      await vectorStore2.client.dropPartition({
        collection_name: "chatluna_collection",
        partition_name: key
      });
      await vectorStore2.client.dropCollection({
        collection_name: "chatluna_collection"
      });
      await vectorStore2.ensureCollection(testVector, [
        {
          pageContent: "test",
          metadata: {
            raw_id: "z".repeat(100),
            source: "z".repeat(100),
            expirationDate: "z".repeat(100),
            type: "z".repeat(100),
            importance: 0
          }
        }
      ]);
      await vectorStore2.ensurePartition();
    }, "createCollection");
    try {
      await vectorStore2.ensureCollection(testVector, [
        {
          pageContent: "test",
          metadata: {
            raw_id: "z".repeat(100),
            source: "z".repeat(100),
            expirationDate: "z".repeat(100),
            type: "z".repeat(100),
            importance: 0
          }
        }
      ]);
      await vectorStore2.ensurePartition();
      await vectorStore2.similaritySearchVectorWithScore(testVector[0], 10);
    } catch (e) {
      try {
        await createCollection();
      } catch (e2) {
        logger3.error(e2);
      }
      logger3.error(e);
    }
    const wrapperStore = new ChatLunaSaveableVectorStore3(
      vectorStore2,
      {
        async deletableFunction(store, options) {
          if (options.deleteAll) {
            await vectorStore2.client.releasePartitions({
              collection_name: "chatluna_collection",
              partition_names: [key]
            });
            await vectorStore2.client.releaseCollection({
              collection_name: "chatluna_collection"
            });
            await vectorStore2.client.dropPartition({
              collection_name: "chatluna_collection",
              partition_name: key
            });
            await vectorStore2.client.dropCollection({
              collection_name: "chatluna_collection"
            });
            return;
          }
          const ids = [];
          if (options.ids) {
            ids.push(
              ...options.ids.map((id) => id.replaceAll("-", "_"))
            );
          }
          if (options.documents) {
            const documentIds = options.documents?.map((document) => {
              const id = document.metadata?.raw_id;
              return id != null ? id.replaceAll("-", "_") : void 0;
            }).filter((id) => id != null);
            ids.push(...documentIds);
          }
          if (ids.length < 1) {
            return;
          }
          const client = store.client;
          const deleteResp = await client.delete({
            collection_name: store.collectionName,
            partition_name: key,
            ids
          });
          if (deleteResp.status.error_code !== "Success") {
            throw new Error(
              `Error deleting data with ids: ${JSON.stringify(deleteResp)}`
            );
          }
        },
        async addDocumentsFunction(store, documents, options) {
          let ids = options?.ids ?? [];
          ids = documents.map((document, i) => {
            const id = ids[i] ?? crypto.randomUUID();
            document.metadata = {
              source: "unknown",
              ...document.metadata,
              raw_id: id
            };
            return id.replaceAll("-", "_");
          });
          await store.addDocuments(documents, {
            ids
          });
        },
        async similaritySearchVectorWithScoreFunction(store, query, k, filter) {
          const hasColResp = await store.client.hasCollection({
            collection_name: store.collectionName
          });
          if (hasColResp.status.error_code !== "Success") {
            throw new Error(
              `Error checking collection: ${hasColResp}`
            );
          }
          if (hasColResp.value === false) {
            logger3.warn(
              `Collection ${store.collectionName} does not exist, ensure all data and recreate collection.`
            );
            await createCollection();
          }
          const filterStr = filter ?? "";
          await store.grabCollectionFields();
          const loadResp = await store.client.loadCollectionSync({
            collection_name: store.collectionName
          });
          if (loadResp.error_code !== "Success") {
            throw new Error(`Error loading collection: ${loadResp}`);
          }
          const outputFields = store.fields.filter(
            (field) => field !== store.vectorField
          );
          const searchResp = await store.client.search({
            collection_name: store.collectionName,
            search_params: {
              anns_field: store.vectorField,
              topk: k,
              metric_type: store.indexCreateParams.metric_type,
              params: JSON.stringify(store.indexSearchParams)
            },
            output_fields: outputFields,
            // add partition_names
            partition_names: store.partitionName ? [store.partitionName] : void 0,
            // DataType.FloatVector
            vector_type: 101,
            vectors: [query],
            filter: filterStr
          });
          if (searchResp.status.error_code !== "Success") {
            throw new Error(
              `Error searching data: ${JSON.stringify(searchResp)}`
            );
          }
          const results = [];
          searchResp.results.forEach((result) => {
            const fields = {
              pageContent: "",
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              metadata: {}
            };
            Object.keys(result).forEach((key2) => {
              if (key2 === store.textField) {
                fields.pageContent = result[key2];
              } else if (store.fields.includes(key2) || key2 === store.primaryField) {
                if (typeof result[key2] === "string") {
                  const { isJson, obj } = checkJsonString(
                    result[key2]
                  );
                  fields.metadata[key2] = isJson ? obj : result[key2];
                } else {
                  fields.metadata[key2] = result[key2];
                }
              }
            });
            results.push([new Document2(fields), result.score]);
          });
          return results;
        },
        async freeFunction() {
          vectorStore2 = void 0;
        }
      }
    );
    return wrapperStore;
  });
}
__name(apply3, "apply");
async function importMilvus() {
  try {
    await import("@zilliz/milvus2-sdk-node");
    const store = await import("@langchain/community/vectorstores/milvus");
    return store.Milvus;
  } catch (err) {
    logger3.error(err);
    throw new Error(
      "Please install milvus as a dependency with, e.g. `npm install -S @zilliz/milvus2-sdk-node`"
    );
  }
}
__name(importMilvus, "importMilvus");
function checkJsonString(value) {
  try {
    const result = JSON.parse(value);
    return { isJson: true, obj: result };
  } catch (e) {
    return { isJson: false, obj: null };
  }
}
__name(checkJsonString, "checkJsonString");

// src/vectorstore/neo4j.ts
import { createLogger as createLogger4 } from "koishi-plugin-chatluna/utils/logger";
import { ChatLunaSaveableVectorStore as ChatLunaSaveableVectorStore4 } from "koishi-plugin-chatluna/llm-core/model/base";
var logger4;
async function apply4(ctx, config, plugin) {
  logger4 = createLogger4(ctx, "chatluna-vector-store-service");
  if (!config.vectorStore.includes("neo4j")) {
    return;
  }
  const { Neo4jVectorStoreInstace, neo4j } = await importNeo4j();
  plugin.registerVectorStore("neo4j", async (params) => {
    const embeddings = params.embeddings;
    const testVector = await embeddings.embedQuery("test");
    if (testVector.length === 0) {
      throw new Error(
        "Embedding dimension is 0, Try to change the embeddings model."
      );
    }
    const vectorStoreConfig = {
      url: config.neo4jUrl,
      username: config.neo4jUsername,
      password: config.neo4jPassword,
      indexName: params.key ?? "chatluna",
      nodeLabel: "Embedding",
      textNodeProperty: "text",
      embeddingNodeProperty: "embedding",
      searchType: "vector"
      // Support for hybrid search if needed
    };
    let driver;
    try {
      driver = neo4j.driver(
        vectorStoreConfig.url,
        neo4j.auth.basic(
          vectorStoreConfig.username,
          vectorStoreConfig.password
        )
      );
    } catch (err) {
      logger4.error("Failed to create Neo4j driver", err);
      throw err;
    }
    try {
      let vectorStore2;
      try {
        vectorStore2 = await Neo4jVectorStoreInstace.fromExistingIndex(
          embeddings,
          vectorStoreConfig
        );
        logger4.debug(
          `Connected to existing Neo4j index: ${vectorStoreConfig.indexName}`
        );
      } catch (error) {
        logger4.debug(
          `Creating new Neo4j index: ${vectorStoreConfig.indexName}`
        );
        vectorStore2 = new Neo4jVectorStoreInstace(
          embeddings,
          vectorStoreConfig
        );
        await vectorStore2.createNewIndex();
      }
      logger4.debug(
        `Neo4j vector store ready with index ${params.key ?? "chatluna"}`
      );
      const wrapperStore = new ChatLunaSaveableVectorStore4(vectorStore2, {
        async deletableFunction(_store, options) {
          if (options.deleteAll) {
            const session2 = driver.session();
            try {
              await session2.run(
                `MATCH (n:${vectorStoreConfig.nodeLabel} {indexName: $indexName}) DETACH DELETE n`,
                { indexName: vectorStoreConfig.indexName }
              );
            } finally {
              await session2.close();
            }
            return;
          }
          const ids = [];
          if (options.ids) {
            ids.push(...options.ids);
          }
          if (options.documents) {
            const documentIds = options.documents?.map((document) => {
              return document.metadata?.raw_id;
            }).filter((id) => id != null);
            ids.push(...documentIds);
          }
          if (ids.length < 1) {
            return;
          }
          const session = driver.session();
          try {
            await session.run(
              `MATCH (n:${vectorStoreConfig.nodeLabel} {indexName: $indexName})
                                WHERE n.id IN $ids
                                DETACH DELETE n`,
              { indexName: vectorStoreConfig.indexName, ids }
            );
          } finally {
            await session.close();
          }
        },
        async addDocumentsFunction(store, documents) {
          const processedDocuments = documents.map((document) => {
            const id = crypto.randomUUID();
            document.metadata = {
              ...document.metadata,
              raw_id: id
            };
            return document;
          });
          await store.addDocuments(processedDocuments);
        },
        async freeFunction() {
          await vectorStore2.close();
          if (driver) {
            await driver.close();
          }
        },
        async saveableFunction() {
        }
      });
      return wrapperStore;
    } catch (error) {
      logger4.error("Error initializing Neo4j vector store", error);
      throw error;
    }
  });
}
__name(apply4, "apply");
async function importNeo4j() {
  try {
    try {
      const { Neo4jVectorStore } = await import("@langchain/community/vectorstores/neo4j_vector");
      return {
        neo4j: await import("neo4j-driver"),
        Neo4jVectorStoreInstace: Neo4jVectorStore
      };
    } catch (err) {
      logger4.warn(
        "Failed to import Neo4jVectorStore from @langchain/community, trying alternate sources"
      );
      throw err;
    }
  } catch (err) {
    logger4.error(err);
    throw new Error(
      "Please install neo4j-driver and @langchain/community as dependencies with, e.g. `npm install -S neo4j-driver @langchain/community`"
    );
  }
}
__name(importNeo4j, "importNeo4j");

// src/vectorstore/redis.ts
import { RedisVectorStore } from "@langchain/redis";
import { createLogger as createLogger5 } from "koishi-plugin-chatluna/utils/logger";
import { ChatLunaSaveableVectorStore as ChatLunaSaveableVectorStore5 } from "koishi-plugin-chatluna/llm-core/model/base";
var logger5;
async function apply5(ctx, config, plugin) {
  logger5 = createLogger5(ctx, "chatluna-vector-store-service");
  if (!config.vectorStore.includes("redis")) {
    return;
  }
  await importRedis();
  plugin.registerVectorStore("redis", async (params) => {
    const embeddings = params.embeddings;
    const client = await createClient(config.redisUrl);
    await client.connect();
    const vectorStore2 = new RedisVectorStore(embeddings, {
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      redisClient: client,
      indexName: params.key ?? "chatluna"
    });
    const testVector = await embeddings.embedQuery("test");
    if (testVector.length === 0) {
      throw new Error(
        "Embedding dismension is 0, Try to change the embeddings model."
      );
    }
    try {
      await vectorStore2.createIndex(testVector.length);
    } catch (e) {
      logger5.warn(
        "Some error occurred when creating redis index. Will drop and recreate index."
      );
      logger5.error(e);
      try {
        await vectorStore2.dropIndex(true);
        await vectorStore2.createIndex(testVector.length);
      } catch (e2) {
        logger5.error(e2);
      }
    }
    try {
      await vectorStore2.similaritySearchVectorWithScore(testVector, 1);
    } catch (e) {
      logger5.warn(
        "Some error occurred when query redis index. Will drop and recreate index."
      );
      try {
        await vectorStore2.dropIndex(true);
        await vectorStore2.createIndex(testVector.length);
      } catch (e2) {
        logger5.error(e2);
      }
      logger5.error(e);
    }
    logger5.debug(`Loading redis store from %c`, vectorStore2.indexName);
    const wrapperStore = new ChatLunaSaveableVectorStore5(
      vectorStore2,
      {
        async deletableFunction(store, options) {
          if (options.deleteAll) {
            await client.ft.dropIndex(vectorStore2.indexName, {
              DD: true
            });
            return;
          }
          const ids = [];
          if (options.ids) {
            ids.push(...options.ids);
          }
          if (options.documents) {
            const documentIds = options.documents?.map((document) => {
              return document.metadata?.raw_id;
            }).filter((id) => id != null);
            ids.push(...documentIds);
          }
          if (ids.length < 1) {
            return;
          }
          for (const id of ids) {
            await client.del(store.keyPrefix + id);
          }
        },
        async addDocumentsFunction(store, documents, options) {
          let keys = options?.keys ?? [];
          keys = documents.map((document, i) => {
            const id = keys[i] ?? crypto.randomUUID();
            document.metadata = { ...document.metadata, raw_id: id };
            return store.keyPrefix + id;
          });
          await store.addDocuments(documents, {
            keys,
            batchSize: options?.batchSize
          });
        },
        async freeFunction() {
          await client.disconnect();
        },
        async saveableFunction(store) {
        }
      }
    );
    return wrapperStore;
  });
}
__name(apply5, "apply");
async function createClient(url) {
  const redis = await importRedis();
  return redis.createClient({ url });
}
__name(createClient, "createClient");
async function importRedis() {
  try {
    const any = await import("redis");
    return any;
  } catch (err) {
    logger5.error(err);
    throw new Error(
      "Please install redis as a dependency with, e.g. `npm install -S redis`"
    );
  }
}
__name(importRedis, "importRedis");

// src/vectorstore.ts
async function vectorStore(ctx, config, plugin) {
  const middlewares = (
    // middleware start
    [apply, apply2, apply3, apply4, apply5]
  );
  for (const middleware of middlewares) {
    try {
      await middleware(ctx, config, plugin);
    } catch (error) {
      ctx.logger.error(error);
    }
  }
}
__name(vectorStore, "vectorStore");

// src/index.ts
function apply6(ctx, config) {
  const plugin = new ChatLunaPlugin(
    ctx,
    config,
    "vector-store-service",
    false
  );
  ctx.on("ready", async () => {
    plugin.registerToService();
    await vectorStore(ctx, config, plugin);
  });
}
__name(apply6, "apply");
var Config = Schema.intersect([
  Schema.object({
    vectorStore: Schema.array(
      Schema.union([
        Schema.const("faiss").description("Faiss"),
        Schema.const("redis").description("Redis"),
        Schema.const("milvus").description("Milvus"),
        Schema.const("neo4j").description("Neo4j"),
        Schema.const("luna-vdb").description("lunavdb")
      ])
    ).default(["luna-vdb"]).role("select")
  }),
  Schema.object({
    redisUrl: Schema.string().role("url").default("redis://127.0.0.1:6379")
  }),
  Schema.object({
    milvusUrl: Schema.string().role("url").default("http://127.0.0.1:19530"),
    milvusUsername: Schema.string().default(""),
    milvusPassword: Schema.string().role("secret").default("")
  }),
  Schema.object({
    neo4jUrl: Schema.string().role("url").default("neo4j://localhost:7687"),
    neo4jUsername: Schema.string().default("neo4j"),
    neo4jPassword: Schema.string().role("secret").default("")
  })
]).i18n({
  "zh-CN": require_zh_CN_schema(),
  "en-US": require_en_US_schema()
});
var inject = ["chatluna"];
var usage = `
现我们不再直接依赖向量数据库的相关库，你需要自己安装相关依赖到 koishi 根目录下。

要查看如何配置 Faiss 数据库，看[这里](https://js.langchain.com/docs/integrations/vectorstores/faiss/)

要查看如何配置 Redis 数据库，看[这里](https://js.langchain.com/docs/integrations/vectorstores/redis/)

要查看如何配置 Milvus 数据库，看[这里](https://js.langchain.com/docs/integrations/vectorstores/milvus/)

要查看如何配置 Neo4j 数据库，看[这里](https://js.langchain.com/docs/integrations/vectorstores/neo4jvector/)

目前配置 Faiss 数据库安装后可能会导致 koishi 环境不安全，如果安装完成后进行某些操作完成后出现了问题（如，升级 node 版本），开发者不对此负直接责任。
`;
var name = "chatluna-vector-store-service";
export {
  Config,
  apply6 as apply,
  inject,
  name,
  usage
};
