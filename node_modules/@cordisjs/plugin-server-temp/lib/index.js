"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var src_exports = {};
__export(src_exports, {
  default: () => src_default
});
module.exports = __toCommonJS(src_exports);
var import_cordis = require("cordis");
var import_promises = require("node:fs/promises");
var import_node_fs = require("node:fs");
var import_cosmokit = require("cosmokit");
var import_url = require("url");
var import_stream = require("stream");
var TempServer = class extends import_cordis.Service {
  constructor(ctx, config) {
    super(ctx, "server.temp");
    this.ctx = ctx;
    this.config = config;
    const logger = ctx.logger("temp");
    this.path = (0, import_cosmokit.sanitize)(config.path);
    this.selfUrl = config.selfUrl || ctx.server.config.selfUrl;
    if (!this.selfUrl) {
      logger.warn("missing selfUrl configuration");
    }
    ctx.server.get(this.path + "/:name", async (koa) => {
      logger.debug(koa.params.name);
      const entry = this.entries[koa.params.name];
      if (!entry) return koa.status = 404;
      koa.body = (0, import_node_fs.createReadStream)(entry.path);
    });
  }
  static {
    __name(this, "TempServer");
  }
  static inject = ["server", "http"];
  path;
  selfUrl;
  baseDir;
  entries = /* @__PURE__ */ Object.create(null);
  async start() {
    this.baseDir = this.ctx.baseDir + "/temp/" + Math.random().toString(36).slice(2) + "/";
    await (0, import_promises.mkdir)(this.baseDir, { recursive: true });
  }
  async stop() {
    await (0, import_promises.rm)(this.baseDir, { recursive: true });
  }
  async create(data) {
    const name = Math.random().toString(36).slice(2);
    const url = this.selfUrl + this.path + "/" + name;
    let path;
    if (typeof data === "string") {
      if (new URL(data).protocol === "file:") {
        path = (0, import_url.fileURLToPath)(data);
      } else {
        const stream = await this.ctx.http.get(data, { responseType: "stream" });
        path = this.baseDir + name;
        await (0, import_promises.writeFile)(path, import_stream.Readable.fromWeb(stream));
      }
    } else {
      path = this.baseDir + name;
      await (0, import_promises.writeFile)(path, data instanceof ReadableStream ? import_stream.Readable.fromWeb(data) : data);
    }
    return this.ctx.effect(() => {
      const timer = setTimeout(() => dispose(), this.config.maxAge);
      const dispose = /* @__PURE__ */ __name(async () => {
        clearTimeout(timer);
        delete this.entries[name];
        if (path.startsWith(this.baseDir)) await (0, import_promises.rm)(path);
      }, "dispose");
      return this.entries[name] = { path, url, dispose };
    });
  }
};
((TempServer2) => {
  TempServer2.Config = import_cordis.Schema.object({
    path: import_cordis.Schema.string().default("/temp"),
    selfUrl: import_cordis.Schema.string().role("link").description("此服务暴露在公网的地址。缺省时将使用全局配置。"),
    maxAge: import_cordis.Schema.number().default(import_cosmokit.Time.minute * 5).description("临时文件的默认最大存活时间。")
  });
})(TempServer || (TempServer = {}));
var src_default = TempServer;
//# sourceMappingURL=index.js.map
